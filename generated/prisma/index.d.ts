
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Hito
 * 
 */
export type Hito = $Result.DefaultSelection<Prisma.$HitoPayload>
/**
 * Model PaqueteTrabajo
 * 
 */
export type PaqueteTrabajo = $Result.DefaultSelection<Prisma.$PaqueteTrabajoPayload>
/**
 * Model Partida
 * 
 */
export type Partida = $Result.DefaultSelection<Prisma.$PartidaPayload>
/**
 * Model ProcesoConstrutivo
 * 
 */
export type ProcesoConstrutivo = $Result.DefaultSelection<Prisma.$ProcesoConstrutivoPayload>
/**
 * Model PlanMaestro
 * 
 */
export type PlanMaestro = $Result.DefaultSelection<Prisma.$PlanMaestroPayload>
/**
 * Model PmFrente
 * 
 */
export type PmFrente = $Result.DefaultSelection<Prisma.$PmFrentePayload>
/**
 * Model PmFrentePartida
 * 
 */
export type PmFrentePartida = $Result.DefaultSelection<Prisma.$PmFrentePartidaPayload>
/**
 * Model PmProgramacion
 * 
 */
export type PmProgramacion = $Result.DefaultSelection<Prisma.$PmProgramacionPayload>
/**
 * Model EquipoCargo
 * 
 */
export type EquipoCargo = $Result.DefaultSelection<Prisma.$EquipoCargoPayload>
/**
 * Model EquipoTrabajo
 * 
 */
export type EquipoTrabajo = $Result.DefaultSelection<Prisma.$EquipoTrabajoPayload>
/**
 * Model PmEquipo
 * 
 */
export type PmEquipo = $Result.DefaultSelection<Prisma.$PmEquipoPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model ModeloVivienda
 * 
 */
export type ModeloVivienda = $Result.DefaultSelection<Prisma.$ModeloViviendaPayload>
/**
 * Model Proyecto
 * 
 */
export type Proyecto = $Result.DefaultSelection<Prisma.$ProyectoPayload>
/**
 * Model Vivienda
 * 
 */
export type Vivienda = $Result.DefaultSelection<Prisma.$ViviendaPayload>
/**
 * Model PlanSemanal
 * 
 */
export type PlanSemanal = $Result.DefaultSelection<Prisma.$PlanSemanalPayload>
/**
 * Model PlanSemanalPartida
 * 
 */
export type PlanSemanalPartida = $Result.DefaultSelection<Prisma.$PlanSemanalPartidaPayload>
/**
 * Model CausaNoCumplimiento
 * 
 */
export type CausaNoCumplimiento = $Result.DefaultSelection<Prisma.$CausaNoCumplimientoPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Hitos
 * const hitos = await prisma.hito.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Hitos
   * const hitos = await prisma.hito.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.hito`: Exposes CRUD operations for the **Hito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hitos
    * const hitos = await prisma.hito.findMany()
    * ```
    */
  get hito(): Prisma.HitoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paqueteTrabajo`: Exposes CRUD operations for the **PaqueteTrabajo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaqueteTrabajos
    * const paqueteTrabajos = await prisma.paqueteTrabajo.findMany()
    * ```
    */
  get paqueteTrabajo(): Prisma.PaqueteTrabajoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partida`: Exposes CRUD operations for the **Partida** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partidas
    * const partidas = await prisma.partida.findMany()
    * ```
    */
  get partida(): Prisma.PartidaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.procesoConstrutivo`: Exposes CRUD operations for the **ProcesoConstrutivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcesoConstrutivos
    * const procesoConstrutivos = await prisma.procesoConstrutivo.findMany()
    * ```
    */
  get procesoConstrutivo(): Prisma.ProcesoConstrutivoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planMaestro`: Exposes CRUD operations for the **PlanMaestro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanMaestros
    * const planMaestros = await prisma.planMaestro.findMany()
    * ```
    */
  get planMaestro(): Prisma.PlanMaestroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pmFrente`: Exposes CRUD operations for the **PmFrente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PmFrentes
    * const pmFrentes = await prisma.pmFrente.findMany()
    * ```
    */
  get pmFrente(): Prisma.PmFrenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pmFrentePartida`: Exposes CRUD operations for the **PmFrentePartida** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PmFrentePartidas
    * const pmFrentePartidas = await prisma.pmFrentePartida.findMany()
    * ```
    */
  get pmFrentePartida(): Prisma.PmFrentePartidaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pmProgramacion`: Exposes CRUD operations for the **PmProgramacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PmProgramacions
    * const pmProgramacions = await prisma.pmProgramacion.findMany()
    * ```
    */
  get pmProgramacion(): Prisma.PmProgramacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipoCargo`: Exposes CRUD operations for the **EquipoCargo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipoCargos
    * const equipoCargos = await prisma.equipoCargo.findMany()
    * ```
    */
  get equipoCargo(): Prisma.EquipoCargoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipoTrabajo`: Exposes CRUD operations for the **EquipoTrabajo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipoTrabajos
    * const equipoTrabajos = await prisma.equipoTrabajo.findMany()
    * ```
    */
  get equipoTrabajo(): Prisma.EquipoTrabajoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pmEquipo`: Exposes CRUD operations for the **PmEquipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PmEquipos
    * const pmEquipos = await prisma.pmEquipo.findMany()
    * ```
    */
  get pmEquipo(): Prisma.PmEquipoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modeloVivienda`: Exposes CRUD operations for the **ModeloVivienda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModeloViviendas
    * const modeloViviendas = await prisma.modeloVivienda.findMany()
    * ```
    */
  get modeloVivienda(): Prisma.ModeloViviendaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proyecto`: Exposes CRUD operations for the **Proyecto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proyectos
    * const proyectos = await prisma.proyecto.findMany()
    * ```
    */
  get proyecto(): Prisma.ProyectoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vivienda`: Exposes CRUD operations for the **Vivienda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viviendas
    * const viviendas = await prisma.vivienda.findMany()
    * ```
    */
  get vivienda(): Prisma.ViviendaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planSemanal`: Exposes CRUD operations for the **PlanSemanal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanSemanals
    * const planSemanals = await prisma.planSemanal.findMany()
    * ```
    */
  get planSemanal(): Prisma.PlanSemanalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planSemanalPartida`: Exposes CRUD operations for the **PlanSemanalPartida** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanSemanalPartidas
    * const planSemanalPartidas = await prisma.planSemanalPartida.findMany()
    * ```
    */
  get planSemanalPartida(): Prisma.PlanSemanalPartidaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.causaNoCumplimiento`: Exposes CRUD operations for the **CausaNoCumplimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CausaNoCumplimientos
    * const causaNoCumplimientos = await prisma.causaNoCumplimiento.findMany()
    * ```
    */
  get causaNoCumplimiento(): Prisma.CausaNoCumplimientoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Hito: 'Hito',
    PaqueteTrabajo: 'PaqueteTrabajo',
    Partida: 'Partida',
    ProcesoConstrutivo: 'ProcesoConstrutivo',
    PlanMaestro: 'PlanMaestro',
    PmFrente: 'PmFrente',
    PmFrentePartida: 'PmFrentePartida',
    PmProgramacion: 'PmProgramacion',
    EquipoCargo: 'EquipoCargo',
    EquipoTrabajo: 'EquipoTrabajo',
    PmEquipo: 'PmEquipo',
    Usuario: 'Usuario',
    ModeloVivienda: 'ModeloVivienda',
    Proyecto: 'Proyecto',
    Vivienda: 'Vivienda',
    PlanSemanal: 'PlanSemanal',
    PlanSemanalPartida: 'PlanSemanalPartida',
    CausaNoCumplimiento: 'CausaNoCumplimiento'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "hito" | "paqueteTrabajo" | "partida" | "procesoConstrutivo" | "planMaestro" | "pmFrente" | "pmFrentePartida" | "pmProgramacion" | "equipoCargo" | "equipoTrabajo" | "pmEquipo" | "usuario" | "modeloVivienda" | "proyecto" | "vivienda" | "planSemanal" | "planSemanalPartida" | "causaNoCumplimiento"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Hito: {
        payload: Prisma.$HitoPayload<ExtArgs>
        fields: Prisma.HitoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HitoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HitoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>
          }
          findFirst: {
            args: Prisma.HitoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HitoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>
          }
          findMany: {
            args: Prisma.HitoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>[]
          }
          create: {
            args: Prisma.HitoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>
          }
          createMany: {
            args: Prisma.HitoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HitoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>[]
          }
          delete: {
            args: Prisma.HitoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>
          }
          update: {
            args: Prisma.HitoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>
          }
          deleteMany: {
            args: Prisma.HitoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HitoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HitoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>[]
          }
          upsert: {
            args: Prisma.HitoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitoPayload>
          }
          aggregate: {
            args: Prisma.HitoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHito>
          }
          groupBy: {
            args: Prisma.HitoGroupByArgs<ExtArgs>
            result: $Utils.Optional<HitoGroupByOutputType>[]
          }
          count: {
            args: Prisma.HitoCountArgs<ExtArgs>
            result: $Utils.Optional<HitoCountAggregateOutputType> | number
          }
        }
      }
      PaqueteTrabajo: {
        payload: Prisma.$PaqueteTrabajoPayload<ExtArgs>
        fields: Prisma.PaqueteTrabajoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaqueteTrabajoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaqueteTrabajoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>
          }
          findFirst: {
            args: Prisma.PaqueteTrabajoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaqueteTrabajoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>
          }
          findMany: {
            args: Prisma.PaqueteTrabajoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>[]
          }
          create: {
            args: Prisma.PaqueteTrabajoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>
          }
          createMany: {
            args: Prisma.PaqueteTrabajoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaqueteTrabajoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>[]
          }
          delete: {
            args: Prisma.PaqueteTrabajoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>
          }
          update: {
            args: Prisma.PaqueteTrabajoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>
          }
          deleteMany: {
            args: Prisma.PaqueteTrabajoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaqueteTrabajoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaqueteTrabajoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>[]
          }
          upsert: {
            args: Prisma.PaqueteTrabajoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTrabajoPayload>
          }
          aggregate: {
            args: Prisma.PaqueteTrabajoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaqueteTrabajo>
          }
          groupBy: {
            args: Prisma.PaqueteTrabajoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaqueteTrabajoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaqueteTrabajoCountArgs<ExtArgs>
            result: $Utils.Optional<PaqueteTrabajoCountAggregateOutputType> | number
          }
        }
      }
      Partida: {
        payload: Prisma.$PartidaPayload<ExtArgs>
        fields: Prisma.PartidaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartidaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartidaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>
          }
          findFirst: {
            args: Prisma.PartidaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartidaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>
          }
          findMany: {
            args: Prisma.PartidaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>[]
          }
          create: {
            args: Prisma.PartidaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>
          }
          createMany: {
            args: Prisma.PartidaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartidaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>[]
          }
          delete: {
            args: Prisma.PartidaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>
          }
          update: {
            args: Prisma.PartidaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>
          }
          deleteMany: {
            args: Prisma.PartidaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartidaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartidaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>[]
          }
          upsert: {
            args: Prisma.PartidaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartidaPayload>
          }
          aggregate: {
            args: Prisma.PartidaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartida>
          }
          groupBy: {
            args: Prisma.PartidaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartidaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartidaCountArgs<ExtArgs>
            result: $Utils.Optional<PartidaCountAggregateOutputType> | number
          }
        }
      }
      ProcesoConstrutivo: {
        payload: Prisma.$ProcesoConstrutivoPayload<ExtArgs>
        fields: Prisma.ProcesoConstrutivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcesoConstrutivoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcesoConstrutivoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>
          }
          findFirst: {
            args: Prisma.ProcesoConstrutivoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcesoConstrutivoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>
          }
          findMany: {
            args: Prisma.ProcesoConstrutivoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>[]
          }
          create: {
            args: Prisma.ProcesoConstrutivoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>
          }
          createMany: {
            args: Prisma.ProcesoConstrutivoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcesoConstrutivoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>[]
          }
          delete: {
            args: Prisma.ProcesoConstrutivoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>
          }
          update: {
            args: Prisma.ProcesoConstrutivoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>
          }
          deleteMany: {
            args: Prisma.ProcesoConstrutivoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcesoConstrutivoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcesoConstrutivoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>[]
          }
          upsert: {
            args: Prisma.ProcesoConstrutivoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoConstrutivoPayload>
          }
          aggregate: {
            args: Prisma.ProcesoConstrutivoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcesoConstrutivo>
          }
          groupBy: {
            args: Prisma.ProcesoConstrutivoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcesoConstrutivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcesoConstrutivoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcesoConstrutivoCountAggregateOutputType> | number
          }
        }
      }
      PlanMaestro: {
        payload: Prisma.$PlanMaestroPayload<ExtArgs>
        fields: Prisma.PlanMaestroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanMaestroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanMaestroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>
          }
          findFirst: {
            args: Prisma.PlanMaestroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanMaestroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>
          }
          findMany: {
            args: Prisma.PlanMaestroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>[]
          }
          create: {
            args: Prisma.PlanMaestroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>
          }
          createMany: {
            args: Prisma.PlanMaestroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanMaestroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>[]
          }
          delete: {
            args: Prisma.PlanMaestroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>
          }
          update: {
            args: Prisma.PlanMaestroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>
          }
          deleteMany: {
            args: Prisma.PlanMaestroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanMaestroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanMaestroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>[]
          }
          upsert: {
            args: Prisma.PlanMaestroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMaestroPayload>
          }
          aggregate: {
            args: Prisma.PlanMaestroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanMaestro>
          }
          groupBy: {
            args: Prisma.PlanMaestroGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanMaestroGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanMaestroCountArgs<ExtArgs>
            result: $Utils.Optional<PlanMaestroCountAggregateOutputType> | number
          }
        }
      }
      PmFrente: {
        payload: Prisma.$PmFrentePayload<ExtArgs>
        fields: Prisma.PmFrenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PmFrenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PmFrenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>
          }
          findFirst: {
            args: Prisma.PmFrenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PmFrenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>
          }
          findMany: {
            args: Prisma.PmFrenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>[]
          }
          create: {
            args: Prisma.PmFrenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>
          }
          createMany: {
            args: Prisma.PmFrenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PmFrenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>[]
          }
          delete: {
            args: Prisma.PmFrenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>
          }
          update: {
            args: Prisma.PmFrenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>
          }
          deleteMany: {
            args: Prisma.PmFrenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PmFrenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PmFrenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>[]
          }
          upsert: {
            args: Prisma.PmFrenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePayload>
          }
          aggregate: {
            args: Prisma.PmFrenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePmFrente>
          }
          groupBy: {
            args: Prisma.PmFrenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PmFrenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PmFrenteCountArgs<ExtArgs>
            result: $Utils.Optional<PmFrenteCountAggregateOutputType> | number
          }
        }
      }
      PmFrentePartida: {
        payload: Prisma.$PmFrentePartidaPayload<ExtArgs>
        fields: Prisma.PmFrentePartidaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PmFrentePartidaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PmFrentePartidaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>
          }
          findFirst: {
            args: Prisma.PmFrentePartidaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PmFrentePartidaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>
          }
          findMany: {
            args: Prisma.PmFrentePartidaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>[]
          }
          create: {
            args: Prisma.PmFrentePartidaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>
          }
          createMany: {
            args: Prisma.PmFrentePartidaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PmFrentePartidaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>[]
          }
          delete: {
            args: Prisma.PmFrentePartidaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>
          }
          update: {
            args: Prisma.PmFrentePartidaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>
          }
          deleteMany: {
            args: Prisma.PmFrentePartidaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PmFrentePartidaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PmFrentePartidaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>[]
          }
          upsert: {
            args: Prisma.PmFrentePartidaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmFrentePartidaPayload>
          }
          aggregate: {
            args: Prisma.PmFrentePartidaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePmFrentePartida>
          }
          groupBy: {
            args: Prisma.PmFrentePartidaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PmFrentePartidaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PmFrentePartidaCountArgs<ExtArgs>
            result: $Utils.Optional<PmFrentePartidaCountAggregateOutputType> | number
          }
        }
      }
      PmProgramacion: {
        payload: Prisma.$PmProgramacionPayload<ExtArgs>
        fields: Prisma.PmProgramacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PmProgramacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PmProgramacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>
          }
          findFirst: {
            args: Prisma.PmProgramacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PmProgramacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>
          }
          findMany: {
            args: Prisma.PmProgramacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>[]
          }
          create: {
            args: Prisma.PmProgramacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>
          }
          createMany: {
            args: Prisma.PmProgramacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PmProgramacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>[]
          }
          delete: {
            args: Prisma.PmProgramacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>
          }
          update: {
            args: Prisma.PmProgramacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>
          }
          deleteMany: {
            args: Prisma.PmProgramacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PmProgramacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PmProgramacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>[]
          }
          upsert: {
            args: Prisma.PmProgramacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmProgramacionPayload>
          }
          aggregate: {
            args: Prisma.PmProgramacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePmProgramacion>
          }
          groupBy: {
            args: Prisma.PmProgramacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PmProgramacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PmProgramacionCountArgs<ExtArgs>
            result: $Utils.Optional<PmProgramacionCountAggregateOutputType> | number
          }
        }
      }
      EquipoCargo: {
        payload: Prisma.$EquipoCargoPayload<ExtArgs>
        fields: Prisma.EquipoCargoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipoCargoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipoCargoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>
          }
          findFirst: {
            args: Prisma.EquipoCargoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipoCargoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>
          }
          findMany: {
            args: Prisma.EquipoCargoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>[]
          }
          create: {
            args: Prisma.EquipoCargoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>
          }
          createMany: {
            args: Prisma.EquipoCargoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipoCargoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>[]
          }
          delete: {
            args: Prisma.EquipoCargoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>
          }
          update: {
            args: Prisma.EquipoCargoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>
          }
          deleteMany: {
            args: Prisma.EquipoCargoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipoCargoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipoCargoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>[]
          }
          upsert: {
            args: Prisma.EquipoCargoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoCargoPayload>
          }
          aggregate: {
            args: Prisma.EquipoCargoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipoCargo>
          }
          groupBy: {
            args: Prisma.EquipoCargoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipoCargoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipoCargoCountArgs<ExtArgs>
            result: $Utils.Optional<EquipoCargoCountAggregateOutputType> | number
          }
        }
      }
      EquipoTrabajo: {
        payload: Prisma.$EquipoTrabajoPayload<ExtArgs>
        fields: Prisma.EquipoTrabajoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipoTrabajoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipoTrabajoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>
          }
          findFirst: {
            args: Prisma.EquipoTrabajoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipoTrabajoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>
          }
          findMany: {
            args: Prisma.EquipoTrabajoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>[]
          }
          create: {
            args: Prisma.EquipoTrabajoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>
          }
          createMany: {
            args: Prisma.EquipoTrabajoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipoTrabajoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>[]
          }
          delete: {
            args: Prisma.EquipoTrabajoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>
          }
          update: {
            args: Prisma.EquipoTrabajoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>
          }
          deleteMany: {
            args: Prisma.EquipoTrabajoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipoTrabajoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipoTrabajoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>[]
          }
          upsert: {
            args: Prisma.EquipoTrabajoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipoTrabajoPayload>
          }
          aggregate: {
            args: Prisma.EquipoTrabajoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipoTrabajo>
          }
          groupBy: {
            args: Prisma.EquipoTrabajoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipoTrabajoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipoTrabajoCountArgs<ExtArgs>
            result: $Utils.Optional<EquipoTrabajoCountAggregateOutputType> | number
          }
        }
      }
      PmEquipo: {
        payload: Prisma.$PmEquipoPayload<ExtArgs>
        fields: Prisma.PmEquipoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PmEquipoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PmEquipoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>
          }
          findFirst: {
            args: Prisma.PmEquipoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PmEquipoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>
          }
          findMany: {
            args: Prisma.PmEquipoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>[]
          }
          create: {
            args: Prisma.PmEquipoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>
          }
          createMany: {
            args: Prisma.PmEquipoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PmEquipoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>[]
          }
          delete: {
            args: Prisma.PmEquipoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>
          }
          update: {
            args: Prisma.PmEquipoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>
          }
          deleteMany: {
            args: Prisma.PmEquipoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PmEquipoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PmEquipoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>[]
          }
          upsert: {
            args: Prisma.PmEquipoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PmEquipoPayload>
          }
          aggregate: {
            args: Prisma.PmEquipoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePmEquipo>
          }
          groupBy: {
            args: Prisma.PmEquipoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PmEquipoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PmEquipoCountArgs<ExtArgs>
            result: $Utils.Optional<PmEquipoCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      ModeloVivienda: {
        payload: Prisma.$ModeloViviendaPayload<ExtArgs>
        fields: Prisma.ModeloViviendaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModeloViviendaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModeloViviendaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>
          }
          findFirst: {
            args: Prisma.ModeloViviendaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModeloViviendaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>
          }
          findMany: {
            args: Prisma.ModeloViviendaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>[]
          }
          create: {
            args: Prisma.ModeloViviendaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>
          }
          createMany: {
            args: Prisma.ModeloViviendaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModeloViviendaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>[]
          }
          delete: {
            args: Prisma.ModeloViviendaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>
          }
          update: {
            args: Prisma.ModeloViviendaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>
          }
          deleteMany: {
            args: Prisma.ModeloViviendaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModeloViviendaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModeloViviendaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>[]
          }
          upsert: {
            args: Prisma.ModeloViviendaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloViviendaPayload>
          }
          aggregate: {
            args: Prisma.ModeloViviendaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModeloVivienda>
          }
          groupBy: {
            args: Prisma.ModeloViviendaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModeloViviendaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModeloViviendaCountArgs<ExtArgs>
            result: $Utils.Optional<ModeloViviendaCountAggregateOutputType> | number
          }
        }
      }
      Proyecto: {
        payload: Prisma.$ProyectoPayload<ExtArgs>
        fields: Prisma.ProyectoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProyectoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProyectoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>
          }
          findFirst: {
            args: Prisma.ProyectoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProyectoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>
          }
          findMany: {
            args: Prisma.ProyectoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>[]
          }
          create: {
            args: Prisma.ProyectoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>
          }
          createMany: {
            args: Prisma.ProyectoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProyectoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>[]
          }
          delete: {
            args: Prisma.ProyectoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>
          }
          update: {
            args: Prisma.ProyectoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>
          }
          deleteMany: {
            args: Prisma.ProyectoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProyectoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProyectoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>[]
          }
          upsert: {
            args: Prisma.ProyectoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProyectoPayload>
          }
          aggregate: {
            args: Prisma.ProyectoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProyecto>
          }
          groupBy: {
            args: Prisma.ProyectoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProyectoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProyectoCountArgs<ExtArgs>
            result: $Utils.Optional<ProyectoCountAggregateOutputType> | number
          }
        }
      }
      Vivienda: {
        payload: Prisma.$ViviendaPayload<ExtArgs>
        fields: Prisma.ViviendaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViviendaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViviendaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>
          }
          findFirst: {
            args: Prisma.ViviendaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViviendaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>
          }
          findMany: {
            args: Prisma.ViviendaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>[]
          }
          create: {
            args: Prisma.ViviendaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>
          }
          createMany: {
            args: Prisma.ViviendaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViviendaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>[]
          }
          delete: {
            args: Prisma.ViviendaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>
          }
          update: {
            args: Prisma.ViviendaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>
          }
          deleteMany: {
            args: Prisma.ViviendaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViviendaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViviendaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>[]
          }
          upsert: {
            args: Prisma.ViviendaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViviendaPayload>
          }
          aggregate: {
            args: Prisma.ViviendaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVivienda>
          }
          groupBy: {
            args: Prisma.ViviendaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViviendaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViviendaCountArgs<ExtArgs>
            result: $Utils.Optional<ViviendaCountAggregateOutputType> | number
          }
        }
      }
      PlanSemanal: {
        payload: Prisma.$PlanSemanalPayload<ExtArgs>
        fields: Prisma.PlanSemanalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanSemanalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanSemanalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>
          }
          findFirst: {
            args: Prisma.PlanSemanalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanSemanalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>
          }
          findMany: {
            args: Prisma.PlanSemanalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>[]
          }
          create: {
            args: Prisma.PlanSemanalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>
          }
          createMany: {
            args: Prisma.PlanSemanalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanSemanalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>[]
          }
          delete: {
            args: Prisma.PlanSemanalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>
          }
          update: {
            args: Prisma.PlanSemanalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>
          }
          deleteMany: {
            args: Prisma.PlanSemanalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanSemanalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanSemanalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>[]
          }
          upsert: {
            args: Prisma.PlanSemanalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPayload>
          }
          aggregate: {
            args: Prisma.PlanSemanalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanSemanal>
          }
          groupBy: {
            args: Prisma.PlanSemanalGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanSemanalGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanSemanalCountArgs<ExtArgs>
            result: $Utils.Optional<PlanSemanalCountAggregateOutputType> | number
          }
        }
      }
      PlanSemanalPartida: {
        payload: Prisma.$PlanSemanalPartidaPayload<ExtArgs>
        fields: Prisma.PlanSemanalPartidaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanSemanalPartidaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanSemanalPartidaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>
          }
          findFirst: {
            args: Prisma.PlanSemanalPartidaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanSemanalPartidaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>
          }
          findMany: {
            args: Prisma.PlanSemanalPartidaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>[]
          }
          create: {
            args: Prisma.PlanSemanalPartidaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>
          }
          createMany: {
            args: Prisma.PlanSemanalPartidaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanSemanalPartidaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>[]
          }
          delete: {
            args: Prisma.PlanSemanalPartidaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>
          }
          update: {
            args: Prisma.PlanSemanalPartidaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>
          }
          deleteMany: {
            args: Prisma.PlanSemanalPartidaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanSemanalPartidaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanSemanalPartidaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>[]
          }
          upsert: {
            args: Prisma.PlanSemanalPartidaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSemanalPartidaPayload>
          }
          aggregate: {
            args: Prisma.PlanSemanalPartidaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanSemanalPartida>
          }
          groupBy: {
            args: Prisma.PlanSemanalPartidaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanSemanalPartidaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanSemanalPartidaCountArgs<ExtArgs>
            result: $Utils.Optional<PlanSemanalPartidaCountAggregateOutputType> | number
          }
        }
      }
      CausaNoCumplimiento: {
        payload: Prisma.$CausaNoCumplimientoPayload<ExtArgs>
        fields: Prisma.CausaNoCumplimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CausaNoCumplimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CausaNoCumplimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>
          }
          findFirst: {
            args: Prisma.CausaNoCumplimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CausaNoCumplimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>
          }
          findMany: {
            args: Prisma.CausaNoCumplimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>[]
          }
          create: {
            args: Prisma.CausaNoCumplimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>
          }
          createMany: {
            args: Prisma.CausaNoCumplimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CausaNoCumplimientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>[]
          }
          delete: {
            args: Prisma.CausaNoCumplimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>
          }
          update: {
            args: Prisma.CausaNoCumplimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>
          }
          deleteMany: {
            args: Prisma.CausaNoCumplimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CausaNoCumplimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CausaNoCumplimientoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>[]
          }
          upsert: {
            args: Prisma.CausaNoCumplimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CausaNoCumplimientoPayload>
          }
          aggregate: {
            args: Prisma.CausaNoCumplimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCausaNoCumplimiento>
          }
          groupBy: {
            args: Prisma.CausaNoCumplimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CausaNoCumplimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CausaNoCumplimientoCountArgs<ExtArgs>
            result: $Utils.Optional<CausaNoCumplimientoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    hito?: HitoOmit
    paqueteTrabajo?: PaqueteTrabajoOmit
    partida?: PartidaOmit
    procesoConstrutivo?: ProcesoConstrutivoOmit
    planMaestro?: PlanMaestroOmit
    pmFrente?: PmFrenteOmit
    pmFrentePartida?: PmFrentePartidaOmit
    pmProgramacion?: PmProgramacionOmit
    equipoCargo?: EquipoCargoOmit
    equipoTrabajo?: EquipoTrabajoOmit
    pmEquipo?: PmEquipoOmit
    usuario?: UsuarioOmit
    modeloVivienda?: ModeloViviendaOmit
    proyecto?: ProyectoOmit
    vivienda?: ViviendaOmit
    planSemanal?: PlanSemanalOmit
    planSemanalPartida?: PlanSemanalPartidaOmit
    causaNoCumplimiento?: CausaNoCumplimientoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HitoCountOutputType
   */

  export type HitoCountOutputType = {
    partida: number
  }

  export type HitoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | HitoCountOutputTypeCountPartidaArgs
  }

  // Custom InputTypes
  /**
   * HitoCountOutputType without action
   */
  export type HitoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HitoCountOutputType
     */
    select?: HitoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HitoCountOutputType without action
   */
  export type HitoCountOutputTypeCountPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartidaWhereInput
  }


  /**
   * Count Type PaqueteTrabajoCountOutputType
   */

  export type PaqueteTrabajoCountOutputType = {
    partida: number
  }

  export type PaqueteTrabajoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PaqueteTrabajoCountOutputTypeCountPartidaArgs
  }

  // Custom InputTypes
  /**
   * PaqueteTrabajoCountOutputType without action
   */
  export type PaqueteTrabajoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajoCountOutputType
     */
    select?: PaqueteTrabajoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaqueteTrabajoCountOutputType without action
   */
  export type PaqueteTrabajoCountOutputTypeCountPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartidaWhereInput
  }


  /**
   * Count Type PartidaCountOutputType
   */

  export type PartidaCountOutputType = {
    pmFrentePartidas: number
    planSemanalPartida: number
  }

  export type PartidaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmFrentePartidas?: boolean | PartidaCountOutputTypeCountPmFrentePartidasArgs
    planSemanalPartida?: boolean | PartidaCountOutputTypeCountPlanSemanalPartidaArgs
  }

  // Custom InputTypes
  /**
   * PartidaCountOutputType without action
   */
  export type PartidaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartidaCountOutputType
     */
    select?: PartidaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartidaCountOutputType without action
   */
  export type PartidaCountOutputTypeCountPmFrentePartidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmFrentePartidaWhereInput
  }

  /**
   * PartidaCountOutputType without action
   */
  export type PartidaCountOutputTypeCountPlanSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalPartidaWhereInput
  }


  /**
   * Count Type ProcesoConstrutivoCountOutputType
   */

  export type ProcesoConstrutivoCountOutputType = {
    partida: number
  }

  export type ProcesoConstrutivoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | ProcesoConstrutivoCountOutputTypeCountPartidaArgs
  }

  // Custom InputTypes
  /**
   * ProcesoConstrutivoCountOutputType without action
   */
  export type ProcesoConstrutivoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivoCountOutputType
     */
    select?: ProcesoConstrutivoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcesoConstrutivoCountOutputType without action
   */
  export type ProcesoConstrutivoCountOutputTypeCountPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartidaWhereInput
  }


  /**
   * Count Type PlanMaestroCountOutputType
   */

  export type PlanMaestroCountOutputType = {
    equipoTrabajos: number
    pmFrentes: number
  }

  export type PlanMaestroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipoTrabajos?: boolean | PlanMaestroCountOutputTypeCountEquipoTrabajosArgs
    pmFrentes?: boolean | PlanMaestroCountOutputTypeCountPmFrentesArgs
  }

  // Custom InputTypes
  /**
   * PlanMaestroCountOutputType without action
   */
  export type PlanMaestroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestroCountOutputType
     */
    select?: PlanMaestroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanMaestroCountOutputType without action
   */
  export type PlanMaestroCountOutputTypeCountEquipoTrabajosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipoTrabajoWhereInput
  }

  /**
   * PlanMaestroCountOutputType without action
   */
  export type PlanMaestroCountOutputTypeCountPmFrentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmFrenteWhereInput
  }


  /**
   * Count Type PmFrenteCountOutputType
   */

  export type PmFrenteCountOutputType = {
    pmFrentePartidas: number
    planSemanal: number
  }

  export type PmFrenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmFrentePartidas?: boolean | PmFrenteCountOutputTypeCountPmFrentePartidasArgs
    planSemanal?: boolean | PmFrenteCountOutputTypeCountPlanSemanalArgs
  }

  // Custom InputTypes
  /**
   * PmFrenteCountOutputType without action
   */
  export type PmFrenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrenteCountOutputType
     */
    select?: PmFrenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PmFrenteCountOutputType without action
   */
  export type PmFrenteCountOutputTypeCountPmFrentePartidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmFrentePartidaWhereInput
  }

  /**
   * PmFrenteCountOutputType without action
   */
  export type PmFrenteCountOutputTypeCountPlanSemanalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalWhereInput
  }


  /**
   * Count Type PmFrentePartidaCountOutputType
   */

  export type PmFrentePartidaCountOutputType = {
    pmProgramacion: number
  }

  export type PmFrentePartidaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmProgramacion?: boolean | PmFrentePartidaCountOutputTypeCountPmProgramacionArgs
  }

  // Custom InputTypes
  /**
   * PmFrentePartidaCountOutputType without action
   */
  export type PmFrentePartidaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartidaCountOutputType
     */
    select?: PmFrentePartidaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PmFrentePartidaCountOutputType without action
   */
  export type PmFrentePartidaCountOutputTypeCountPmProgramacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmProgramacionWhereInput
  }


  /**
   * Count Type EquipoCargoCountOutputType
   */

  export type EquipoCargoCountOutputType = {
    pmEquipo: number
  }

  export type EquipoCargoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmEquipo?: boolean | EquipoCargoCountOutputTypeCountPmEquipoArgs
  }

  // Custom InputTypes
  /**
   * EquipoCargoCountOutputType without action
   */
  export type EquipoCargoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargoCountOutputType
     */
    select?: EquipoCargoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipoCargoCountOutputType without action
   */
  export type EquipoCargoCountOutputTypeCountPmEquipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmEquipoWhereInput
  }


  /**
   * Count Type EquipoTrabajoCountOutputType
   */

  export type EquipoTrabajoCountOutputType = {
    pmEquipo: number
  }

  export type EquipoTrabajoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmEquipo?: boolean | EquipoTrabajoCountOutputTypeCountPmEquipoArgs
  }

  // Custom InputTypes
  /**
   * EquipoTrabajoCountOutputType without action
   */
  export type EquipoTrabajoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajoCountOutputType
     */
    select?: EquipoTrabajoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipoTrabajoCountOutputType without action
   */
  export type EquipoTrabajoCountOutputTypeCountPmEquipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmEquipoWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    pmEquipo: number
    planSemanalPartida: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmEquipo?: boolean | UsuarioCountOutputTypeCountPmEquipoArgs
    planSemanalPartida?: boolean | UsuarioCountOutputTypeCountPlanSemanalPartidaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPmEquipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmEquipoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPlanSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalPartidaWhereInput
  }


  /**
   * Count Type ModeloViviendaCountOutputType
   */

  export type ModeloViviendaCountOutputType = {
    vivienda: number
  }

  export type ModeloViviendaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vivienda?: boolean | ModeloViviendaCountOutputTypeCountViviendaArgs
  }

  // Custom InputTypes
  /**
   * ModeloViviendaCountOutputType without action
   */
  export type ModeloViviendaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloViviendaCountOutputType
     */
    select?: ModeloViviendaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModeloViviendaCountOutputType without action
   */
  export type ModeloViviendaCountOutputTypeCountViviendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViviendaWhereInput
  }


  /**
   * Count Type ProyectoCountOutputType
   */

  export type ProyectoCountOutputType = {
    planMaestro: number
  }

  export type ProyectoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planMaestro?: boolean | ProyectoCountOutputTypeCountPlanMaestroArgs
  }

  // Custom InputTypes
  /**
   * ProyectoCountOutputType without action
   */
  export type ProyectoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProyectoCountOutputType
     */
    select?: ProyectoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProyectoCountOutputType without action
   */
  export type ProyectoCountOutputTypeCountPlanMaestroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMaestroWhereInput
  }


  /**
   * Count Type ViviendaCountOutputType
   */

  export type ViviendaCountOutputType = {
    planSemanalPartida: number
    pmProgramacion: number
  }

  export type ViviendaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planSemanalPartida?: boolean | ViviendaCountOutputTypeCountPlanSemanalPartidaArgs
    pmProgramacion?: boolean | ViviendaCountOutputTypeCountPmProgramacionArgs
  }

  // Custom InputTypes
  /**
   * ViviendaCountOutputType without action
   */
  export type ViviendaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViviendaCountOutputType
     */
    select?: ViviendaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViviendaCountOutputType without action
   */
  export type ViviendaCountOutputTypeCountPlanSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalPartidaWhereInput
  }

  /**
   * ViviendaCountOutputType without action
   */
  export type ViviendaCountOutputTypeCountPmProgramacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmProgramacionWhereInput
  }


  /**
   * Count Type CausaNoCumplimientoCountOutputType
   */

  export type CausaNoCumplimientoCountOutputType = {
    planSemanalPartida: number
  }

  export type CausaNoCumplimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planSemanalPartida?: boolean | CausaNoCumplimientoCountOutputTypeCountPlanSemanalPartidaArgs
  }

  // Custom InputTypes
  /**
   * CausaNoCumplimientoCountOutputType without action
   */
  export type CausaNoCumplimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimientoCountOutputType
     */
    select?: CausaNoCumplimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CausaNoCumplimientoCountOutputType without action
   */
  export type CausaNoCumplimientoCountOutputTypeCountPlanSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalPartidaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Hito
   */

  export type AggregateHito = {
    _count: HitoCountAggregateOutputType | null
    _avg: HitoAvgAggregateOutputType | null
    _sum: HitoSumAggregateOutputType | null
    _min: HitoMinAggregateOutputType | null
    _max: HitoMaxAggregateOutputType | null
  }

  export type HitoAvgAggregateOutputType = {
    id_Hito: number | null
  }

  export type HitoSumAggregateOutputType = {
    id_Hito: number | null
  }

  export type HitoMinAggregateOutputType = {
    id_Hito: number | null
    nombre: string | null
    descripcion: string | null
    esActivo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HitoMaxAggregateOutputType = {
    id_Hito: number | null
    nombre: string | null
    descripcion: string | null
    esActivo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HitoCountAggregateOutputType = {
    id_Hito: number
    nombre: number
    descripcion: number
    esActivo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HitoAvgAggregateInputType = {
    id_Hito?: true
  }

  export type HitoSumAggregateInputType = {
    id_Hito?: true
  }

  export type HitoMinAggregateInputType = {
    id_Hito?: true
    nombre?: true
    descripcion?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HitoMaxAggregateInputType = {
    id_Hito?: true
    nombre?: true
    descripcion?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HitoCountAggregateInputType = {
    id_Hito?: true
    nombre?: true
    descripcion?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HitoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hito to aggregate.
     */
    where?: HitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hitos to fetch.
     */
    orderBy?: HitoOrderByWithRelationInput | HitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hitos
    **/
    _count?: true | HitoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HitoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HitoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HitoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HitoMaxAggregateInputType
  }

  export type GetHitoAggregateType<T extends HitoAggregateArgs> = {
        [P in keyof T & keyof AggregateHito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHito[P]>
      : GetScalarType<T[P], AggregateHito[P]>
  }




  export type HitoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HitoWhereInput
    orderBy?: HitoOrderByWithAggregationInput | HitoOrderByWithAggregationInput[]
    by: HitoScalarFieldEnum[] | HitoScalarFieldEnum
    having?: HitoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HitoCountAggregateInputType | true
    _avg?: HitoAvgAggregateInputType
    _sum?: HitoSumAggregateInputType
    _min?: HitoMinAggregateInputType
    _max?: HitoMaxAggregateInputType
  }

  export type HitoGroupByOutputType = {
    id_Hito: number
    nombre: string
    descripcion: string
    esActivo: boolean
    createdAt: Date
    updatedAt: Date
    _count: HitoCountAggregateOutputType | null
    _avg: HitoAvgAggregateOutputType | null
    _sum: HitoSumAggregateOutputType | null
    _min: HitoMinAggregateOutputType | null
    _max: HitoMaxAggregateOutputType | null
  }

  type GetHitoGroupByPayload<T extends HitoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HitoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HitoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HitoGroupByOutputType[P]>
            : GetScalarType<T[P], HitoGroupByOutputType[P]>
        }
      >
    >


  export type HitoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Hito?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partida?: boolean | Hito$partidaArgs<ExtArgs>
    _count?: boolean | HitoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hito"]>

  export type HitoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Hito?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hito"]>

  export type HitoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Hito?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hito"]>

  export type HitoSelectScalar = {
    id_Hito?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HitoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_Hito" | "nombre" | "descripcion" | "esActivo" | "createdAt" | "updatedAt", ExtArgs["result"]["hito"]>
  export type HitoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | Hito$partidaArgs<ExtArgs>
    _count?: boolean | HitoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HitoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HitoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HitoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hito"
    objects: {
      partida: Prisma.$PartidaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_Hito: number
      nombre: string
      descripcion: string
      esActivo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hito"]>
    composites: {}
  }

  type HitoGetPayload<S extends boolean | null | undefined | HitoDefaultArgs> = $Result.GetResult<Prisma.$HitoPayload, S>

  type HitoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HitoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HitoCountAggregateInputType | true
    }

  export interface HitoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hito'], meta: { name: 'Hito' } }
    /**
     * Find zero or one Hito that matches the filter.
     * @param {HitoFindUniqueArgs} args - Arguments to find a Hito
     * @example
     * // Get one Hito
     * const hito = await prisma.hito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HitoFindUniqueArgs>(args: SelectSubset<T, HitoFindUniqueArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HitoFindUniqueOrThrowArgs} args - Arguments to find a Hito
     * @example
     * // Get one Hito
     * const hito = await prisma.hito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HitoFindUniqueOrThrowArgs>(args: SelectSubset<T, HitoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoFindFirstArgs} args - Arguments to find a Hito
     * @example
     * // Get one Hito
     * const hito = await prisma.hito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HitoFindFirstArgs>(args?: SelectSubset<T, HitoFindFirstArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoFindFirstOrThrowArgs} args - Arguments to find a Hito
     * @example
     * // Get one Hito
     * const hito = await prisma.hito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HitoFindFirstOrThrowArgs>(args?: SelectSubset<T, HitoFindFirstOrThrowArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hitos
     * const hitos = await prisma.hito.findMany()
     * 
     * // Get first 10 Hitos
     * const hitos = await prisma.hito.findMany({ take: 10 })
     * 
     * // Only select the `id_Hito`
     * const hitoWithId_HitoOnly = await prisma.hito.findMany({ select: { id_Hito: true } })
     * 
     */
    findMany<T extends HitoFindManyArgs>(args?: SelectSubset<T, HitoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hito.
     * @param {HitoCreateArgs} args - Arguments to create a Hito.
     * @example
     * // Create one Hito
     * const Hito = await prisma.hito.create({
     *   data: {
     *     // ... data to create a Hito
     *   }
     * })
     * 
     */
    create<T extends HitoCreateArgs>(args: SelectSubset<T, HitoCreateArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hitos.
     * @param {HitoCreateManyArgs} args - Arguments to create many Hitos.
     * @example
     * // Create many Hitos
     * const hito = await prisma.hito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HitoCreateManyArgs>(args?: SelectSubset<T, HitoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hitos and returns the data saved in the database.
     * @param {HitoCreateManyAndReturnArgs} args - Arguments to create many Hitos.
     * @example
     * // Create many Hitos
     * const hito = await prisma.hito.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hitos and only return the `id_Hito`
     * const hitoWithId_HitoOnly = await prisma.hito.createManyAndReturn({
     *   select: { id_Hito: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HitoCreateManyAndReturnArgs>(args?: SelectSubset<T, HitoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hito.
     * @param {HitoDeleteArgs} args - Arguments to delete one Hito.
     * @example
     * // Delete one Hito
     * const Hito = await prisma.hito.delete({
     *   where: {
     *     // ... filter to delete one Hito
     *   }
     * })
     * 
     */
    delete<T extends HitoDeleteArgs>(args: SelectSubset<T, HitoDeleteArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hito.
     * @param {HitoUpdateArgs} args - Arguments to update one Hito.
     * @example
     * // Update one Hito
     * const hito = await prisma.hito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HitoUpdateArgs>(args: SelectSubset<T, HitoUpdateArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hitos.
     * @param {HitoDeleteManyArgs} args - Arguments to filter Hitos to delete.
     * @example
     * // Delete a few Hitos
     * const { count } = await prisma.hito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HitoDeleteManyArgs>(args?: SelectSubset<T, HitoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hitos
     * const hito = await prisma.hito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HitoUpdateManyArgs>(args: SelectSubset<T, HitoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hitos and returns the data updated in the database.
     * @param {HitoUpdateManyAndReturnArgs} args - Arguments to update many Hitos.
     * @example
     * // Update many Hitos
     * const hito = await prisma.hito.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hitos and only return the `id_Hito`
     * const hitoWithId_HitoOnly = await prisma.hito.updateManyAndReturn({
     *   select: { id_Hito: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HitoUpdateManyAndReturnArgs>(args: SelectSubset<T, HitoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hito.
     * @param {HitoUpsertArgs} args - Arguments to update or create a Hito.
     * @example
     * // Update or create a Hito
     * const hito = await prisma.hito.upsert({
     *   create: {
     *     // ... data to create a Hito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hito we want to update
     *   }
     * })
     */
    upsert<T extends HitoUpsertArgs>(args: SelectSubset<T, HitoUpsertArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoCountArgs} args - Arguments to filter Hitos to count.
     * @example
     * // Count the number of Hitos
     * const count = await prisma.hito.count({
     *   where: {
     *     // ... the filter for the Hitos we want to count
     *   }
     * })
    **/
    count<T extends HitoCountArgs>(
      args?: Subset<T, HitoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HitoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HitoAggregateArgs>(args: Subset<T, HitoAggregateArgs>): Prisma.PrismaPromise<GetHitoAggregateType<T>>

    /**
     * Group by Hito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HitoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HitoGroupByArgs['orderBy'] }
        : { orderBy?: HitoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HitoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHitoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hito model
   */
  readonly fields: HitoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HitoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partida<T extends Hito$partidaArgs<ExtArgs> = {}>(args?: Subset<T, Hito$partidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hito model
   */
  interface HitoFieldRefs {
    readonly id_Hito: FieldRef<"Hito", 'Int'>
    readonly nombre: FieldRef<"Hito", 'String'>
    readonly descripcion: FieldRef<"Hito", 'String'>
    readonly esActivo: FieldRef<"Hito", 'Boolean'>
    readonly createdAt: FieldRef<"Hito", 'DateTime'>
    readonly updatedAt: FieldRef<"Hito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hito findUnique
   */
  export type HitoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * Filter, which Hito to fetch.
     */
    where: HitoWhereUniqueInput
  }

  /**
   * Hito findUniqueOrThrow
   */
  export type HitoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * Filter, which Hito to fetch.
     */
    where: HitoWhereUniqueInput
  }

  /**
   * Hito findFirst
   */
  export type HitoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * Filter, which Hito to fetch.
     */
    where?: HitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hitos to fetch.
     */
    orderBy?: HitoOrderByWithRelationInput | HitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hitos.
     */
    cursor?: HitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hitos.
     */
    distinct?: HitoScalarFieldEnum | HitoScalarFieldEnum[]
  }

  /**
   * Hito findFirstOrThrow
   */
  export type HitoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * Filter, which Hito to fetch.
     */
    where?: HitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hitos to fetch.
     */
    orderBy?: HitoOrderByWithRelationInput | HitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hitos.
     */
    cursor?: HitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hitos.
     */
    distinct?: HitoScalarFieldEnum | HitoScalarFieldEnum[]
  }

  /**
   * Hito findMany
   */
  export type HitoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * Filter, which Hitos to fetch.
     */
    where?: HitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hitos to fetch.
     */
    orderBy?: HitoOrderByWithRelationInput | HitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hitos.
     */
    cursor?: HitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hitos.
     */
    skip?: number
    distinct?: HitoScalarFieldEnum | HitoScalarFieldEnum[]
  }

  /**
   * Hito create
   */
  export type HitoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * The data needed to create a Hito.
     */
    data: XOR<HitoCreateInput, HitoUncheckedCreateInput>
  }

  /**
   * Hito createMany
   */
  export type HitoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hitos.
     */
    data: HitoCreateManyInput | HitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hito createManyAndReturn
   */
  export type HitoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * The data used to create many Hitos.
     */
    data: HitoCreateManyInput | HitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hito update
   */
  export type HitoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * The data needed to update a Hito.
     */
    data: XOR<HitoUpdateInput, HitoUncheckedUpdateInput>
    /**
     * Choose, which Hito to update.
     */
    where: HitoWhereUniqueInput
  }

  /**
   * Hito updateMany
   */
  export type HitoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hitos.
     */
    data: XOR<HitoUpdateManyMutationInput, HitoUncheckedUpdateManyInput>
    /**
     * Filter which Hitos to update
     */
    where?: HitoWhereInput
    /**
     * Limit how many Hitos to update.
     */
    limit?: number
  }

  /**
   * Hito updateManyAndReturn
   */
  export type HitoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * The data used to update Hitos.
     */
    data: XOR<HitoUpdateManyMutationInput, HitoUncheckedUpdateManyInput>
    /**
     * Filter which Hitos to update
     */
    where?: HitoWhereInput
    /**
     * Limit how many Hitos to update.
     */
    limit?: number
  }

  /**
   * Hito upsert
   */
  export type HitoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * The filter to search for the Hito to update in case it exists.
     */
    where: HitoWhereUniqueInput
    /**
     * In case the Hito found by the `where` argument doesn't exist, create a new Hito with this data.
     */
    create: XOR<HitoCreateInput, HitoUncheckedCreateInput>
    /**
     * In case the Hito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HitoUpdateInput, HitoUncheckedUpdateInput>
  }

  /**
   * Hito delete
   */
  export type HitoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
    /**
     * Filter which Hito to delete.
     */
    where: HitoWhereUniqueInput
  }

  /**
   * Hito deleteMany
   */
  export type HitoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hitos to delete
     */
    where?: HitoWhereInput
    /**
     * Limit how many Hitos to delete.
     */
    limit?: number
  }

  /**
   * Hito.partida
   */
  export type Hito$partidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    where?: PartidaWhereInput
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    cursor?: PartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartidaScalarFieldEnum | PartidaScalarFieldEnum[]
  }

  /**
   * Hito without action
   */
  export type HitoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hito
     */
    select?: HitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hito
     */
    omit?: HitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitoInclude<ExtArgs> | null
  }


  /**
   * Model PaqueteTrabajo
   */

  export type AggregatePaqueteTrabajo = {
    _count: PaqueteTrabajoCountAggregateOutputType | null
    _avg: PaqueteTrabajoAvgAggregateOutputType | null
    _sum: PaqueteTrabajoSumAggregateOutputType | null
    _min: PaqueteTrabajoMinAggregateOutputType | null
    _max: PaqueteTrabajoMaxAggregateOutputType | null
  }

  export type PaqueteTrabajoAvgAggregateOutputType = {
    id_PaqueteTrabajo: number | null
  }

  export type PaqueteTrabajoSumAggregateOutputType = {
    id_PaqueteTrabajo: number | null
  }

  export type PaqueteTrabajoMinAggregateOutputType = {
    id_PaqueteTrabajo: number | null
    nombre: string | null
    descripcion: string | null
    esActivo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaqueteTrabajoMaxAggregateOutputType = {
    id_PaqueteTrabajo: number | null
    nombre: string | null
    descripcion: string | null
    esActivo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaqueteTrabajoCountAggregateOutputType = {
    id_PaqueteTrabajo: number
    nombre: number
    descripcion: number
    esActivo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaqueteTrabajoAvgAggregateInputType = {
    id_PaqueteTrabajo?: true
  }

  export type PaqueteTrabajoSumAggregateInputType = {
    id_PaqueteTrabajo?: true
  }

  export type PaqueteTrabajoMinAggregateInputType = {
    id_PaqueteTrabajo?: true
    nombre?: true
    descripcion?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaqueteTrabajoMaxAggregateInputType = {
    id_PaqueteTrabajo?: true
    nombre?: true
    descripcion?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaqueteTrabajoCountAggregateInputType = {
    id_PaqueteTrabajo?: true
    nombre?: true
    descripcion?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaqueteTrabajoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteTrabajo to aggregate.
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTrabajos to fetch.
     */
    orderBy?: PaqueteTrabajoOrderByWithRelationInput | PaqueteTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaqueteTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTrabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaqueteTrabajos
    **/
    _count?: true | PaqueteTrabajoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteTrabajoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteTrabajoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteTrabajoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteTrabajoMaxAggregateInputType
  }

  export type GetPaqueteTrabajoAggregateType<T extends PaqueteTrabajoAggregateArgs> = {
        [P in keyof T & keyof AggregatePaqueteTrabajo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaqueteTrabajo[P]>
      : GetScalarType<T[P], AggregatePaqueteTrabajo[P]>
  }




  export type PaqueteTrabajoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteTrabajoWhereInput
    orderBy?: PaqueteTrabajoOrderByWithAggregationInput | PaqueteTrabajoOrderByWithAggregationInput[]
    by: PaqueteTrabajoScalarFieldEnum[] | PaqueteTrabajoScalarFieldEnum
    having?: PaqueteTrabajoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteTrabajoCountAggregateInputType | true
    _avg?: PaqueteTrabajoAvgAggregateInputType
    _sum?: PaqueteTrabajoSumAggregateInputType
    _min?: PaqueteTrabajoMinAggregateInputType
    _max?: PaqueteTrabajoMaxAggregateInputType
  }

  export type PaqueteTrabajoGroupByOutputType = {
    id_PaqueteTrabajo: number
    nombre: string
    descripcion: string
    esActivo: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaqueteTrabajoCountAggregateOutputType | null
    _avg: PaqueteTrabajoAvgAggregateOutputType | null
    _sum: PaqueteTrabajoSumAggregateOutputType | null
    _min: PaqueteTrabajoMinAggregateOutputType | null
    _max: PaqueteTrabajoMaxAggregateOutputType | null
  }

  type GetPaqueteTrabajoGroupByPayload<T extends PaqueteTrabajoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaqueteTrabajoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaqueteTrabajoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaqueteTrabajoGroupByOutputType[P]>
            : GetScalarType<T[P], PaqueteTrabajoGroupByOutputType[P]>
        }
      >
    >


  export type PaqueteTrabajoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PaqueteTrabajo?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partida?: boolean | PaqueteTrabajo$partidaArgs<ExtArgs>
    _count?: boolean | PaqueteTrabajoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTrabajo"]>

  export type PaqueteTrabajoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PaqueteTrabajo?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paqueteTrabajo"]>

  export type PaqueteTrabajoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PaqueteTrabajo?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paqueteTrabajo"]>

  export type PaqueteTrabajoSelectScalar = {
    id_PaqueteTrabajo?: boolean
    nombre?: boolean
    descripcion?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaqueteTrabajoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PaqueteTrabajo" | "nombre" | "descripcion" | "esActivo" | "createdAt" | "updatedAt", ExtArgs["result"]["paqueteTrabajo"]>
  export type PaqueteTrabajoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PaqueteTrabajo$partidaArgs<ExtArgs>
    _count?: boolean | PaqueteTrabajoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaqueteTrabajoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaqueteTrabajoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaqueteTrabajoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaqueteTrabajo"
    objects: {
      partida: Prisma.$PartidaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PaqueteTrabajo: number
      nombre: string
      descripcion: string
      esActivo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paqueteTrabajo"]>
    composites: {}
  }

  type PaqueteTrabajoGetPayload<S extends boolean | null | undefined | PaqueteTrabajoDefaultArgs> = $Result.GetResult<Prisma.$PaqueteTrabajoPayload, S>

  type PaqueteTrabajoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaqueteTrabajoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaqueteTrabajoCountAggregateInputType | true
    }

  export interface PaqueteTrabajoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaqueteTrabajo'], meta: { name: 'PaqueteTrabajo' } }
    /**
     * Find zero or one PaqueteTrabajo that matches the filter.
     * @param {PaqueteTrabajoFindUniqueArgs} args - Arguments to find a PaqueteTrabajo
     * @example
     * // Get one PaqueteTrabajo
     * const paqueteTrabajo = await prisma.paqueteTrabajo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaqueteTrabajoFindUniqueArgs>(args: SelectSubset<T, PaqueteTrabajoFindUniqueArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaqueteTrabajo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaqueteTrabajoFindUniqueOrThrowArgs} args - Arguments to find a PaqueteTrabajo
     * @example
     * // Get one PaqueteTrabajo
     * const paqueteTrabajo = await prisma.paqueteTrabajo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaqueteTrabajoFindUniqueOrThrowArgs>(args: SelectSubset<T, PaqueteTrabajoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteTrabajo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoFindFirstArgs} args - Arguments to find a PaqueteTrabajo
     * @example
     * // Get one PaqueteTrabajo
     * const paqueteTrabajo = await prisma.paqueteTrabajo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaqueteTrabajoFindFirstArgs>(args?: SelectSubset<T, PaqueteTrabajoFindFirstArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteTrabajo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoFindFirstOrThrowArgs} args - Arguments to find a PaqueteTrabajo
     * @example
     * // Get one PaqueteTrabajo
     * const paqueteTrabajo = await prisma.paqueteTrabajo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaqueteTrabajoFindFirstOrThrowArgs>(args?: SelectSubset<T, PaqueteTrabajoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaqueteTrabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaqueteTrabajos
     * const paqueteTrabajos = await prisma.paqueteTrabajo.findMany()
     * 
     * // Get first 10 PaqueteTrabajos
     * const paqueteTrabajos = await prisma.paqueteTrabajo.findMany({ take: 10 })
     * 
     * // Only select the `id_PaqueteTrabajo`
     * const paqueteTrabajoWithId_PaqueteTrabajoOnly = await prisma.paqueteTrabajo.findMany({ select: { id_PaqueteTrabajo: true } })
     * 
     */
    findMany<T extends PaqueteTrabajoFindManyArgs>(args?: SelectSubset<T, PaqueteTrabajoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaqueteTrabajo.
     * @param {PaqueteTrabajoCreateArgs} args - Arguments to create a PaqueteTrabajo.
     * @example
     * // Create one PaqueteTrabajo
     * const PaqueteTrabajo = await prisma.paqueteTrabajo.create({
     *   data: {
     *     // ... data to create a PaqueteTrabajo
     *   }
     * })
     * 
     */
    create<T extends PaqueteTrabajoCreateArgs>(args: SelectSubset<T, PaqueteTrabajoCreateArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaqueteTrabajos.
     * @param {PaqueteTrabajoCreateManyArgs} args - Arguments to create many PaqueteTrabajos.
     * @example
     * // Create many PaqueteTrabajos
     * const paqueteTrabajo = await prisma.paqueteTrabajo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaqueteTrabajoCreateManyArgs>(args?: SelectSubset<T, PaqueteTrabajoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaqueteTrabajos and returns the data saved in the database.
     * @param {PaqueteTrabajoCreateManyAndReturnArgs} args - Arguments to create many PaqueteTrabajos.
     * @example
     * // Create many PaqueteTrabajos
     * const paqueteTrabajo = await prisma.paqueteTrabajo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaqueteTrabajos and only return the `id_PaqueteTrabajo`
     * const paqueteTrabajoWithId_PaqueteTrabajoOnly = await prisma.paqueteTrabajo.createManyAndReturn({
     *   select: { id_PaqueteTrabajo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaqueteTrabajoCreateManyAndReturnArgs>(args?: SelectSubset<T, PaqueteTrabajoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaqueteTrabajo.
     * @param {PaqueteTrabajoDeleteArgs} args - Arguments to delete one PaqueteTrabajo.
     * @example
     * // Delete one PaqueteTrabajo
     * const PaqueteTrabajo = await prisma.paqueteTrabajo.delete({
     *   where: {
     *     // ... filter to delete one PaqueteTrabajo
     *   }
     * })
     * 
     */
    delete<T extends PaqueteTrabajoDeleteArgs>(args: SelectSubset<T, PaqueteTrabajoDeleteArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaqueteTrabajo.
     * @param {PaqueteTrabajoUpdateArgs} args - Arguments to update one PaqueteTrabajo.
     * @example
     * // Update one PaqueteTrabajo
     * const paqueteTrabajo = await prisma.paqueteTrabajo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaqueteTrabajoUpdateArgs>(args: SelectSubset<T, PaqueteTrabajoUpdateArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaqueteTrabajos.
     * @param {PaqueteTrabajoDeleteManyArgs} args - Arguments to filter PaqueteTrabajos to delete.
     * @example
     * // Delete a few PaqueteTrabajos
     * const { count } = await prisma.paqueteTrabajo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaqueteTrabajoDeleteManyArgs>(args?: SelectSubset<T, PaqueteTrabajoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteTrabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaqueteTrabajos
     * const paqueteTrabajo = await prisma.paqueteTrabajo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaqueteTrabajoUpdateManyArgs>(args: SelectSubset<T, PaqueteTrabajoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteTrabajos and returns the data updated in the database.
     * @param {PaqueteTrabajoUpdateManyAndReturnArgs} args - Arguments to update many PaqueteTrabajos.
     * @example
     * // Update many PaqueteTrabajos
     * const paqueteTrabajo = await prisma.paqueteTrabajo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaqueteTrabajos and only return the `id_PaqueteTrabajo`
     * const paqueteTrabajoWithId_PaqueteTrabajoOnly = await prisma.paqueteTrabajo.updateManyAndReturn({
     *   select: { id_PaqueteTrabajo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaqueteTrabajoUpdateManyAndReturnArgs>(args: SelectSubset<T, PaqueteTrabajoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaqueteTrabajo.
     * @param {PaqueteTrabajoUpsertArgs} args - Arguments to update or create a PaqueteTrabajo.
     * @example
     * // Update or create a PaqueteTrabajo
     * const paqueteTrabajo = await prisma.paqueteTrabajo.upsert({
     *   create: {
     *     // ... data to create a PaqueteTrabajo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaqueteTrabajo we want to update
     *   }
     * })
     */
    upsert<T extends PaqueteTrabajoUpsertArgs>(args: SelectSubset<T, PaqueteTrabajoUpsertArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaqueteTrabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoCountArgs} args - Arguments to filter PaqueteTrabajos to count.
     * @example
     * // Count the number of PaqueteTrabajos
     * const count = await prisma.paqueteTrabajo.count({
     *   where: {
     *     // ... the filter for the PaqueteTrabajos we want to count
     *   }
     * })
    **/
    count<T extends PaqueteTrabajoCountArgs>(
      args?: Subset<T, PaqueteTrabajoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteTrabajoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaqueteTrabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteTrabajoAggregateArgs>(args: Subset<T, PaqueteTrabajoAggregateArgs>): Prisma.PrismaPromise<GetPaqueteTrabajoAggregateType<T>>

    /**
     * Group by PaqueteTrabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTrabajoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteTrabajoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteTrabajoGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteTrabajoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteTrabajoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteTrabajoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaqueteTrabajo model
   */
  readonly fields: PaqueteTrabajoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaqueteTrabajo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaqueteTrabajoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partida<T extends PaqueteTrabajo$partidaArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTrabajo$partidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaqueteTrabajo model
   */
  interface PaqueteTrabajoFieldRefs {
    readonly id_PaqueteTrabajo: FieldRef<"PaqueteTrabajo", 'Int'>
    readonly nombre: FieldRef<"PaqueteTrabajo", 'String'>
    readonly descripcion: FieldRef<"PaqueteTrabajo", 'String'>
    readonly esActivo: FieldRef<"PaqueteTrabajo", 'Boolean'>
    readonly createdAt: FieldRef<"PaqueteTrabajo", 'DateTime'>
    readonly updatedAt: FieldRef<"PaqueteTrabajo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaqueteTrabajo findUnique
   */
  export type PaqueteTrabajoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTrabajo to fetch.
     */
    where: PaqueteTrabajoWhereUniqueInput
  }

  /**
   * PaqueteTrabajo findUniqueOrThrow
   */
  export type PaqueteTrabajoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTrabajo to fetch.
     */
    where: PaqueteTrabajoWhereUniqueInput
  }

  /**
   * PaqueteTrabajo findFirst
   */
  export type PaqueteTrabajoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTrabajo to fetch.
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTrabajos to fetch.
     */
    orderBy?: PaqueteTrabajoOrderByWithRelationInput | PaqueteTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteTrabajos.
     */
    cursor?: PaqueteTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTrabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteTrabajos.
     */
    distinct?: PaqueteTrabajoScalarFieldEnum | PaqueteTrabajoScalarFieldEnum[]
  }

  /**
   * PaqueteTrabajo findFirstOrThrow
   */
  export type PaqueteTrabajoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTrabajo to fetch.
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTrabajos to fetch.
     */
    orderBy?: PaqueteTrabajoOrderByWithRelationInput | PaqueteTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteTrabajos.
     */
    cursor?: PaqueteTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTrabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteTrabajos.
     */
    distinct?: PaqueteTrabajoScalarFieldEnum | PaqueteTrabajoScalarFieldEnum[]
  }

  /**
   * PaqueteTrabajo findMany
   */
  export type PaqueteTrabajoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTrabajos to fetch.
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTrabajos to fetch.
     */
    orderBy?: PaqueteTrabajoOrderByWithRelationInput | PaqueteTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaqueteTrabajos.
     */
    cursor?: PaqueteTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTrabajos.
     */
    skip?: number
    distinct?: PaqueteTrabajoScalarFieldEnum | PaqueteTrabajoScalarFieldEnum[]
  }

  /**
   * PaqueteTrabajo create
   */
  export type PaqueteTrabajoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * The data needed to create a PaqueteTrabajo.
     */
    data: XOR<PaqueteTrabajoCreateInput, PaqueteTrabajoUncheckedCreateInput>
  }

  /**
   * PaqueteTrabajo createMany
   */
  export type PaqueteTrabajoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaqueteTrabajos.
     */
    data: PaqueteTrabajoCreateManyInput | PaqueteTrabajoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaqueteTrabajo createManyAndReturn
   */
  export type PaqueteTrabajoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * The data used to create many PaqueteTrabajos.
     */
    data: PaqueteTrabajoCreateManyInput | PaqueteTrabajoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaqueteTrabajo update
   */
  export type PaqueteTrabajoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * The data needed to update a PaqueteTrabajo.
     */
    data: XOR<PaqueteTrabajoUpdateInput, PaqueteTrabajoUncheckedUpdateInput>
    /**
     * Choose, which PaqueteTrabajo to update.
     */
    where: PaqueteTrabajoWhereUniqueInput
  }

  /**
   * PaqueteTrabajo updateMany
   */
  export type PaqueteTrabajoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaqueteTrabajos.
     */
    data: XOR<PaqueteTrabajoUpdateManyMutationInput, PaqueteTrabajoUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteTrabajos to update
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * Limit how many PaqueteTrabajos to update.
     */
    limit?: number
  }

  /**
   * PaqueteTrabajo updateManyAndReturn
   */
  export type PaqueteTrabajoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * The data used to update PaqueteTrabajos.
     */
    data: XOR<PaqueteTrabajoUpdateManyMutationInput, PaqueteTrabajoUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteTrabajos to update
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * Limit how many PaqueteTrabajos to update.
     */
    limit?: number
  }

  /**
   * PaqueteTrabajo upsert
   */
  export type PaqueteTrabajoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * The filter to search for the PaqueteTrabajo to update in case it exists.
     */
    where: PaqueteTrabajoWhereUniqueInput
    /**
     * In case the PaqueteTrabajo found by the `where` argument doesn't exist, create a new PaqueteTrabajo with this data.
     */
    create: XOR<PaqueteTrabajoCreateInput, PaqueteTrabajoUncheckedCreateInput>
    /**
     * In case the PaqueteTrabajo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaqueteTrabajoUpdateInput, PaqueteTrabajoUncheckedUpdateInput>
  }

  /**
   * PaqueteTrabajo delete
   */
  export type PaqueteTrabajoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
    /**
     * Filter which PaqueteTrabajo to delete.
     */
    where: PaqueteTrabajoWhereUniqueInput
  }

  /**
   * PaqueteTrabajo deleteMany
   */
  export type PaqueteTrabajoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteTrabajos to delete
     */
    where?: PaqueteTrabajoWhereInput
    /**
     * Limit how many PaqueteTrabajos to delete.
     */
    limit?: number
  }

  /**
   * PaqueteTrabajo.partida
   */
  export type PaqueteTrabajo$partidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    where?: PartidaWhereInput
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    cursor?: PartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartidaScalarFieldEnum | PartidaScalarFieldEnum[]
  }

  /**
   * PaqueteTrabajo without action
   */
  export type PaqueteTrabajoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTrabajo
     */
    select?: PaqueteTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTrabajo
     */
    omit?: PaqueteTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTrabajoInclude<ExtArgs> | null
  }


  /**
   * Model Partida
   */

  export type AggregatePartida = {
    _count: PartidaCountAggregateOutputType | null
    _avg: PartidaAvgAggregateOutputType | null
    _sum: PartidaSumAggregateOutputType | null
    _min: PartidaMinAggregateOutputType | null
    _max: PartidaMaxAggregateOutputType | null
  }

  export type PartidaAvgAggregateOutputType = {
    id_Partida: number | null
    cuadrillasSugeridas: number | null
    hitoId: number | null
    procesoConstrutivoId: number | null
    paqueteTrabajoId: number | null
  }

  export type PartidaSumAggregateOutputType = {
    id_Partida: number | null
    cuadrillasSugeridas: number | null
    hitoId: number | null
    procesoConstrutivoId: number | null
    paqueteTrabajoId: number | null
  }

  export type PartidaMinAggregateOutputType = {
    id_Partida: number | null
    nombre: string | null
    medida: string | null
    ritmo: string | null
    cuadrillasSugeridas: number | null
    hitoId: number | null
    procesoConstrutivoId: number | null
    paqueteTrabajoId: number | null
  }

  export type PartidaMaxAggregateOutputType = {
    id_Partida: number | null
    nombre: string | null
    medida: string | null
    ritmo: string | null
    cuadrillasSugeridas: number | null
    hitoId: number | null
    procesoConstrutivoId: number | null
    paqueteTrabajoId: number | null
  }

  export type PartidaCountAggregateOutputType = {
    id_Partida: number
    nombre: number
    medida: number
    ritmo: number
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
    _all: number
  }


  export type PartidaAvgAggregateInputType = {
    id_Partida?: true
    cuadrillasSugeridas?: true
    hitoId?: true
    procesoConstrutivoId?: true
    paqueteTrabajoId?: true
  }

  export type PartidaSumAggregateInputType = {
    id_Partida?: true
    cuadrillasSugeridas?: true
    hitoId?: true
    procesoConstrutivoId?: true
    paqueteTrabajoId?: true
  }

  export type PartidaMinAggregateInputType = {
    id_Partida?: true
    nombre?: true
    medida?: true
    ritmo?: true
    cuadrillasSugeridas?: true
    hitoId?: true
    procesoConstrutivoId?: true
    paqueteTrabajoId?: true
  }

  export type PartidaMaxAggregateInputType = {
    id_Partida?: true
    nombre?: true
    medida?: true
    ritmo?: true
    cuadrillasSugeridas?: true
    hitoId?: true
    procesoConstrutivoId?: true
    paqueteTrabajoId?: true
  }

  export type PartidaCountAggregateInputType = {
    id_Partida?: true
    nombre?: true
    medida?: true
    ritmo?: true
    cuadrillasSugeridas?: true
    hitoId?: true
    procesoConstrutivoId?: true
    paqueteTrabajoId?: true
    _all?: true
  }

  export type PartidaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partida to aggregate.
     */
    where?: PartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partidas to fetch.
     */
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partidas
    **/
    _count?: true | PartidaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartidaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartidaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartidaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartidaMaxAggregateInputType
  }

  export type GetPartidaAggregateType<T extends PartidaAggregateArgs> = {
        [P in keyof T & keyof AggregatePartida]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartida[P]>
      : GetScalarType<T[P], AggregatePartida[P]>
  }




  export type PartidaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartidaWhereInput
    orderBy?: PartidaOrderByWithAggregationInput | PartidaOrderByWithAggregationInput[]
    by: PartidaScalarFieldEnum[] | PartidaScalarFieldEnum
    having?: PartidaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartidaCountAggregateInputType | true
    _avg?: PartidaAvgAggregateInputType
    _sum?: PartidaSumAggregateInputType
    _min?: PartidaMinAggregateInputType
    _max?: PartidaMaxAggregateInputType
  }

  export type PartidaGroupByOutputType = {
    id_Partida: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
    _count: PartidaCountAggregateOutputType | null
    _avg: PartidaAvgAggregateOutputType | null
    _sum: PartidaSumAggregateOutputType | null
    _min: PartidaMinAggregateOutputType | null
    _max: PartidaMaxAggregateOutputType | null
  }

  type GetPartidaGroupByPayload<T extends PartidaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartidaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartidaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartidaGroupByOutputType[P]>
            : GetScalarType<T[P], PartidaGroupByOutputType[P]>
        }
      >
    >


  export type PartidaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Partida?: boolean
    nombre?: boolean
    medida?: boolean
    ritmo?: boolean
    cuadrillasSugeridas?: boolean
    hitoId?: boolean
    procesoConstrutivoId?: boolean
    paqueteTrabajoId?: boolean
    hito?: boolean | HitoDefaultArgs<ExtArgs>
    procesoConstrutivo?: boolean | ProcesoConstrutivoDefaultArgs<ExtArgs>
    paqueteTrabajo?: boolean | PaqueteTrabajoDefaultArgs<ExtArgs>
    pmFrentePartidas?: boolean | Partida$pmFrentePartidasArgs<ExtArgs>
    planSemanalPartida?: boolean | Partida$planSemanalPartidaArgs<ExtArgs>
    _count?: boolean | PartidaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partida"]>

  export type PartidaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Partida?: boolean
    nombre?: boolean
    medida?: boolean
    ritmo?: boolean
    cuadrillasSugeridas?: boolean
    hitoId?: boolean
    procesoConstrutivoId?: boolean
    paqueteTrabajoId?: boolean
    hito?: boolean | HitoDefaultArgs<ExtArgs>
    procesoConstrutivo?: boolean | ProcesoConstrutivoDefaultArgs<ExtArgs>
    paqueteTrabajo?: boolean | PaqueteTrabajoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partida"]>

  export type PartidaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Partida?: boolean
    nombre?: boolean
    medida?: boolean
    ritmo?: boolean
    cuadrillasSugeridas?: boolean
    hitoId?: boolean
    procesoConstrutivoId?: boolean
    paqueteTrabajoId?: boolean
    hito?: boolean | HitoDefaultArgs<ExtArgs>
    procesoConstrutivo?: boolean | ProcesoConstrutivoDefaultArgs<ExtArgs>
    paqueteTrabajo?: boolean | PaqueteTrabajoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partida"]>

  export type PartidaSelectScalar = {
    id_Partida?: boolean
    nombre?: boolean
    medida?: boolean
    ritmo?: boolean
    cuadrillasSugeridas?: boolean
    hitoId?: boolean
    procesoConstrutivoId?: boolean
    paqueteTrabajoId?: boolean
  }

  export type PartidaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_Partida" | "nombre" | "medida" | "ritmo" | "cuadrillasSugeridas" | "hitoId" | "procesoConstrutivoId" | "paqueteTrabajoId", ExtArgs["result"]["partida"]>
  export type PartidaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hito?: boolean | HitoDefaultArgs<ExtArgs>
    procesoConstrutivo?: boolean | ProcesoConstrutivoDefaultArgs<ExtArgs>
    paqueteTrabajo?: boolean | PaqueteTrabajoDefaultArgs<ExtArgs>
    pmFrentePartidas?: boolean | Partida$pmFrentePartidasArgs<ExtArgs>
    planSemanalPartida?: boolean | Partida$planSemanalPartidaArgs<ExtArgs>
    _count?: boolean | PartidaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartidaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hito?: boolean | HitoDefaultArgs<ExtArgs>
    procesoConstrutivo?: boolean | ProcesoConstrutivoDefaultArgs<ExtArgs>
    paqueteTrabajo?: boolean | PaqueteTrabajoDefaultArgs<ExtArgs>
  }
  export type PartidaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hito?: boolean | HitoDefaultArgs<ExtArgs>
    procesoConstrutivo?: boolean | ProcesoConstrutivoDefaultArgs<ExtArgs>
    paqueteTrabajo?: boolean | PaqueteTrabajoDefaultArgs<ExtArgs>
  }

  export type $PartidaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partida"
    objects: {
      hito: Prisma.$HitoPayload<ExtArgs>
      procesoConstrutivo: Prisma.$ProcesoConstrutivoPayload<ExtArgs>
      paqueteTrabajo: Prisma.$PaqueteTrabajoPayload<ExtArgs>
      pmFrentePartidas: Prisma.$PmFrentePartidaPayload<ExtArgs>[]
      planSemanalPartida: Prisma.$PlanSemanalPartidaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_Partida: number
      nombre: string
      medida: string
      ritmo: string
      cuadrillasSugeridas: number
      hitoId: number
      procesoConstrutivoId: number
      paqueteTrabajoId: number
    }, ExtArgs["result"]["partida"]>
    composites: {}
  }

  type PartidaGetPayload<S extends boolean | null | undefined | PartidaDefaultArgs> = $Result.GetResult<Prisma.$PartidaPayload, S>

  type PartidaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartidaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartidaCountAggregateInputType | true
    }

  export interface PartidaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partida'], meta: { name: 'Partida' } }
    /**
     * Find zero or one Partida that matches the filter.
     * @param {PartidaFindUniqueArgs} args - Arguments to find a Partida
     * @example
     * // Get one Partida
     * const partida = await prisma.partida.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartidaFindUniqueArgs>(args: SelectSubset<T, PartidaFindUniqueArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partida that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartidaFindUniqueOrThrowArgs} args - Arguments to find a Partida
     * @example
     * // Get one Partida
     * const partida = await prisma.partida.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartidaFindUniqueOrThrowArgs>(args: SelectSubset<T, PartidaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partida that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaFindFirstArgs} args - Arguments to find a Partida
     * @example
     * // Get one Partida
     * const partida = await prisma.partida.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartidaFindFirstArgs>(args?: SelectSubset<T, PartidaFindFirstArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partida that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaFindFirstOrThrowArgs} args - Arguments to find a Partida
     * @example
     * // Get one Partida
     * const partida = await prisma.partida.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartidaFindFirstOrThrowArgs>(args?: SelectSubset<T, PartidaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partidas
     * const partidas = await prisma.partida.findMany()
     * 
     * // Get first 10 Partidas
     * const partidas = await prisma.partida.findMany({ take: 10 })
     * 
     * // Only select the `id_Partida`
     * const partidaWithId_PartidaOnly = await prisma.partida.findMany({ select: { id_Partida: true } })
     * 
     */
    findMany<T extends PartidaFindManyArgs>(args?: SelectSubset<T, PartidaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partida.
     * @param {PartidaCreateArgs} args - Arguments to create a Partida.
     * @example
     * // Create one Partida
     * const Partida = await prisma.partida.create({
     *   data: {
     *     // ... data to create a Partida
     *   }
     * })
     * 
     */
    create<T extends PartidaCreateArgs>(args: SelectSubset<T, PartidaCreateArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partidas.
     * @param {PartidaCreateManyArgs} args - Arguments to create many Partidas.
     * @example
     * // Create many Partidas
     * const partida = await prisma.partida.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartidaCreateManyArgs>(args?: SelectSubset<T, PartidaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partidas and returns the data saved in the database.
     * @param {PartidaCreateManyAndReturnArgs} args - Arguments to create many Partidas.
     * @example
     * // Create many Partidas
     * const partida = await prisma.partida.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partidas and only return the `id_Partida`
     * const partidaWithId_PartidaOnly = await prisma.partida.createManyAndReturn({
     *   select: { id_Partida: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartidaCreateManyAndReturnArgs>(args?: SelectSubset<T, PartidaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Partida.
     * @param {PartidaDeleteArgs} args - Arguments to delete one Partida.
     * @example
     * // Delete one Partida
     * const Partida = await prisma.partida.delete({
     *   where: {
     *     // ... filter to delete one Partida
     *   }
     * })
     * 
     */
    delete<T extends PartidaDeleteArgs>(args: SelectSubset<T, PartidaDeleteArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partida.
     * @param {PartidaUpdateArgs} args - Arguments to update one Partida.
     * @example
     * // Update one Partida
     * const partida = await prisma.partida.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartidaUpdateArgs>(args: SelectSubset<T, PartidaUpdateArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partidas.
     * @param {PartidaDeleteManyArgs} args - Arguments to filter Partidas to delete.
     * @example
     * // Delete a few Partidas
     * const { count } = await prisma.partida.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartidaDeleteManyArgs>(args?: SelectSubset<T, PartidaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partidas
     * const partida = await prisma.partida.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartidaUpdateManyArgs>(args: SelectSubset<T, PartidaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partidas and returns the data updated in the database.
     * @param {PartidaUpdateManyAndReturnArgs} args - Arguments to update many Partidas.
     * @example
     * // Update many Partidas
     * const partida = await prisma.partida.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Partidas and only return the `id_Partida`
     * const partidaWithId_PartidaOnly = await prisma.partida.updateManyAndReturn({
     *   select: { id_Partida: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartidaUpdateManyAndReturnArgs>(args: SelectSubset<T, PartidaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Partida.
     * @param {PartidaUpsertArgs} args - Arguments to update or create a Partida.
     * @example
     * // Update or create a Partida
     * const partida = await prisma.partida.upsert({
     *   create: {
     *     // ... data to create a Partida
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partida we want to update
     *   }
     * })
     */
    upsert<T extends PartidaUpsertArgs>(args: SelectSubset<T, PartidaUpsertArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Partidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaCountArgs} args - Arguments to filter Partidas to count.
     * @example
     * // Count the number of Partidas
     * const count = await prisma.partida.count({
     *   where: {
     *     // ... the filter for the Partidas we want to count
     *   }
     * })
    **/
    count<T extends PartidaCountArgs>(
      args?: Subset<T, PartidaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartidaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartidaAggregateArgs>(args: Subset<T, PartidaAggregateArgs>): Prisma.PrismaPromise<GetPartidaAggregateType<T>>

    /**
     * Group by Partida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartidaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartidaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartidaGroupByArgs['orderBy'] }
        : { orderBy?: PartidaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartidaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartidaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partida model
   */
  readonly fields: PartidaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partida.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartidaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hito<T extends HitoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HitoDefaultArgs<ExtArgs>>): Prisma__HitoClient<$Result.GetResult<Prisma.$HitoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    procesoConstrutivo<T extends ProcesoConstrutivoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoConstrutivoDefaultArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paqueteTrabajo<T extends PaqueteTrabajoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTrabajoDefaultArgs<ExtArgs>>): Prisma__PaqueteTrabajoClient<$Result.GetResult<Prisma.$PaqueteTrabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pmFrentePartidas<T extends Partida$pmFrentePartidasArgs<ExtArgs> = {}>(args?: Subset<T, Partida$pmFrentePartidasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    planSemanalPartida<T extends Partida$planSemanalPartidaArgs<ExtArgs> = {}>(args?: Subset<T, Partida$planSemanalPartidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partida model
   */
  interface PartidaFieldRefs {
    readonly id_Partida: FieldRef<"Partida", 'Int'>
    readonly nombre: FieldRef<"Partida", 'String'>
    readonly medida: FieldRef<"Partida", 'String'>
    readonly ritmo: FieldRef<"Partida", 'String'>
    readonly cuadrillasSugeridas: FieldRef<"Partida", 'Int'>
    readonly hitoId: FieldRef<"Partida", 'Int'>
    readonly procesoConstrutivoId: FieldRef<"Partida", 'Int'>
    readonly paqueteTrabajoId: FieldRef<"Partida", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Partida findUnique
   */
  export type PartidaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * Filter, which Partida to fetch.
     */
    where: PartidaWhereUniqueInput
  }

  /**
   * Partida findUniqueOrThrow
   */
  export type PartidaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * Filter, which Partida to fetch.
     */
    where: PartidaWhereUniqueInput
  }

  /**
   * Partida findFirst
   */
  export type PartidaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * Filter, which Partida to fetch.
     */
    where?: PartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partidas to fetch.
     */
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partidas.
     */
    cursor?: PartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partidas.
     */
    distinct?: PartidaScalarFieldEnum | PartidaScalarFieldEnum[]
  }

  /**
   * Partida findFirstOrThrow
   */
  export type PartidaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * Filter, which Partida to fetch.
     */
    where?: PartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partidas to fetch.
     */
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partidas.
     */
    cursor?: PartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partidas.
     */
    distinct?: PartidaScalarFieldEnum | PartidaScalarFieldEnum[]
  }

  /**
   * Partida findMany
   */
  export type PartidaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * Filter, which Partidas to fetch.
     */
    where?: PartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partidas to fetch.
     */
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partidas.
     */
    cursor?: PartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partidas.
     */
    skip?: number
    distinct?: PartidaScalarFieldEnum | PartidaScalarFieldEnum[]
  }

  /**
   * Partida create
   */
  export type PartidaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * The data needed to create a Partida.
     */
    data: XOR<PartidaCreateInput, PartidaUncheckedCreateInput>
  }

  /**
   * Partida createMany
   */
  export type PartidaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partidas.
     */
    data: PartidaCreateManyInput | PartidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partida createManyAndReturn
   */
  export type PartidaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * The data used to create many Partidas.
     */
    data: PartidaCreateManyInput | PartidaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partida update
   */
  export type PartidaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * The data needed to update a Partida.
     */
    data: XOR<PartidaUpdateInput, PartidaUncheckedUpdateInput>
    /**
     * Choose, which Partida to update.
     */
    where: PartidaWhereUniqueInput
  }

  /**
   * Partida updateMany
   */
  export type PartidaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partidas.
     */
    data: XOR<PartidaUpdateManyMutationInput, PartidaUncheckedUpdateManyInput>
    /**
     * Filter which Partidas to update
     */
    where?: PartidaWhereInput
    /**
     * Limit how many Partidas to update.
     */
    limit?: number
  }

  /**
   * Partida updateManyAndReturn
   */
  export type PartidaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * The data used to update Partidas.
     */
    data: XOR<PartidaUpdateManyMutationInput, PartidaUncheckedUpdateManyInput>
    /**
     * Filter which Partidas to update
     */
    where?: PartidaWhereInput
    /**
     * Limit how many Partidas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partida upsert
   */
  export type PartidaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * The filter to search for the Partida to update in case it exists.
     */
    where: PartidaWhereUniqueInput
    /**
     * In case the Partida found by the `where` argument doesn't exist, create a new Partida with this data.
     */
    create: XOR<PartidaCreateInput, PartidaUncheckedCreateInput>
    /**
     * In case the Partida was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartidaUpdateInput, PartidaUncheckedUpdateInput>
  }

  /**
   * Partida delete
   */
  export type PartidaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    /**
     * Filter which Partida to delete.
     */
    where: PartidaWhereUniqueInput
  }

  /**
   * Partida deleteMany
   */
  export type PartidaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partidas to delete
     */
    where?: PartidaWhereInput
    /**
     * Limit how many Partidas to delete.
     */
    limit?: number
  }

  /**
   * Partida.pmFrentePartidas
   */
  export type Partida$pmFrentePartidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    where?: PmFrentePartidaWhereInput
    orderBy?: PmFrentePartidaOrderByWithRelationInput | PmFrentePartidaOrderByWithRelationInput[]
    cursor?: PmFrentePartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmFrentePartidaScalarFieldEnum | PmFrentePartidaScalarFieldEnum[]
  }

  /**
   * Partida.planSemanalPartida
   */
  export type Partida$planSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    where?: PlanSemanalPartidaWhereInput
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    cursor?: PlanSemanalPartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * Partida without action
   */
  export type PartidaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
  }


  /**
   * Model ProcesoConstrutivo
   */

  export type AggregateProcesoConstrutivo = {
    _count: ProcesoConstrutivoCountAggregateOutputType | null
    _avg: ProcesoConstrutivoAvgAggregateOutputType | null
    _sum: ProcesoConstrutivoSumAggregateOutputType | null
    _min: ProcesoConstrutivoMinAggregateOutputType | null
    _max: ProcesoConstrutivoMaxAggregateOutputType | null
  }

  export type ProcesoConstrutivoAvgAggregateOutputType = {
    id_ProcesoConstrutivo: number | null
    jerarquia: number | null
  }

  export type ProcesoConstrutivoSumAggregateOutputType = {
    id_ProcesoConstrutivo: number | null
    jerarquia: number | null
  }

  export type ProcesoConstrutivoMinAggregateOutputType = {
    id_ProcesoConstrutivo: number | null
    nombre: string | null
    descripcion: string | null
    jerarquia: number | null
    esActivo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcesoConstrutivoMaxAggregateOutputType = {
    id_ProcesoConstrutivo: number | null
    nombre: string | null
    descripcion: string | null
    jerarquia: number | null
    esActivo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcesoConstrutivoCountAggregateOutputType = {
    id_ProcesoConstrutivo: number
    nombre: number
    descripcion: number
    jerarquia: number
    esActivo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcesoConstrutivoAvgAggregateInputType = {
    id_ProcesoConstrutivo?: true
    jerarquia?: true
  }

  export type ProcesoConstrutivoSumAggregateInputType = {
    id_ProcesoConstrutivo?: true
    jerarquia?: true
  }

  export type ProcesoConstrutivoMinAggregateInputType = {
    id_ProcesoConstrutivo?: true
    nombre?: true
    descripcion?: true
    jerarquia?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcesoConstrutivoMaxAggregateInputType = {
    id_ProcesoConstrutivo?: true
    nombre?: true
    descripcion?: true
    jerarquia?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcesoConstrutivoCountAggregateInputType = {
    id_ProcesoConstrutivo?: true
    nombre?: true
    descripcion?: true
    jerarquia?: true
    esActivo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcesoConstrutivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcesoConstrutivo to aggregate.
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcesoConstrutivos to fetch.
     */
    orderBy?: ProcesoConstrutivoOrderByWithRelationInput | ProcesoConstrutivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcesoConstrutivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcesoConstrutivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcesoConstrutivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcesoConstrutivos
    **/
    _count?: true | ProcesoConstrutivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcesoConstrutivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcesoConstrutivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcesoConstrutivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcesoConstrutivoMaxAggregateInputType
  }

  export type GetProcesoConstrutivoAggregateType<T extends ProcesoConstrutivoAggregateArgs> = {
        [P in keyof T & keyof AggregateProcesoConstrutivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcesoConstrutivo[P]>
      : GetScalarType<T[P], AggregateProcesoConstrutivo[P]>
  }




  export type ProcesoConstrutivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcesoConstrutivoWhereInput
    orderBy?: ProcesoConstrutivoOrderByWithAggregationInput | ProcesoConstrutivoOrderByWithAggregationInput[]
    by: ProcesoConstrutivoScalarFieldEnum[] | ProcesoConstrutivoScalarFieldEnum
    having?: ProcesoConstrutivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcesoConstrutivoCountAggregateInputType | true
    _avg?: ProcesoConstrutivoAvgAggregateInputType
    _sum?: ProcesoConstrutivoSumAggregateInputType
    _min?: ProcesoConstrutivoMinAggregateInputType
    _max?: ProcesoConstrutivoMaxAggregateInputType
  }

  export type ProcesoConstrutivoGroupByOutputType = {
    id_ProcesoConstrutivo: number
    nombre: string
    descripcion: string
    jerarquia: number
    esActivo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProcesoConstrutivoCountAggregateOutputType | null
    _avg: ProcesoConstrutivoAvgAggregateOutputType | null
    _sum: ProcesoConstrutivoSumAggregateOutputType | null
    _min: ProcesoConstrutivoMinAggregateOutputType | null
    _max: ProcesoConstrutivoMaxAggregateOutputType | null
  }

  type GetProcesoConstrutivoGroupByPayload<T extends ProcesoConstrutivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcesoConstrutivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcesoConstrutivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcesoConstrutivoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcesoConstrutivoGroupByOutputType[P]>
        }
      >
    >


  export type ProcesoConstrutivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ProcesoConstrutivo?: boolean
    nombre?: boolean
    descripcion?: boolean
    jerarquia?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partida?: boolean | ProcesoConstrutivo$partidaArgs<ExtArgs>
    _count?: boolean | ProcesoConstrutivoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procesoConstrutivo"]>

  export type ProcesoConstrutivoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ProcesoConstrutivo?: boolean
    nombre?: boolean
    descripcion?: boolean
    jerarquia?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["procesoConstrutivo"]>

  export type ProcesoConstrutivoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ProcesoConstrutivo?: boolean
    nombre?: boolean
    descripcion?: boolean
    jerarquia?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["procesoConstrutivo"]>

  export type ProcesoConstrutivoSelectScalar = {
    id_ProcesoConstrutivo?: boolean
    nombre?: boolean
    descripcion?: boolean
    jerarquia?: boolean
    esActivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcesoConstrutivoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_ProcesoConstrutivo" | "nombre" | "descripcion" | "jerarquia" | "esActivo" | "createdAt" | "updatedAt", ExtArgs["result"]["procesoConstrutivo"]>
  export type ProcesoConstrutivoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | ProcesoConstrutivo$partidaArgs<ExtArgs>
    _count?: boolean | ProcesoConstrutivoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcesoConstrutivoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProcesoConstrutivoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProcesoConstrutivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcesoConstrutivo"
    objects: {
      partida: Prisma.$PartidaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_ProcesoConstrutivo: number
      nombre: string
      descripcion: string
      jerarquia: number
      esActivo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["procesoConstrutivo"]>
    composites: {}
  }

  type ProcesoConstrutivoGetPayload<S extends boolean | null | undefined | ProcesoConstrutivoDefaultArgs> = $Result.GetResult<Prisma.$ProcesoConstrutivoPayload, S>

  type ProcesoConstrutivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcesoConstrutivoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProcesoConstrutivoCountAggregateInputType | true
    }

  export interface ProcesoConstrutivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcesoConstrutivo'], meta: { name: 'ProcesoConstrutivo' } }
    /**
     * Find zero or one ProcesoConstrutivo that matches the filter.
     * @param {ProcesoConstrutivoFindUniqueArgs} args - Arguments to find a ProcesoConstrutivo
     * @example
     * // Get one ProcesoConstrutivo
     * const procesoConstrutivo = await prisma.procesoConstrutivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcesoConstrutivoFindUniqueArgs>(args: SelectSubset<T, ProcesoConstrutivoFindUniqueArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcesoConstrutivo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcesoConstrutivoFindUniqueOrThrowArgs} args - Arguments to find a ProcesoConstrutivo
     * @example
     * // Get one ProcesoConstrutivo
     * const procesoConstrutivo = await prisma.procesoConstrutivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcesoConstrutivoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcesoConstrutivoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcesoConstrutivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoFindFirstArgs} args - Arguments to find a ProcesoConstrutivo
     * @example
     * // Get one ProcesoConstrutivo
     * const procesoConstrutivo = await prisma.procesoConstrutivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcesoConstrutivoFindFirstArgs>(args?: SelectSubset<T, ProcesoConstrutivoFindFirstArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcesoConstrutivo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoFindFirstOrThrowArgs} args - Arguments to find a ProcesoConstrutivo
     * @example
     * // Get one ProcesoConstrutivo
     * const procesoConstrutivo = await prisma.procesoConstrutivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcesoConstrutivoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcesoConstrutivoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcesoConstrutivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcesoConstrutivos
     * const procesoConstrutivos = await prisma.procesoConstrutivo.findMany()
     * 
     * // Get first 10 ProcesoConstrutivos
     * const procesoConstrutivos = await prisma.procesoConstrutivo.findMany({ take: 10 })
     * 
     * // Only select the `id_ProcesoConstrutivo`
     * const procesoConstrutivoWithId_ProcesoConstrutivoOnly = await prisma.procesoConstrutivo.findMany({ select: { id_ProcesoConstrutivo: true } })
     * 
     */
    findMany<T extends ProcesoConstrutivoFindManyArgs>(args?: SelectSubset<T, ProcesoConstrutivoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcesoConstrutivo.
     * @param {ProcesoConstrutivoCreateArgs} args - Arguments to create a ProcesoConstrutivo.
     * @example
     * // Create one ProcesoConstrutivo
     * const ProcesoConstrutivo = await prisma.procesoConstrutivo.create({
     *   data: {
     *     // ... data to create a ProcesoConstrutivo
     *   }
     * })
     * 
     */
    create<T extends ProcesoConstrutivoCreateArgs>(args: SelectSubset<T, ProcesoConstrutivoCreateArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcesoConstrutivos.
     * @param {ProcesoConstrutivoCreateManyArgs} args - Arguments to create many ProcesoConstrutivos.
     * @example
     * // Create many ProcesoConstrutivos
     * const procesoConstrutivo = await prisma.procesoConstrutivo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcesoConstrutivoCreateManyArgs>(args?: SelectSubset<T, ProcesoConstrutivoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcesoConstrutivos and returns the data saved in the database.
     * @param {ProcesoConstrutivoCreateManyAndReturnArgs} args - Arguments to create many ProcesoConstrutivos.
     * @example
     * // Create many ProcesoConstrutivos
     * const procesoConstrutivo = await prisma.procesoConstrutivo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcesoConstrutivos and only return the `id_ProcesoConstrutivo`
     * const procesoConstrutivoWithId_ProcesoConstrutivoOnly = await prisma.procesoConstrutivo.createManyAndReturn({
     *   select: { id_ProcesoConstrutivo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcesoConstrutivoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcesoConstrutivoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcesoConstrutivo.
     * @param {ProcesoConstrutivoDeleteArgs} args - Arguments to delete one ProcesoConstrutivo.
     * @example
     * // Delete one ProcesoConstrutivo
     * const ProcesoConstrutivo = await prisma.procesoConstrutivo.delete({
     *   where: {
     *     // ... filter to delete one ProcesoConstrutivo
     *   }
     * })
     * 
     */
    delete<T extends ProcesoConstrutivoDeleteArgs>(args: SelectSubset<T, ProcesoConstrutivoDeleteArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcesoConstrutivo.
     * @param {ProcesoConstrutivoUpdateArgs} args - Arguments to update one ProcesoConstrutivo.
     * @example
     * // Update one ProcesoConstrutivo
     * const procesoConstrutivo = await prisma.procesoConstrutivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcesoConstrutivoUpdateArgs>(args: SelectSubset<T, ProcesoConstrutivoUpdateArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcesoConstrutivos.
     * @param {ProcesoConstrutivoDeleteManyArgs} args - Arguments to filter ProcesoConstrutivos to delete.
     * @example
     * // Delete a few ProcesoConstrutivos
     * const { count } = await prisma.procesoConstrutivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcesoConstrutivoDeleteManyArgs>(args?: SelectSubset<T, ProcesoConstrutivoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcesoConstrutivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcesoConstrutivos
     * const procesoConstrutivo = await prisma.procesoConstrutivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcesoConstrutivoUpdateManyArgs>(args: SelectSubset<T, ProcesoConstrutivoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcesoConstrutivos and returns the data updated in the database.
     * @param {ProcesoConstrutivoUpdateManyAndReturnArgs} args - Arguments to update many ProcesoConstrutivos.
     * @example
     * // Update many ProcesoConstrutivos
     * const procesoConstrutivo = await prisma.procesoConstrutivo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcesoConstrutivos and only return the `id_ProcesoConstrutivo`
     * const procesoConstrutivoWithId_ProcesoConstrutivoOnly = await prisma.procesoConstrutivo.updateManyAndReturn({
     *   select: { id_ProcesoConstrutivo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcesoConstrutivoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcesoConstrutivoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcesoConstrutivo.
     * @param {ProcesoConstrutivoUpsertArgs} args - Arguments to update or create a ProcesoConstrutivo.
     * @example
     * // Update or create a ProcesoConstrutivo
     * const procesoConstrutivo = await prisma.procesoConstrutivo.upsert({
     *   create: {
     *     // ... data to create a ProcesoConstrutivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcesoConstrutivo we want to update
     *   }
     * })
     */
    upsert<T extends ProcesoConstrutivoUpsertArgs>(args: SelectSubset<T, ProcesoConstrutivoUpsertArgs<ExtArgs>>): Prisma__ProcesoConstrutivoClient<$Result.GetResult<Prisma.$ProcesoConstrutivoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcesoConstrutivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoCountArgs} args - Arguments to filter ProcesoConstrutivos to count.
     * @example
     * // Count the number of ProcesoConstrutivos
     * const count = await prisma.procesoConstrutivo.count({
     *   where: {
     *     // ... the filter for the ProcesoConstrutivos we want to count
     *   }
     * })
    **/
    count<T extends ProcesoConstrutivoCountArgs>(
      args?: Subset<T, ProcesoConstrutivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcesoConstrutivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcesoConstrutivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcesoConstrutivoAggregateArgs>(args: Subset<T, ProcesoConstrutivoAggregateArgs>): Prisma.PrismaPromise<GetProcesoConstrutivoAggregateType<T>>

    /**
     * Group by ProcesoConstrutivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoConstrutivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcesoConstrutivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcesoConstrutivoGroupByArgs['orderBy'] }
        : { orderBy?: ProcesoConstrutivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcesoConstrutivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcesoConstrutivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcesoConstrutivo model
   */
  readonly fields: ProcesoConstrutivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcesoConstrutivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcesoConstrutivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partida<T extends ProcesoConstrutivo$partidaArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoConstrutivo$partidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcesoConstrutivo model
   */
  interface ProcesoConstrutivoFieldRefs {
    readonly id_ProcesoConstrutivo: FieldRef<"ProcesoConstrutivo", 'Int'>
    readonly nombre: FieldRef<"ProcesoConstrutivo", 'String'>
    readonly descripcion: FieldRef<"ProcesoConstrutivo", 'String'>
    readonly jerarquia: FieldRef<"ProcesoConstrutivo", 'Int'>
    readonly esActivo: FieldRef<"ProcesoConstrutivo", 'Boolean'>
    readonly createdAt: FieldRef<"ProcesoConstrutivo", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcesoConstrutivo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcesoConstrutivo findUnique
   */
  export type ProcesoConstrutivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * Filter, which ProcesoConstrutivo to fetch.
     */
    where: ProcesoConstrutivoWhereUniqueInput
  }

  /**
   * ProcesoConstrutivo findUniqueOrThrow
   */
  export type ProcesoConstrutivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * Filter, which ProcesoConstrutivo to fetch.
     */
    where: ProcesoConstrutivoWhereUniqueInput
  }

  /**
   * ProcesoConstrutivo findFirst
   */
  export type ProcesoConstrutivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * Filter, which ProcesoConstrutivo to fetch.
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcesoConstrutivos to fetch.
     */
    orderBy?: ProcesoConstrutivoOrderByWithRelationInput | ProcesoConstrutivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcesoConstrutivos.
     */
    cursor?: ProcesoConstrutivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcesoConstrutivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcesoConstrutivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcesoConstrutivos.
     */
    distinct?: ProcesoConstrutivoScalarFieldEnum | ProcesoConstrutivoScalarFieldEnum[]
  }

  /**
   * ProcesoConstrutivo findFirstOrThrow
   */
  export type ProcesoConstrutivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * Filter, which ProcesoConstrutivo to fetch.
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcesoConstrutivos to fetch.
     */
    orderBy?: ProcesoConstrutivoOrderByWithRelationInput | ProcesoConstrutivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcesoConstrutivos.
     */
    cursor?: ProcesoConstrutivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcesoConstrutivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcesoConstrutivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcesoConstrutivos.
     */
    distinct?: ProcesoConstrutivoScalarFieldEnum | ProcesoConstrutivoScalarFieldEnum[]
  }

  /**
   * ProcesoConstrutivo findMany
   */
  export type ProcesoConstrutivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * Filter, which ProcesoConstrutivos to fetch.
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcesoConstrutivos to fetch.
     */
    orderBy?: ProcesoConstrutivoOrderByWithRelationInput | ProcesoConstrutivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcesoConstrutivos.
     */
    cursor?: ProcesoConstrutivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcesoConstrutivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcesoConstrutivos.
     */
    skip?: number
    distinct?: ProcesoConstrutivoScalarFieldEnum | ProcesoConstrutivoScalarFieldEnum[]
  }

  /**
   * ProcesoConstrutivo create
   */
  export type ProcesoConstrutivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcesoConstrutivo.
     */
    data: XOR<ProcesoConstrutivoCreateInput, ProcesoConstrutivoUncheckedCreateInput>
  }

  /**
   * ProcesoConstrutivo createMany
   */
  export type ProcesoConstrutivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcesoConstrutivos.
     */
    data: ProcesoConstrutivoCreateManyInput | ProcesoConstrutivoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcesoConstrutivo createManyAndReturn
   */
  export type ProcesoConstrutivoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * The data used to create many ProcesoConstrutivos.
     */
    data: ProcesoConstrutivoCreateManyInput | ProcesoConstrutivoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcesoConstrutivo update
   */
  export type ProcesoConstrutivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcesoConstrutivo.
     */
    data: XOR<ProcesoConstrutivoUpdateInput, ProcesoConstrutivoUncheckedUpdateInput>
    /**
     * Choose, which ProcesoConstrutivo to update.
     */
    where: ProcesoConstrutivoWhereUniqueInput
  }

  /**
   * ProcesoConstrutivo updateMany
   */
  export type ProcesoConstrutivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcesoConstrutivos.
     */
    data: XOR<ProcesoConstrutivoUpdateManyMutationInput, ProcesoConstrutivoUncheckedUpdateManyInput>
    /**
     * Filter which ProcesoConstrutivos to update
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * Limit how many ProcesoConstrutivos to update.
     */
    limit?: number
  }

  /**
   * ProcesoConstrutivo updateManyAndReturn
   */
  export type ProcesoConstrutivoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * The data used to update ProcesoConstrutivos.
     */
    data: XOR<ProcesoConstrutivoUpdateManyMutationInput, ProcesoConstrutivoUncheckedUpdateManyInput>
    /**
     * Filter which ProcesoConstrutivos to update
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * Limit how many ProcesoConstrutivos to update.
     */
    limit?: number
  }

  /**
   * ProcesoConstrutivo upsert
   */
  export type ProcesoConstrutivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcesoConstrutivo to update in case it exists.
     */
    where: ProcesoConstrutivoWhereUniqueInput
    /**
     * In case the ProcesoConstrutivo found by the `where` argument doesn't exist, create a new ProcesoConstrutivo with this data.
     */
    create: XOR<ProcesoConstrutivoCreateInput, ProcesoConstrutivoUncheckedCreateInput>
    /**
     * In case the ProcesoConstrutivo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcesoConstrutivoUpdateInput, ProcesoConstrutivoUncheckedUpdateInput>
  }

  /**
   * ProcesoConstrutivo delete
   */
  export type ProcesoConstrutivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
    /**
     * Filter which ProcesoConstrutivo to delete.
     */
    where: ProcesoConstrutivoWhereUniqueInput
  }

  /**
   * ProcesoConstrutivo deleteMany
   */
  export type ProcesoConstrutivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcesoConstrutivos to delete
     */
    where?: ProcesoConstrutivoWhereInput
    /**
     * Limit how many ProcesoConstrutivos to delete.
     */
    limit?: number
  }

  /**
   * ProcesoConstrutivo.partida
   */
  export type ProcesoConstrutivo$partidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partida
     */
    select?: PartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partida
     */
    omit?: PartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartidaInclude<ExtArgs> | null
    where?: PartidaWhereInput
    orderBy?: PartidaOrderByWithRelationInput | PartidaOrderByWithRelationInput[]
    cursor?: PartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartidaScalarFieldEnum | PartidaScalarFieldEnum[]
  }

  /**
   * ProcesoConstrutivo without action
   */
  export type ProcesoConstrutivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoConstrutivo
     */
    select?: ProcesoConstrutivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcesoConstrutivo
     */
    omit?: ProcesoConstrutivoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoConstrutivoInclude<ExtArgs> | null
  }


  /**
   * Model PlanMaestro
   */

  export type AggregatePlanMaestro = {
    _count: PlanMaestroCountAggregateOutputType | null
    _avg: PlanMaestroAvgAggregateOutputType | null
    _sum: PlanMaestroSumAggregateOutputType | null
    _min: PlanMaestroMinAggregateOutputType | null
    _max: PlanMaestroMaxAggregateOutputType | null
  }

  export type PlanMaestroAvgAggregateOutputType = {
    id_PlanMaestro: number | null
    proyectoId: number | null
  }

  export type PlanMaestroSumAggregateOutputType = {
    id_PlanMaestro: number | null
    proyectoId: number | null
  }

  export type PlanMaestroMinAggregateOutputType = {
    id_PlanMaestro: number | null
    descripcion: string | null
    fechaInicio: Date | null
    proyectoId: number | null
  }

  export type PlanMaestroMaxAggregateOutputType = {
    id_PlanMaestro: number | null
    descripcion: string | null
    fechaInicio: Date | null
    proyectoId: number | null
  }

  export type PlanMaestroCountAggregateOutputType = {
    id_PlanMaestro: number
    descripcion: number
    fechaInicio: number
    proyectoId: number
    _all: number
  }


  export type PlanMaestroAvgAggregateInputType = {
    id_PlanMaestro?: true
    proyectoId?: true
  }

  export type PlanMaestroSumAggregateInputType = {
    id_PlanMaestro?: true
    proyectoId?: true
  }

  export type PlanMaestroMinAggregateInputType = {
    id_PlanMaestro?: true
    descripcion?: true
    fechaInicio?: true
    proyectoId?: true
  }

  export type PlanMaestroMaxAggregateInputType = {
    id_PlanMaestro?: true
    descripcion?: true
    fechaInicio?: true
    proyectoId?: true
  }

  export type PlanMaestroCountAggregateInputType = {
    id_PlanMaestro?: true
    descripcion?: true
    fechaInicio?: true
    proyectoId?: true
    _all?: true
  }

  export type PlanMaestroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanMaestro to aggregate.
     */
    where?: PlanMaestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMaestros to fetch.
     */
    orderBy?: PlanMaestroOrderByWithRelationInput | PlanMaestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanMaestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMaestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMaestros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanMaestros
    **/
    _count?: true | PlanMaestroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanMaestroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanMaestroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMaestroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaestroMaxAggregateInputType
  }

  export type GetPlanMaestroAggregateType<T extends PlanMaestroAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanMaestro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanMaestro[P]>
      : GetScalarType<T[P], AggregatePlanMaestro[P]>
  }




  export type PlanMaestroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMaestroWhereInput
    orderBy?: PlanMaestroOrderByWithAggregationInput | PlanMaestroOrderByWithAggregationInput[]
    by: PlanMaestroScalarFieldEnum[] | PlanMaestroScalarFieldEnum
    having?: PlanMaestroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanMaestroCountAggregateInputType | true
    _avg?: PlanMaestroAvgAggregateInputType
    _sum?: PlanMaestroSumAggregateInputType
    _min?: PlanMaestroMinAggregateInputType
    _max?: PlanMaestroMaxAggregateInputType
  }

  export type PlanMaestroGroupByOutputType = {
    id_PlanMaestro: number
    descripcion: string
    fechaInicio: Date
    proyectoId: number
    _count: PlanMaestroCountAggregateOutputType | null
    _avg: PlanMaestroAvgAggregateOutputType | null
    _sum: PlanMaestroSumAggregateOutputType | null
    _min: PlanMaestroMinAggregateOutputType | null
    _max: PlanMaestroMaxAggregateOutputType | null
  }

  type GetPlanMaestroGroupByPayload<T extends PlanMaestroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanMaestroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanMaestroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanMaestroGroupByOutputType[P]>
            : GetScalarType<T[P], PlanMaestroGroupByOutputType[P]>
        }
      >
    >


  export type PlanMaestroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanMaestro?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    proyectoId?: boolean
    proyecto?: boolean | ProyectoDefaultArgs<ExtArgs>
    equipoTrabajos?: boolean | PlanMaestro$equipoTrabajosArgs<ExtArgs>
    pmFrentes?: boolean | PlanMaestro$pmFrentesArgs<ExtArgs>
    _count?: boolean | PlanMaestroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planMaestro"]>

  export type PlanMaestroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanMaestro?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    proyectoId?: boolean
    proyecto?: boolean | ProyectoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planMaestro"]>

  export type PlanMaestroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanMaestro?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    proyectoId?: boolean
    proyecto?: boolean | ProyectoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planMaestro"]>

  export type PlanMaestroSelectScalar = {
    id_PlanMaestro?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    proyectoId?: boolean
  }

  export type PlanMaestroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PlanMaestro" | "descripcion" | "fechaInicio" | "proyectoId", ExtArgs["result"]["planMaestro"]>
  export type PlanMaestroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyecto?: boolean | ProyectoDefaultArgs<ExtArgs>
    equipoTrabajos?: boolean | PlanMaestro$equipoTrabajosArgs<ExtArgs>
    pmFrentes?: boolean | PlanMaestro$pmFrentesArgs<ExtArgs>
    _count?: boolean | PlanMaestroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanMaestroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyecto?: boolean | ProyectoDefaultArgs<ExtArgs>
  }
  export type PlanMaestroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proyecto?: boolean | ProyectoDefaultArgs<ExtArgs>
  }

  export type $PlanMaestroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanMaestro"
    objects: {
      proyecto: Prisma.$ProyectoPayload<ExtArgs>
      equipoTrabajos: Prisma.$EquipoTrabajoPayload<ExtArgs>[]
      pmFrentes: Prisma.$PmFrentePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PlanMaestro: number
      descripcion: string
      fechaInicio: Date
      proyectoId: number
    }, ExtArgs["result"]["planMaestro"]>
    composites: {}
  }

  type PlanMaestroGetPayload<S extends boolean | null | undefined | PlanMaestroDefaultArgs> = $Result.GetResult<Prisma.$PlanMaestroPayload, S>

  type PlanMaestroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanMaestroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanMaestroCountAggregateInputType | true
    }

  export interface PlanMaestroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanMaestro'], meta: { name: 'PlanMaestro' } }
    /**
     * Find zero or one PlanMaestro that matches the filter.
     * @param {PlanMaestroFindUniqueArgs} args - Arguments to find a PlanMaestro
     * @example
     * // Get one PlanMaestro
     * const planMaestro = await prisma.planMaestro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanMaestroFindUniqueArgs>(args: SelectSubset<T, PlanMaestroFindUniqueArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanMaestro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanMaestroFindUniqueOrThrowArgs} args - Arguments to find a PlanMaestro
     * @example
     * // Get one PlanMaestro
     * const planMaestro = await prisma.planMaestro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanMaestroFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanMaestroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanMaestro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroFindFirstArgs} args - Arguments to find a PlanMaestro
     * @example
     * // Get one PlanMaestro
     * const planMaestro = await prisma.planMaestro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanMaestroFindFirstArgs>(args?: SelectSubset<T, PlanMaestroFindFirstArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanMaestro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroFindFirstOrThrowArgs} args - Arguments to find a PlanMaestro
     * @example
     * // Get one PlanMaestro
     * const planMaestro = await prisma.planMaestro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanMaestroFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanMaestroFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanMaestros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanMaestros
     * const planMaestros = await prisma.planMaestro.findMany()
     * 
     * // Get first 10 PlanMaestros
     * const planMaestros = await prisma.planMaestro.findMany({ take: 10 })
     * 
     * // Only select the `id_PlanMaestro`
     * const planMaestroWithId_PlanMaestroOnly = await prisma.planMaestro.findMany({ select: { id_PlanMaestro: true } })
     * 
     */
    findMany<T extends PlanMaestroFindManyArgs>(args?: SelectSubset<T, PlanMaestroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanMaestro.
     * @param {PlanMaestroCreateArgs} args - Arguments to create a PlanMaestro.
     * @example
     * // Create one PlanMaestro
     * const PlanMaestro = await prisma.planMaestro.create({
     *   data: {
     *     // ... data to create a PlanMaestro
     *   }
     * })
     * 
     */
    create<T extends PlanMaestroCreateArgs>(args: SelectSubset<T, PlanMaestroCreateArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanMaestros.
     * @param {PlanMaestroCreateManyArgs} args - Arguments to create many PlanMaestros.
     * @example
     * // Create many PlanMaestros
     * const planMaestro = await prisma.planMaestro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanMaestroCreateManyArgs>(args?: SelectSubset<T, PlanMaestroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanMaestros and returns the data saved in the database.
     * @param {PlanMaestroCreateManyAndReturnArgs} args - Arguments to create many PlanMaestros.
     * @example
     * // Create many PlanMaestros
     * const planMaestro = await prisma.planMaestro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanMaestros and only return the `id_PlanMaestro`
     * const planMaestroWithId_PlanMaestroOnly = await prisma.planMaestro.createManyAndReturn({
     *   select: { id_PlanMaestro: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanMaestroCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanMaestroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanMaestro.
     * @param {PlanMaestroDeleteArgs} args - Arguments to delete one PlanMaestro.
     * @example
     * // Delete one PlanMaestro
     * const PlanMaestro = await prisma.planMaestro.delete({
     *   where: {
     *     // ... filter to delete one PlanMaestro
     *   }
     * })
     * 
     */
    delete<T extends PlanMaestroDeleteArgs>(args: SelectSubset<T, PlanMaestroDeleteArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanMaestro.
     * @param {PlanMaestroUpdateArgs} args - Arguments to update one PlanMaestro.
     * @example
     * // Update one PlanMaestro
     * const planMaestro = await prisma.planMaestro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanMaestroUpdateArgs>(args: SelectSubset<T, PlanMaestroUpdateArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanMaestros.
     * @param {PlanMaestroDeleteManyArgs} args - Arguments to filter PlanMaestros to delete.
     * @example
     * // Delete a few PlanMaestros
     * const { count } = await prisma.planMaestro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanMaestroDeleteManyArgs>(args?: SelectSubset<T, PlanMaestroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanMaestros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanMaestros
     * const planMaestro = await prisma.planMaestro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanMaestroUpdateManyArgs>(args: SelectSubset<T, PlanMaestroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanMaestros and returns the data updated in the database.
     * @param {PlanMaestroUpdateManyAndReturnArgs} args - Arguments to update many PlanMaestros.
     * @example
     * // Update many PlanMaestros
     * const planMaestro = await prisma.planMaestro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanMaestros and only return the `id_PlanMaestro`
     * const planMaestroWithId_PlanMaestroOnly = await prisma.planMaestro.updateManyAndReturn({
     *   select: { id_PlanMaestro: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanMaestroUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanMaestroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanMaestro.
     * @param {PlanMaestroUpsertArgs} args - Arguments to update or create a PlanMaestro.
     * @example
     * // Update or create a PlanMaestro
     * const planMaestro = await prisma.planMaestro.upsert({
     *   create: {
     *     // ... data to create a PlanMaestro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanMaestro we want to update
     *   }
     * })
     */
    upsert<T extends PlanMaestroUpsertArgs>(args: SelectSubset<T, PlanMaestroUpsertArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanMaestros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroCountArgs} args - Arguments to filter PlanMaestros to count.
     * @example
     * // Count the number of PlanMaestros
     * const count = await prisma.planMaestro.count({
     *   where: {
     *     // ... the filter for the PlanMaestros we want to count
     *   }
     * })
    **/
    count<T extends PlanMaestroCountArgs>(
      args?: Subset<T, PlanMaestroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanMaestroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanMaestro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanMaestroAggregateArgs>(args: Subset<T, PlanMaestroAggregateArgs>): Prisma.PrismaPromise<GetPlanMaestroAggregateType<T>>

    /**
     * Group by PlanMaestro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMaestroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanMaestroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanMaestroGroupByArgs['orderBy'] }
        : { orderBy?: PlanMaestroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanMaestroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanMaestroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanMaestro model
   */
  readonly fields: PlanMaestroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanMaestro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanMaestroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proyecto<T extends ProyectoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProyectoDefaultArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipoTrabajos<T extends PlanMaestro$equipoTrabajosArgs<ExtArgs> = {}>(args?: Subset<T, PlanMaestro$equipoTrabajosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pmFrentes<T extends PlanMaestro$pmFrentesArgs<ExtArgs> = {}>(args?: Subset<T, PlanMaestro$pmFrentesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanMaestro model
   */
  interface PlanMaestroFieldRefs {
    readonly id_PlanMaestro: FieldRef<"PlanMaestro", 'Int'>
    readonly descripcion: FieldRef<"PlanMaestro", 'String'>
    readonly fechaInicio: FieldRef<"PlanMaestro", 'DateTime'>
    readonly proyectoId: FieldRef<"PlanMaestro", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlanMaestro findUnique
   */
  export type PlanMaestroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * Filter, which PlanMaestro to fetch.
     */
    where: PlanMaestroWhereUniqueInput
  }

  /**
   * PlanMaestro findUniqueOrThrow
   */
  export type PlanMaestroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * Filter, which PlanMaestro to fetch.
     */
    where: PlanMaestroWhereUniqueInput
  }

  /**
   * PlanMaestro findFirst
   */
  export type PlanMaestroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * Filter, which PlanMaestro to fetch.
     */
    where?: PlanMaestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMaestros to fetch.
     */
    orderBy?: PlanMaestroOrderByWithRelationInput | PlanMaestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanMaestros.
     */
    cursor?: PlanMaestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMaestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMaestros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanMaestros.
     */
    distinct?: PlanMaestroScalarFieldEnum | PlanMaestroScalarFieldEnum[]
  }

  /**
   * PlanMaestro findFirstOrThrow
   */
  export type PlanMaestroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * Filter, which PlanMaestro to fetch.
     */
    where?: PlanMaestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMaestros to fetch.
     */
    orderBy?: PlanMaestroOrderByWithRelationInput | PlanMaestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanMaestros.
     */
    cursor?: PlanMaestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMaestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMaestros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanMaestros.
     */
    distinct?: PlanMaestroScalarFieldEnum | PlanMaestroScalarFieldEnum[]
  }

  /**
   * PlanMaestro findMany
   */
  export type PlanMaestroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * Filter, which PlanMaestros to fetch.
     */
    where?: PlanMaestroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMaestros to fetch.
     */
    orderBy?: PlanMaestroOrderByWithRelationInput | PlanMaestroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanMaestros.
     */
    cursor?: PlanMaestroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMaestros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMaestros.
     */
    skip?: number
    distinct?: PlanMaestroScalarFieldEnum | PlanMaestroScalarFieldEnum[]
  }

  /**
   * PlanMaestro create
   */
  export type PlanMaestroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanMaestro.
     */
    data: XOR<PlanMaestroCreateInput, PlanMaestroUncheckedCreateInput>
  }

  /**
   * PlanMaestro createMany
   */
  export type PlanMaestroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanMaestros.
     */
    data: PlanMaestroCreateManyInput | PlanMaestroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanMaestro createManyAndReturn
   */
  export type PlanMaestroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * The data used to create many PlanMaestros.
     */
    data: PlanMaestroCreateManyInput | PlanMaestroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanMaestro update
   */
  export type PlanMaestroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanMaestro.
     */
    data: XOR<PlanMaestroUpdateInput, PlanMaestroUncheckedUpdateInput>
    /**
     * Choose, which PlanMaestro to update.
     */
    where: PlanMaestroWhereUniqueInput
  }

  /**
   * PlanMaestro updateMany
   */
  export type PlanMaestroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanMaestros.
     */
    data: XOR<PlanMaestroUpdateManyMutationInput, PlanMaestroUncheckedUpdateManyInput>
    /**
     * Filter which PlanMaestros to update
     */
    where?: PlanMaestroWhereInput
    /**
     * Limit how many PlanMaestros to update.
     */
    limit?: number
  }

  /**
   * PlanMaestro updateManyAndReturn
   */
  export type PlanMaestroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * The data used to update PlanMaestros.
     */
    data: XOR<PlanMaestroUpdateManyMutationInput, PlanMaestroUncheckedUpdateManyInput>
    /**
     * Filter which PlanMaestros to update
     */
    where?: PlanMaestroWhereInput
    /**
     * Limit how many PlanMaestros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanMaestro upsert
   */
  export type PlanMaestroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanMaestro to update in case it exists.
     */
    where: PlanMaestroWhereUniqueInput
    /**
     * In case the PlanMaestro found by the `where` argument doesn't exist, create a new PlanMaestro with this data.
     */
    create: XOR<PlanMaestroCreateInput, PlanMaestroUncheckedCreateInput>
    /**
     * In case the PlanMaestro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanMaestroUpdateInput, PlanMaestroUncheckedUpdateInput>
  }

  /**
   * PlanMaestro delete
   */
  export type PlanMaestroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    /**
     * Filter which PlanMaestro to delete.
     */
    where: PlanMaestroWhereUniqueInput
  }

  /**
   * PlanMaestro deleteMany
   */
  export type PlanMaestroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanMaestros to delete
     */
    where?: PlanMaestroWhereInput
    /**
     * Limit how many PlanMaestros to delete.
     */
    limit?: number
  }

  /**
   * PlanMaestro.equipoTrabajos
   */
  export type PlanMaestro$equipoTrabajosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    where?: EquipoTrabajoWhereInput
    orderBy?: EquipoTrabajoOrderByWithRelationInput | EquipoTrabajoOrderByWithRelationInput[]
    cursor?: EquipoTrabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipoTrabajoScalarFieldEnum | EquipoTrabajoScalarFieldEnum[]
  }

  /**
   * PlanMaestro.pmFrentes
   */
  export type PlanMaestro$pmFrentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    where?: PmFrenteWhereInput
    orderBy?: PmFrenteOrderByWithRelationInput | PmFrenteOrderByWithRelationInput[]
    cursor?: PmFrenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmFrenteScalarFieldEnum | PmFrenteScalarFieldEnum[]
  }

  /**
   * PlanMaestro without action
   */
  export type PlanMaestroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
  }


  /**
   * Model PmFrente
   */

  export type AggregatePmFrente = {
    _count: PmFrenteCountAggregateOutputType | null
    _avg: PmFrenteAvgAggregateOutputType | null
    _sum: PmFrenteSumAggregateOutputType | null
    _min: PmFrenteMinAggregateOutputType | null
    _max: PmFrenteMaxAggregateOutputType | null
  }

  export type PmFrenteAvgAggregateOutputType = {
    id_PmFrente: number | null
    planMaestroId: number | null
  }

  export type PmFrenteSumAggregateOutputType = {
    id_PmFrente: number | null
    planMaestroId: number | null
  }

  export type PmFrenteMinAggregateOutputType = {
    id_PmFrente: number | null
    planMaestroId: number | null
    nombre: string | null
  }

  export type PmFrenteMaxAggregateOutputType = {
    id_PmFrente: number | null
    planMaestroId: number | null
    nombre: string | null
  }

  export type PmFrenteCountAggregateOutputType = {
    id_PmFrente: number
    planMaestroId: number
    nombre: number
    _all: number
  }


  export type PmFrenteAvgAggregateInputType = {
    id_PmFrente?: true
    planMaestroId?: true
  }

  export type PmFrenteSumAggregateInputType = {
    id_PmFrente?: true
    planMaestroId?: true
  }

  export type PmFrenteMinAggregateInputType = {
    id_PmFrente?: true
    planMaestroId?: true
    nombre?: true
  }

  export type PmFrenteMaxAggregateInputType = {
    id_PmFrente?: true
    planMaestroId?: true
    nombre?: true
  }

  export type PmFrenteCountAggregateInputType = {
    id_PmFrente?: true
    planMaestroId?: true
    nombre?: true
    _all?: true
  }

  export type PmFrenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmFrente to aggregate.
     */
    where?: PmFrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentes to fetch.
     */
    orderBy?: PmFrenteOrderByWithRelationInput | PmFrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PmFrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PmFrentes
    **/
    _count?: true | PmFrenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PmFrenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PmFrenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PmFrenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PmFrenteMaxAggregateInputType
  }

  export type GetPmFrenteAggregateType<T extends PmFrenteAggregateArgs> = {
        [P in keyof T & keyof AggregatePmFrente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePmFrente[P]>
      : GetScalarType<T[P], AggregatePmFrente[P]>
  }




  export type PmFrenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmFrenteWhereInput
    orderBy?: PmFrenteOrderByWithAggregationInput | PmFrenteOrderByWithAggregationInput[]
    by: PmFrenteScalarFieldEnum[] | PmFrenteScalarFieldEnum
    having?: PmFrenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PmFrenteCountAggregateInputType | true
    _avg?: PmFrenteAvgAggregateInputType
    _sum?: PmFrenteSumAggregateInputType
    _min?: PmFrenteMinAggregateInputType
    _max?: PmFrenteMaxAggregateInputType
  }

  export type PmFrenteGroupByOutputType = {
    id_PmFrente: number
    planMaestroId: number
    nombre: string
    _count: PmFrenteCountAggregateOutputType | null
    _avg: PmFrenteAvgAggregateOutputType | null
    _sum: PmFrenteSumAggregateOutputType | null
    _min: PmFrenteMinAggregateOutputType | null
    _max: PmFrenteMaxAggregateOutputType | null
  }

  type GetPmFrenteGroupByPayload<T extends PmFrenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PmFrenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PmFrenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PmFrenteGroupByOutputType[P]>
            : GetScalarType<T[P], PmFrenteGroupByOutputType[P]>
        }
      >
    >


  export type PmFrenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmFrente?: boolean
    planMaestroId?: boolean
    nombre?: boolean
    planMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
    pmFrentePartidas?: boolean | PmFrente$pmFrentePartidasArgs<ExtArgs>
    planSemanal?: boolean | PmFrente$planSemanalArgs<ExtArgs>
    _count?: boolean | PmFrenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmFrente"]>

  export type PmFrenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmFrente?: boolean
    planMaestroId?: boolean
    nombre?: boolean
    planMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmFrente"]>

  export type PmFrenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmFrente?: boolean
    planMaestroId?: boolean
    nombre?: boolean
    planMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmFrente"]>

  export type PmFrenteSelectScalar = {
    id_PmFrente?: boolean
    planMaestroId?: boolean
    nombre?: boolean
  }

  export type PmFrenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PmFrente" | "planMaestroId" | "nombre", ExtArgs["result"]["pmFrente"]>
  export type PmFrenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
    pmFrentePartidas?: boolean | PmFrente$pmFrentePartidasArgs<ExtArgs>
    planSemanal?: boolean | PmFrente$planSemanalArgs<ExtArgs>
    _count?: boolean | PmFrenteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PmFrenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }
  export type PmFrenteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }

  export type $PmFrentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PmFrente"
    objects: {
      planMaestro: Prisma.$PlanMaestroPayload<ExtArgs>
      pmFrentePartidas: Prisma.$PmFrentePartidaPayload<ExtArgs>[]
      planSemanal: Prisma.$PlanSemanalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PmFrente: number
      planMaestroId: number
      nombre: string
    }, ExtArgs["result"]["pmFrente"]>
    composites: {}
  }

  type PmFrenteGetPayload<S extends boolean | null | undefined | PmFrenteDefaultArgs> = $Result.GetResult<Prisma.$PmFrentePayload, S>

  type PmFrenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PmFrenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PmFrenteCountAggregateInputType | true
    }

  export interface PmFrenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PmFrente'], meta: { name: 'PmFrente' } }
    /**
     * Find zero or one PmFrente that matches the filter.
     * @param {PmFrenteFindUniqueArgs} args - Arguments to find a PmFrente
     * @example
     * // Get one PmFrente
     * const pmFrente = await prisma.pmFrente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PmFrenteFindUniqueArgs>(args: SelectSubset<T, PmFrenteFindUniqueArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PmFrente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PmFrenteFindUniqueOrThrowArgs} args - Arguments to find a PmFrente
     * @example
     * // Get one PmFrente
     * const pmFrente = await prisma.pmFrente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PmFrenteFindUniqueOrThrowArgs>(args: SelectSubset<T, PmFrenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmFrente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteFindFirstArgs} args - Arguments to find a PmFrente
     * @example
     * // Get one PmFrente
     * const pmFrente = await prisma.pmFrente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PmFrenteFindFirstArgs>(args?: SelectSubset<T, PmFrenteFindFirstArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmFrente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteFindFirstOrThrowArgs} args - Arguments to find a PmFrente
     * @example
     * // Get one PmFrente
     * const pmFrente = await prisma.pmFrente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PmFrenteFindFirstOrThrowArgs>(args?: SelectSubset<T, PmFrenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PmFrentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PmFrentes
     * const pmFrentes = await prisma.pmFrente.findMany()
     * 
     * // Get first 10 PmFrentes
     * const pmFrentes = await prisma.pmFrente.findMany({ take: 10 })
     * 
     * // Only select the `id_PmFrente`
     * const pmFrenteWithId_PmFrenteOnly = await prisma.pmFrente.findMany({ select: { id_PmFrente: true } })
     * 
     */
    findMany<T extends PmFrenteFindManyArgs>(args?: SelectSubset<T, PmFrenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PmFrente.
     * @param {PmFrenteCreateArgs} args - Arguments to create a PmFrente.
     * @example
     * // Create one PmFrente
     * const PmFrente = await prisma.pmFrente.create({
     *   data: {
     *     // ... data to create a PmFrente
     *   }
     * })
     * 
     */
    create<T extends PmFrenteCreateArgs>(args: SelectSubset<T, PmFrenteCreateArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PmFrentes.
     * @param {PmFrenteCreateManyArgs} args - Arguments to create many PmFrentes.
     * @example
     * // Create many PmFrentes
     * const pmFrente = await prisma.pmFrente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PmFrenteCreateManyArgs>(args?: SelectSubset<T, PmFrenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PmFrentes and returns the data saved in the database.
     * @param {PmFrenteCreateManyAndReturnArgs} args - Arguments to create many PmFrentes.
     * @example
     * // Create many PmFrentes
     * const pmFrente = await prisma.pmFrente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PmFrentes and only return the `id_PmFrente`
     * const pmFrenteWithId_PmFrenteOnly = await prisma.pmFrente.createManyAndReturn({
     *   select: { id_PmFrente: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PmFrenteCreateManyAndReturnArgs>(args?: SelectSubset<T, PmFrenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PmFrente.
     * @param {PmFrenteDeleteArgs} args - Arguments to delete one PmFrente.
     * @example
     * // Delete one PmFrente
     * const PmFrente = await prisma.pmFrente.delete({
     *   where: {
     *     // ... filter to delete one PmFrente
     *   }
     * })
     * 
     */
    delete<T extends PmFrenteDeleteArgs>(args: SelectSubset<T, PmFrenteDeleteArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PmFrente.
     * @param {PmFrenteUpdateArgs} args - Arguments to update one PmFrente.
     * @example
     * // Update one PmFrente
     * const pmFrente = await prisma.pmFrente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PmFrenteUpdateArgs>(args: SelectSubset<T, PmFrenteUpdateArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PmFrentes.
     * @param {PmFrenteDeleteManyArgs} args - Arguments to filter PmFrentes to delete.
     * @example
     * // Delete a few PmFrentes
     * const { count } = await prisma.pmFrente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PmFrenteDeleteManyArgs>(args?: SelectSubset<T, PmFrenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmFrentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PmFrentes
     * const pmFrente = await prisma.pmFrente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PmFrenteUpdateManyArgs>(args: SelectSubset<T, PmFrenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmFrentes and returns the data updated in the database.
     * @param {PmFrenteUpdateManyAndReturnArgs} args - Arguments to update many PmFrentes.
     * @example
     * // Update many PmFrentes
     * const pmFrente = await prisma.pmFrente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PmFrentes and only return the `id_PmFrente`
     * const pmFrenteWithId_PmFrenteOnly = await prisma.pmFrente.updateManyAndReturn({
     *   select: { id_PmFrente: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PmFrenteUpdateManyAndReturnArgs>(args: SelectSubset<T, PmFrenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PmFrente.
     * @param {PmFrenteUpsertArgs} args - Arguments to update or create a PmFrente.
     * @example
     * // Update or create a PmFrente
     * const pmFrente = await prisma.pmFrente.upsert({
     *   create: {
     *     // ... data to create a PmFrente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PmFrente we want to update
     *   }
     * })
     */
    upsert<T extends PmFrenteUpsertArgs>(args: SelectSubset<T, PmFrenteUpsertArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PmFrentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteCountArgs} args - Arguments to filter PmFrentes to count.
     * @example
     * // Count the number of PmFrentes
     * const count = await prisma.pmFrente.count({
     *   where: {
     *     // ... the filter for the PmFrentes we want to count
     *   }
     * })
    **/
    count<T extends PmFrenteCountArgs>(
      args?: Subset<T, PmFrenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PmFrenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PmFrente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PmFrenteAggregateArgs>(args: Subset<T, PmFrenteAggregateArgs>): Prisma.PrismaPromise<GetPmFrenteAggregateType<T>>

    /**
     * Group by PmFrente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PmFrenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PmFrenteGroupByArgs['orderBy'] }
        : { orderBy?: PmFrenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PmFrenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPmFrenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PmFrente model
   */
  readonly fields: PmFrenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PmFrente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PmFrenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planMaestro<T extends PlanMaestroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanMaestroDefaultArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pmFrentePartidas<T extends PmFrente$pmFrentePartidasArgs<ExtArgs> = {}>(args?: Subset<T, PmFrente$pmFrentePartidasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    planSemanal<T extends PmFrente$planSemanalArgs<ExtArgs> = {}>(args?: Subset<T, PmFrente$planSemanalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PmFrente model
   */
  interface PmFrenteFieldRefs {
    readonly id_PmFrente: FieldRef<"PmFrente", 'Int'>
    readonly planMaestroId: FieldRef<"PmFrente", 'Int'>
    readonly nombre: FieldRef<"PmFrente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PmFrente findUnique
   */
  export type PmFrenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * Filter, which PmFrente to fetch.
     */
    where: PmFrenteWhereUniqueInput
  }

  /**
   * PmFrente findUniqueOrThrow
   */
  export type PmFrenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * Filter, which PmFrente to fetch.
     */
    where: PmFrenteWhereUniqueInput
  }

  /**
   * PmFrente findFirst
   */
  export type PmFrenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * Filter, which PmFrente to fetch.
     */
    where?: PmFrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentes to fetch.
     */
    orderBy?: PmFrenteOrderByWithRelationInput | PmFrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmFrentes.
     */
    cursor?: PmFrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmFrentes.
     */
    distinct?: PmFrenteScalarFieldEnum | PmFrenteScalarFieldEnum[]
  }

  /**
   * PmFrente findFirstOrThrow
   */
  export type PmFrenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * Filter, which PmFrente to fetch.
     */
    where?: PmFrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentes to fetch.
     */
    orderBy?: PmFrenteOrderByWithRelationInput | PmFrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmFrentes.
     */
    cursor?: PmFrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmFrentes.
     */
    distinct?: PmFrenteScalarFieldEnum | PmFrenteScalarFieldEnum[]
  }

  /**
   * PmFrente findMany
   */
  export type PmFrenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * Filter, which PmFrentes to fetch.
     */
    where?: PmFrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentes to fetch.
     */
    orderBy?: PmFrenteOrderByWithRelationInput | PmFrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PmFrentes.
     */
    cursor?: PmFrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentes.
     */
    skip?: number
    distinct?: PmFrenteScalarFieldEnum | PmFrenteScalarFieldEnum[]
  }

  /**
   * PmFrente create
   */
  export type PmFrenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * The data needed to create a PmFrente.
     */
    data: XOR<PmFrenteCreateInput, PmFrenteUncheckedCreateInput>
  }

  /**
   * PmFrente createMany
   */
  export type PmFrenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PmFrentes.
     */
    data: PmFrenteCreateManyInput | PmFrenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PmFrente createManyAndReturn
   */
  export type PmFrenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * The data used to create many PmFrentes.
     */
    data: PmFrenteCreateManyInput | PmFrenteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmFrente update
   */
  export type PmFrenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * The data needed to update a PmFrente.
     */
    data: XOR<PmFrenteUpdateInput, PmFrenteUncheckedUpdateInput>
    /**
     * Choose, which PmFrente to update.
     */
    where: PmFrenteWhereUniqueInput
  }

  /**
   * PmFrente updateMany
   */
  export type PmFrenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PmFrentes.
     */
    data: XOR<PmFrenteUpdateManyMutationInput, PmFrenteUncheckedUpdateManyInput>
    /**
     * Filter which PmFrentes to update
     */
    where?: PmFrenteWhereInput
    /**
     * Limit how many PmFrentes to update.
     */
    limit?: number
  }

  /**
   * PmFrente updateManyAndReturn
   */
  export type PmFrenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * The data used to update PmFrentes.
     */
    data: XOR<PmFrenteUpdateManyMutationInput, PmFrenteUncheckedUpdateManyInput>
    /**
     * Filter which PmFrentes to update
     */
    where?: PmFrenteWhereInput
    /**
     * Limit how many PmFrentes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmFrente upsert
   */
  export type PmFrenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * The filter to search for the PmFrente to update in case it exists.
     */
    where: PmFrenteWhereUniqueInput
    /**
     * In case the PmFrente found by the `where` argument doesn't exist, create a new PmFrente with this data.
     */
    create: XOR<PmFrenteCreateInput, PmFrenteUncheckedCreateInput>
    /**
     * In case the PmFrente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PmFrenteUpdateInput, PmFrenteUncheckedUpdateInput>
  }

  /**
   * PmFrente delete
   */
  export type PmFrenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
    /**
     * Filter which PmFrente to delete.
     */
    where: PmFrenteWhereUniqueInput
  }

  /**
   * PmFrente deleteMany
   */
  export type PmFrenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmFrentes to delete
     */
    where?: PmFrenteWhereInput
    /**
     * Limit how many PmFrentes to delete.
     */
    limit?: number
  }

  /**
   * PmFrente.pmFrentePartidas
   */
  export type PmFrente$pmFrentePartidasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    where?: PmFrentePartidaWhereInput
    orderBy?: PmFrentePartidaOrderByWithRelationInput | PmFrentePartidaOrderByWithRelationInput[]
    cursor?: PmFrentePartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmFrentePartidaScalarFieldEnum | PmFrentePartidaScalarFieldEnum[]
  }

  /**
   * PmFrente.planSemanal
   */
  export type PmFrente$planSemanalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    where?: PlanSemanalWhereInput
    orderBy?: PlanSemanalOrderByWithRelationInput | PlanSemanalOrderByWithRelationInput[]
    cursor?: PlanSemanalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanSemanalScalarFieldEnum | PlanSemanalScalarFieldEnum[]
  }

  /**
   * PmFrente without action
   */
  export type PmFrenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrente
     */
    select?: PmFrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrente
     */
    omit?: PmFrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrenteInclude<ExtArgs> | null
  }


  /**
   * Model PmFrentePartida
   */

  export type AggregatePmFrentePartida = {
    _count: PmFrentePartidaCountAggregateOutputType | null
    _avg: PmFrentePartidaAvgAggregateOutputType | null
    _sum: PmFrentePartidaSumAggregateOutputType | null
    _min: PmFrentePartidaMinAggregateOutputType | null
    _max: PmFrentePartidaMaxAggregateOutputType | null
  }

  export type PmFrentePartidaAvgAggregateOutputType = {
    id_PmFrentePartida: number | null
    partidaId: number | null
    cuadrilla: number | null
    frenteId: number | null
    orden: number | null
  }

  export type PmFrentePartidaSumAggregateOutputType = {
    id_PmFrentePartida: number | null
    partidaId: number | null
    cuadrilla: number | null
    frenteId: number | null
    orden: number | null
  }

  export type PmFrentePartidaMinAggregateOutputType = {
    id_PmFrentePartida: number | null
    partidaId: number | null
    cuadrilla: number | null
    frenteId: number | null
    orden: number | null
  }

  export type PmFrentePartidaMaxAggregateOutputType = {
    id_PmFrentePartida: number | null
    partidaId: number | null
    cuadrilla: number | null
    frenteId: number | null
    orden: number | null
  }

  export type PmFrentePartidaCountAggregateOutputType = {
    id_PmFrentePartida: number
    partidaId: number
    cuadrilla: number
    frenteId: number
    orden: number
    _all: number
  }


  export type PmFrentePartidaAvgAggregateInputType = {
    id_PmFrentePartida?: true
    partidaId?: true
    cuadrilla?: true
    frenteId?: true
    orden?: true
  }

  export type PmFrentePartidaSumAggregateInputType = {
    id_PmFrentePartida?: true
    partidaId?: true
    cuadrilla?: true
    frenteId?: true
    orden?: true
  }

  export type PmFrentePartidaMinAggregateInputType = {
    id_PmFrentePartida?: true
    partidaId?: true
    cuadrilla?: true
    frenteId?: true
    orden?: true
  }

  export type PmFrentePartidaMaxAggregateInputType = {
    id_PmFrentePartida?: true
    partidaId?: true
    cuadrilla?: true
    frenteId?: true
    orden?: true
  }

  export type PmFrentePartidaCountAggregateInputType = {
    id_PmFrentePartida?: true
    partidaId?: true
    cuadrilla?: true
    frenteId?: true
    orden?: true
    _all?: true
  }

  export type PmFrentePartidaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmFrentePartida to aggregate.
     */
    where?: PmFrentePartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentePartidas to fetch.
     */
    orderBy?: PmFrentePartidaOrderByWithRelationInput | PmFrentePartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PmFrentePartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentePartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentePartidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PmFrentePartidas
    **/
    _count?: true | PmFrentePartidaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PmFrentePartidaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PmFrentePartidaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PmFrentePartidaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PmFrentePartidaMaxAggregateInputType
  }

  export type GetPmFrentePartidaAggregateType<T extends PmFrentePartidaAggregateArgs> = {
        [P in keyof T & keyof AggregatePmFrentePartida]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePmFrentePartida[P]>
      : GetScalarType<T[P], AggregatePmFrentePartida[P]>
  }




  export type PmFrentePartidaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmFrentePartidaWhereInput
    orderBy?: PmFrentePartidaOrderByWithAggregationInput | PmFrentePartidaOrderByWithAggregationInput[]
    by: PmFrentePartidaScalarFieldEnum[] | PmFrentePartidaScalarFieldEnum
    having?: PmFrentePartidaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PmFrentePartidaCountAggregateInputType | true
    _avg?: PmFrentePartidaAvgAggregateInputType
    _sum?: PmFrentePartidaSumAggregateInputType
    _min?: PmFrentePartidaMinAggregateInputType
    _max?: PmFrentePartidaMaxAggregateInputType
  }

  export type PmFrentePartidaGroupByOutputType = {
    id_PmFrentePartida: number
    partidaId: number
    cuadrilla: number
    frenteId: number
    orden: number
    _count: PmFrentePartidaCountAggregateOutputType | null
    _avg: PmFrentePartidaAvgAggregateOutputType | null
    _sum: PmFrentePartidaSumAggregateOutputType | null
    _min: PmFrentePartidaMinAggregateOutputType | null
    _max: PmFrentePartidaMaxAggregateOutputType | null
  }

  type GetPmFrentePartidaGroupByPayload<T extends PmFrentePartidaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PmFrentePartidaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PmFrentePartidaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PmFrentePartidaGroupByOutputType[P]>
            : GetScalarType<T[P], PmFrentePartidaGroupByOutputType[P]>
        }
      >
    >


  export type PmFrentePartidaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmFrentePartida?: boolean
    partidaId?: boolean
    cuadrilla?: boolean
    frenteId?: boolean
    orden?: boolean
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    frente?: boolean | PmFrenteDefaultArgs<ExtArgs>
    pmProgramacion?: boolean | PmFrentePartida$pmProgramacionArgs<ExtArgs>
    _count?: boolean | PmFrentePartidaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmFrentePartida"]>

  export type PmFrentePartidaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmFrentePartida?: boolean
    partidaId?: boolean
    cuadrilla?: boolean
    frenteId?: boolean
    orden?: boolean
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    frente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmFrentePartida"]>

  export type PmFrentePartidaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmFrentePartida?: boolean
    partidaId?: boolean
    cuadrilla?: boolean
    frenteId?: boolean
    orden?: boolean
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    frente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmFrentePartida"]>

  export type PmFrentePartidaSelectScalar = {
    id_PmFrentePartida?: boolean
    partidaId?: boolean
    cuadrilla?: boolean
    frenteId?: boolean
    orden?: boolean
  }

  export type PmFrentePartidaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PmFrentePartida" | "partidaId" | "cuadrilla" | "frenteId" | "orden", ExtArgs["result"]["pmFrentePartida"]>
  export type PmFrentePartidaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    frente?: boolean | PmFrenteDefaultArgs<ExtArgs>
    pmProgramacion?: boolean | PmFrentePartida$pmProgramacionArgs<ExtArgs>
    _count?: boolean | PmFrentePartidaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PmFrentePartidaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    frente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }
  export type PmFrentePartidaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    frente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }

  export type $PmFrentePartidaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PmFrentePartida"
    objects: {
      partida: Prisma.$PartidaPayload<ExtArgs>
      frente: Prisma.$PmFrentePayload<ExtArgs>
      pmProgramacion: Prisma.$PmProgramacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PmFrentePartida: number
      partidaId: number
      cuadrilla: number
      frenteId: number
      orden: number
    }, ExtArgs["result"]["pmFrentePartida"]>
    composites: {}
  }

  type PmFrentePartidaGetPayload<S extends boolean | null | undefined | PmFrentePartidaDefaultArgs> = $Result.GetResult<Prisma.$PmFrentePartidaPayload, S>

  type PmFrentePartidaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PmFrentePartidaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PmFrentePartidaCountAggregateInputType | true
    }

  export interface PmFrentePartidaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PmFrentePartida'], meta: { name: 'PmFrentePartida' } }
    /**
     * Find zero or one PmFrentePartida that matches the filter.
     * @param {PmFrentePartidaFindUniqueArgs} args - Arguments to find a PmFrentePartida
     * @example
     * // Get one PmFrentePartida
     * const pmFrentePartida = await prisma.pmFrentePartida.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PmFrentePartidaFindUniqueArgs>(args: SelectSubset<T, PmFrentePartidaFindUniqueArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PmFrentePartida that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PmFrentePartidaFindUniqueOrThrowArgs} args - Arguments to find a PmFrentePartida
     * @example
     * // Get one PmFrentePartida
     * const pmFrentePartida = await prisma.pmFrentePartida.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PmFrentePartidaFindUniqueOrThrowArgs>(args: SelectSubset<T, PmFrentePartidaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmFrentePartida that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaFindFirstArgs} args - Arguments to find a PmFrentePartida
     * @example
     * // Get one PmFrentePartida
     * const pmFrentePartida = await prisma.pmFrentePartida.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PmFrentePartidaFindFirstArgs>(args?: SelectSubset<T, PmFrentePartidaFindFirstArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmFrentePartida that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaFindFirstOrThrowArgs} args - Arguments to find a PmFrentePartida
     * @example
     * // Get one PmFrentePartida
     * const pmFrentePartida = await prisma.pmFrentePartida.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PmFrentePartidaFindFirstOrThrowArgs>(args?: SelectSubset<T, PmFrentePartidaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PmFrentePartidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PmFrentePartidas
     * const pmFrentePartidas = await prisma.pmFrentePartida.findMany()
     * 
     * // Get first 10 PmFrentePartidas
     * const pmFrentePartidas = await prisma.pmFrentePartida.findMany({ take: 10 })
     * 
     * // Only select the `id_PmFrentePartida`
     * const pmFrentePartidaWithId_PmFrentePartidaOnly = await prisma.pmFrentePartida.findMany({ select: { id_PmFrentePartida: true } })
     * 
     */
    findMany<T extends PmFrentePartidaFindManyArgs>(args?: SelectSubset<T, PmFrentePartidaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PmFrentePartida.
     * @param {PmFrentePartidaCreateArgs} args - Arguments to create a PmFrentePartida.
     * @example
     * // Create one PmFrentePartida
     * const PmFrentePartida = await prisma.pmFrentePartida.create({
     *   data: {
     *     // ... data to create a PmFrentePartida
     *   }
     * })
     * 
     */
    create<T extends PmFrentePartidaCreateArgs>(args: SelectSubset<T, PmFrentePartidaCreateArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PmFrentePartidas.
     * @param {PmFrentePartidaCreateManyArgs} args - Arguments to create many PmFrentePartidas.
     * @example
     * // Create many PmFrentePartidas
     * const pmFrentePartida = await prisma.pmFrentePartida.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PmFrentePartidaCreateManyArgs>(args?: SelectSubset<T, PmFrentePartidaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PmFrentePartidas and returns the data saved in the database.
     * @param {PmFrentePartidaCreateManyAndReturnArgs} args - Arguments to create many PmFrentePartidas.
     * @example
     * // Create many PmFrentePartidas
     * const pmFrentePartida = await prisma.pmFrentePartida.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PmFrentePartidas and only return the `id_PmFrentePartida`
     * const pmFrentePartidaWithId_PmFrentePartidaOnly = await prisma.pmFrentePartida.createManyAndReturn({
     *   select: { id_PmFrentePartida: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PmFrentePartidaCreateManyAndReturnArgs>(args?: SelectSubset<T, PmFrentePartidaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PmFrentePartida.
     * @param {PmFrentePartidaDeleteArgs} args - Arguments to delete one PmFrentePartida.
     * @example
     * // Delete one PmFrentePartida
     * const PmFrentePartida = await prisma.pmFrentePartida.delete({
     *   where: {
     *     // ... filter to delete one PmFrentePartida
     *   }
     * })
     * 
     */
    delete<T extends PmFrentePartidaDeleteArgs>(args: SelectSubset<T, PmFrentePartidaDeleteArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PmFrentePartida.
     * @param {PmFrentePartidaUpdateArgs} args - Arguments to update one PmFrentePartida.
     * @example
     * // Update one PmFrentePartida
     * const pmFrentePartida = await prisma.pmFrentePartida.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PmFrentePartidaUpdateArgs>(args: SelectSubset<T, PmFrentePartidaUpdateArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PmFrentePartidas.
     * @param {PmFrentePartidaDeleteManyArgs} args - Arguments to filter PmFrentePartidas to delete.
     * @example
     * // Delete a few PmFrentePartidas
     * const { count } = await prisma.pmFrentePartida.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PmFrentePartidaDeleteManyArgs>(args?: SelectSubset<T, PmFrentePartidaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmFrentePartidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PmFrentePartidas
     * const pmFrentePartida = await prisma.pmFrentePartida.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PmFrentePartidaUpdateManyArgs>(args: SelectSubset<T, PmFrentePartidaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmFrentePartidas and returns the data updated in the database.
     * @param {PmFrentePartidaUpdateManyAndReturnArgs} args - Arguments to update many PmFrentePartidas.
     * @example
     * // Update many PmFrentePartidas
     * const pmFrentePartida = await prisma.pmFrentePartida.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PmFrentePartidas and only return the `id_PmFrentePartida`
     * const pmFrentePartidaWithId_PmFrentePartidaOnly = await prisma.pmFrentePartida.updateManyAndReturn({
     *   select: { id_PmFrentePartida: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PmFrentePartidaUpdateManyAndReturnArgs>(args: SelectSubset<T, PmFrentePartidaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PmFrentePartida.
     * @param {PmFrentePartidaUpsertArgs} args - Arguments to update or create a PmFrentePartida.
     * @example
     * // Update or create a PmFrentePartida
     * const pmFrentePartida = await prisma.pmFrentePartida.upsert({
     *   create: {
     *     // ... data to create a PmFrentePartida
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PmFrentePartida we want to update
     *   }
     * })
     */
    upsert<T extends PmFrentePartidaUpsertArgs>(args: SelectSubset<T, PmFrentePartidaUpsertArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PmFrentePartidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaCountArgs} args - Arguments to filter PmFrentePartidas to count.
     * @example
     * // Count the number of PmFrentePartidas
     * const count = await prisma.pmFrentePartida.count({
     *   where: {
     *     // ... the filter for the PmFrentePartidas we want to count
     *   }
     * })
    **/
    count<T extends PmFrentePartidaCountArgs>(
      args?: Subset<T, PmFrentePartidaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PmFrentePartidaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PmFrentePartida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PmFrentePartidaAggregateArgs>(args: Subset<T, PmFrentePartidaAggregateArgs>): Prisma.PrismaPromise<GetPmFrentePartidaAggregateType<T>>

    /**
     * Group by PmFrentePartida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmFrentePartidaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PmFrentePartidaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PmFrentePartidaGroupByArgs['orderBy'] }
        : { orderBy?: PmFrentePartidaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PmFrentePartidaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPmFrentePartidaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PmFrentePartida model
   */
  readonly fields: PmFrentePartidaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PmFrentePartida.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PmFrentePartidaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partida<T extends PartidaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartidaDefaultArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    frente<T extends PmFrenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PmFrenteDefaultArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pmProgramacion<T extends PmFrentePartida$pmProgramacionArgs<ExtArgs> = {}>(args?: Subset<T, PmFrentePartida$pmProgramacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PmFrentePartida model
   */
  interface PmFrentePartidaFieldRefs {
    readonly id_PmFrentePartida: FieldRef<"PmFrentePartida", 'Int'>
    readonly partidaId: FieldRef<"PmFrentePartida", 'Int'>
    readonly cuadrilla: FieldRef<"PmFrentePartida", 'Int'>
    readonly frenteId: FieldRef<"PmFrentePartida", 'Int'>
    readonly orden: FieldRef<"PmFrentePartida", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PmFrentePartida findUnique
   */
  export type PmFrentePartidaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * Filter, which PmFrentePartida to fetch.
     */
    where: PmFrentePartidaWhereUniqueInput
  }

  /**
   * PmFrentePartida findUniqueOrThrow
   */
  export type PmFrentePartidaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * Filter, which PmFrentePartida to fetch.
     */
    where: PmFrentePartidaWhereUniqueInput
  }

  /**
   * PmFrentePartida findFirst
   */
  export type PmFrentePartidaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * Filter, which PmFrentePartida to fetch.
     */
    where?: PmFrentePartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentePartidas to fetch.
     */
    orderBy?: PmFrentePartidaOrderByWithRelationInput | PmFrentePartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmFrentePartidas.
     */
    cursor?: PmFrentePartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentePartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentePartidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmFrentePartidas.
     */
    distinct?: PmFrentePartidaScalarFieldEnum | PmFrentePartidaScalarFieldEnum[]
  }

  /**
   * PmFrentePartida findFirstOrThrow
   */
  export type PmFrentePartidaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * Filter, which PmFrentePartida to fetch.
     */
    where?: PmFrentePartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentePartidas to fetch.
     */
    orderBy?: PmFrentePartidaOrderByWithRelationInput | PmFrentePartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmFrentePartidas.
     */
    cursor?: PmFrentePartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentePartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentePartidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmFrentePartidas.
     */
    distinct?: PmFrentePartidaScalarFieldEnum | PmFrentePartidaScalarFieldEnum[]
  }

  /**
   * PmFrentePartida findMany
   */
  export type PmFrentePartidaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * Filter, which PmFrentePartidas to fetch.
     */
    where?: PmFrentePartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmFrentePartidas to fetch.
     */
    orderBy?: PmFrentePartidaOrderByWithRelationInput | PmFrentePartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PmFrentePartidas.
     */
    cursor?: PmFrentePartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmFrentePartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmFrentePartidas.
     */
    skip?: number
    distinct?: PmFrentePartidaScalarFieldEnum | PmFrentePartidaScalarFieldEnum[]
  }

  /**
   * PmFrentePartida create
   */
  export type PmFrentePartidaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * The data needed to create a PmFrentePartida.
     */
    data: XOR<PmFrentePartidaCreateInput, PmFrentePartidaUncheckedCreateInput>
  }

  /**
   * PmFrentePartida createMany
   */
  export type PmFrentePartidaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PmFrentePartidas.
     */
    data: PmFrentePartidaCreateManyInput | PmFrentePartidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PmFrentePartida createManyAndReturn
   */
  export type PmFrentePartidaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * The data used to create many PmFrentePartidas.
     */
    data: PmFrentePartidaCreateManyInput | PmFrentePartidaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmFrentePartida update
   */
  export type PmFrentePartidaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * The data needed to update a PmFrentePartida.
     */
    data: XOR<PmFrentePartidaUpdateInput, PmFrentePartidaUncheckedUpdateInput>
    /**
     * Choose, which PmFrentePartida to update.
     */
    where: PmFrentePartidaWhereUniqueInput
  }

  /**
   * PmFrentePartida updateMany
   */
  export type PmFrentePartidaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PmFrentePartidas.
     */
    data: XOR<PmFrentePartidaUpdateManyMutationInput, PmFrentePartidaUncheckedUpdateManyInput>
    /**
     * Filter which PmFrentePartidas to update
     */
    where?: PmFrentePartidaWhereInput
    /**
     * Limit how many PmFrentePartidas to update.
     */
    limit?: number
  }

  /**
   * PmFrentePartida updateManyAndReturn
   */
  export type PmFrentePartidaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * The data used to update PmFrentePartidas.
     */
    data: XOR<PmFrentePartidaUpdateManyMutationInput, PmFrentePartidaUncheckedUpdateManyInput>
    /**
     * Filter which PmFrentePartidas to update
     */
    where?: PmFrentePartidaWhereInput
    /**
     * Limit how many PmFrentePartidas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmFrentePartida upsert
   */
  export type PmFrentePartidaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * The filter to search for the PmFrentePartida to update in case it exists.
     */
    where: PmFrentePartidaWhereUniqueInput
    /**
     * In case the PmFrentePartida found by the `where` argument doesn't exist, create a new PmFrentePartida with this data.
     */
    create: XOR<PmFrentePartidaCreateInput, PmFrentePartidaUncheckedCreateInput>
    /**
     * In case the PmFrentePartida was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PmFrentePartidaUpdateInput, PmFrentePartidaUncheckedUpdateInput>
  }

  /**
   * PmFrentePartida delete
   */
  export type PmFrentePartidaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
    /**
     * Filter which PmFrentePartida to delete.
     */
    where: PmFrentePartidaWhereUniqueInput
  }

  /**
   * PmFrentePartida deleteMany
   */
  export type PmFrentePartidaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmFrentePartidas to delete
     */
    where?: PmFrentePartidaWhereInput
    /**
     * Limit how many PmFrentePartidas to delete.
     */
    limit?: number
  }

  /**
   * PmFrentePartida.pmProgramacion
   */
  export type PmFrentePartida$pmProgramacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    where?: PmProgramacionWhereInput
    orderBy?: PmProgramacionOrderByWithRelationInput | PmProgramacionOrderByWithRelationInput[]
    cursor?: PmProgramacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmProgramacionScalarFieldEnum | PmProgramacionScalarFieldEnum[]
  }

  /**
   * PmFrentePartida without action
   */
  export type PmFrentePartidaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmFrentePartida
     */
    select?: PmFrentePartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmFrentePartida
     */
    omit?: PmFrentePartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmFrentePartidaInclude<ExtArgs> | null
  }


  /**
   * Model PmProgramacion
   */

  export type AggregatePmProgramacion = {
    _count: PmProgramacionCountAggregateOutputType | null
    _avg: PmProgramacionAvgAggregateOutputType | null
    _sum: PmProgramacionSumAggregateOutputType | null
    _min: PmProgramacionMinAggregateOutputType | null
    _max: PmProgramacionMaxAggregateOutputType | null
  }

  export type PmProgramacionAvgAggregateOutputType = {
    id_PmProgramacion: number | null
    viviendaId: number | null
    cantidad: number | null
    pmFrentePartidaId: number | null
  }

  export type PmProgramacionSumAggregateOutputType = {
    id_PmProgramacion: number | null
    viviendaId: number | null
    cantidad: number | null
    pmFrentePartidaId: number | null
  }

  export type PmProgramacionMinAggregateOutputType = {
    id_PmProgramacion: number | null
    viviendaId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    cantidad: number | null
    pmFrentePartidaId: number | null
  }

  export type PmProgramacionMaxAggregateOutputType = {
    id_PmProgramacion: number | null
    viviendaId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    cantidad: number | null
    pmFrentePartidaId: number | null
  }

  export type PmProgramacionCountAggregateOutputType = {
    id_PmProgramacion: number
    viviendaId: number
    fechaInicio: number
    fechaFin: number
    cantidad: number
    pmFrentePartidaId: number
    _all: number
  }


  export type PmProgramacionAvgAggregateInputType = {
    id_PmProgramacion?: true
    viviendaId?: true
    cantidad?: true
    pmFrentePartidaId?: true
  }

  export type PmProgramacionSumAggregateInputType = {
    id_PmProgramacion?: true
    viviendaId?: true
    cantidad?: true
    pmFrentePartidaId?: true
  }

  export type PmProgramacionMinAggregateInputType = {
    id_PmProgramacion?: true
    viviendaId?: true
    fechaInicio?: true
    fechaFin?: true
    cantidad?: true
    pmFrentePartidaId?: true
  }

  export type PmProgramacionMaxAggregateInputType = {
    id_PmProgramacion?: true
    viviendaId?: true
    fechaInicio?: true
    fechaFin?: true
    cantidad?: true
    pmFrentePartidaId?: true
  }

  export type PmProgramacionCountAggregateInputType = {
    id_PmProgramacion?: true
    viviendaId?: true
    fechaInicio?: true
    fechaFin?: true
    cantidad?: true
    pmFrentePartidaId?: true
    _all?: true
  }

  export type PmProgramacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmProgramacion to aggregate.
     */
    where?: PmProgramacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmProgramacions to fetch.
     */
    orderBy?: PmProgramacionOrderByWithRelationInput | PmProgramacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PmProgramacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmProgramacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmProgramacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PmProgramacions
    **/
    _count?: true | PmProgramacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PmProgramacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PmProgramacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PmProgramacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PmProgramacionMaxAggregateInputType
  }

  export type GetPmProgramacionAggregateType<T extends PmProgramacionAggregateArgs> = {
        [P in keyof T & keyof AggregatePmProgramacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePmProgramacion[P]>
      : GetScalarType<T[P], AggregatePmProgramacion[P]>
  }




  export type PmProgramacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmProgramacionWhereInput
    orderBy?: PmProgramacionOrderByWithAggregationInput | PmProgramacionOrderByWithAggregationInput[]
    by: PmProgramacionScalarFieldEnum[] | PmProgramacionScalarFieldEnum
    having?: PmProgramacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PmProgramacionCountAggregateInputType | true
    _avg?: PmProgramacionAvgAggregateInputType
    _sum?: PmProgramacionSumAggregateInputType
    _min?: PmProgramacionMinAggregateInputType
    _max?: PmProgramacionMaxAggregateInputType
  }

  export type PmProgramacionGroupByOutputType = {
    id_PmProgramacion: number
    viviendaId: number
    fechaInicio: Date
    fechaFin: Date
    cantidad: number
    pmFrentePartidaId: number
    _count: PmProgramacionCountAggregateOutputType | null
    _avg: PmProgramacionAvgAggregateOutputType | null
    _sum: PmProgramacionSumAggregateOutputType | null
    _min: PmProgramacionMinAggregateOutputType | null
    _max: PmProgramacionMaxAggregateOutputType | null
  }

  type GetPmProgramacionGroupByPayload<T extends PmProgramacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PmProgramacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PmProgramacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PmProgramacionGroupByOutputType[P]>
            : GetScalarType<T[P], PmProgramacionGroupByOutputType[P]>
        }
      >
    >


  export type PmProgramacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmProgramacion?: boolean
    viviendaId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cantidad?: boolean
    pmFrentePartidaId?: boolean
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    pmFrentePartida?: boolean | PmFrentePartidaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmProgramacion"]>

  export type PmProgramacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmProgramacion?: boolean
    viviendaId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cantidad?: boolean
    pmFrentePartidaId?: boolean
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    pmFrentePartida?: boolean | PmFrentePartidaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmProgramacion"]>

  export type PmProgramacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmProgramacion?: boolean
    viviendaId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cantidad?: boolean
    pmFrentePartidaId?: boolean
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    pmFrentePartida?: boolean | PmFrentePartidaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmProgramacion"]>

  export type PmProgramacionSelectScalar = {
    id_PmProgramacion?: boolean
    viviendaId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cantidad?: boolean
    pmFrentePartidaId?: boolean
  }

  export type PmProgramacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PmProgramacion" | "viviendaId" | "fechaInicio" | "fechaFin" | "cantidad" | "pmFrentePartidaId", ExtArgs["result"]["pmProgramacion"]>
  export type PmProgramacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    pmFrentePartida?: boolean | PmFrentePartidaDefaultArgs<ExtArgs>
  }
  export type PmProgramacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    pmFrentePartida?: boolean | PmFrentePartidaDefaultArgs<ExtArgs>
  }
  export type PmProgramacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    pmFrentePartida?: boolean | PmFrentePartidaDefaultArgs<ExtArgs>
  }

  export type $PmProgramacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PmProgramacion"
    objects: {
      vivienda: Prisma.$ViviendaPayload<ExtArgs>
      pmFrentePartida: Prisma.$PmFrentePartidaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PmProgramacion: number
      viviendaId: number
      fechaInicio: Date
      fechaFin: Date
      cantidad: number
      pmFrentePartidaId: number
    }, ExtArgs["result"]["pmProgramacion"]>
    composites: {}
  }

  type PmProgramacionGetPayload<S extends boolean | null | undefined | PmProgramacionDefaultArgs> = $Result.GetResult<Prisma.$PmProgramacionPayload, S>

  type PmProgramacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PmProgramacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PmProgramacionCountAggregateInputType | true
    }

  export interface PmProgramacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PmProgramacion'], meta: { name: 'PmProgramacion' } }
    /**
     * Find zero or one PmProgramacion that matches the filter.
     * @param {PmProgramacionFindUniqueArgs} args - Arguments to find a PmProgramacion
     * @example
     * // Get one PmProgramacion
     * const pmProgramacion = await prisma.pmProgramacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PmProgramacionFindUniqueArgs>(args: SelectSubset<T, PmProgramacionFindUniqueArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PmProgramacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PmProgramacionFindUniqueOrThrowArgs} args - Arguments to find a PmProgramacion
     * @example
     * // Get one PmProgramacion
     * const pmProgramacion = await prisma.pmProgramacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PmProgramacionFindUniqueOrThrowArgs>(args: SelectSubset<T, PmProgramacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmProgramacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionFindFirstArgs} args - Arguments to find a PmProgramacion
     * @example
     * // Get one PmProgramacion
     * const pmProgramacion = await prisma.pmProgramacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PmProgramacionFindFirstArgs>(args?: SelectSubset<T, PmProgramacionFindFirstArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmProgramacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionFindFirstOrThrowArgs} args - Arguments to find a PmProgramacion
     * @example
     * // Get one PmProgramacion
     * const pmProgramacion = await prisma.pmProgramacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PmProgramacionFindFirstOrThrowArgs>(args?: SelectSubset<T, PmProgramacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PmProgramacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PmProgramacions
     * const pmProgramacions = await prisma.pmProgramacion.findMany()
     * 
     * // Get first 10 PmProgramacions
     * const pmProgramacions = await prisma.pmProgramacion.findMany({ take: 10 })
     * 
     * // Only select the `id_PmProgramacion`
     * const pmProgramacionWithId_PmProgramacionOnly = await prisma.pmProgramacion.findMany({ select: { id_PmProgramacion: true } })
     * 
     */
    findMany<T extends PmProgramacionFindManyArgs>(args?: SelectSubset<T, PmProgramacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PmProgramacion.
     * @param {PmProgramacionCreateArgs} args - Arguments to create a PmProgramacion.
     * @example
     * // Create one PmProgramacion
     * const PmProgramacion = await prisma.pmProgramacion.create({
     *   data: {
     *     // ... data to create a PmProgramacion
     *   }
     * })
     * 
     */
    create<T extends PmProgramacionCreateArgs>(args: SelectSubset<T, PmProgramacionCreateArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PmProgramacions.
     * @param {PmProgramacionCreateManyArgs} args - Arguments to create many PmProgramacions.
     * @example
     * // Create many PmProgramacions
     * const pmProgramacion = await prisma.pmProgramacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PmProgramacionCreateManyArgs>(args?: SelectSubset<T, PmProgramacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PmProgramacions and returns the data saved in the database.
     * @param {PmProgramacionCreateManyAndReturnArgs} args - Arguments to create many PmProgramacions.
     * @example
     * // Create many PmProgramacions
     * const pmProgramacion = await prisma.pmProgramacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PmProgramacions and only return the `id_PmProgramacion`
     * const pmProgramacionWithId_PmProgramacionOnly = await prisma.pmProgramacion.createManyAndReturn({
     *   select: { id_PmProgramacion: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PmProgramacionCreateManyAndReturnArgs>(args?: SelectSubset<T, PmProgramacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PmProgramacion.
     * @param {PmProgramacionDeleteArgs} args - Arguments to delete one PmProgramacion.
     * @example
     * // Delete one PmProgramacion
     * const PmProgramacion = await prisma.pmProgramacion.delete({
     *   where: {
     *     // ... filter to delete one PmProgramacion
     *   }
     * })
     * 
     */
    delete<T extends PmProgramacionDeleteArgs>(args: SelectSubset<T, PmProgramacionDeleteArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PmProgramacion.
     * @param {PmProgramacionUpdateArgs} args - Arguments to update one PmProgramacion.
     * @example
     * // Update one PmProgramacion
     * const pmProgramacion = await prisma.pmProgramacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PmProgramacionUpdateArgs>(args: SelectSubset<T, PmProgramacionUpdateArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PmProgramacions.
     * @param {PmProgramacionDeleteManyArgs} args - Arguments to filter PmProgramacions to delete.
     * @example
     * // Delete a few PmProgramacions
     * const { count } = await prisma.pmProgramacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PmProgramacionDeleteManyArgs>(args?: SelectSubset<T, PmProgramacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmProgramacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PmProgramacions
     * const pmProgramacion = await prisma.pmProgramacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PmProgramacionUpdateManyArgs>(args: SelectSubset<T, PmProgramacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmProgramacions and returns the data updated in the database.
     * @param {PmProgramacionUpdateManyAndReturnArgs} args - Arguments to update many PmProgramacions.
     * @example
     * // Update many PmProgramacions
     * const pmProgramacion = await prisma.pmProgramacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PmProgramacions and only return the `id_PmProgramacion`
     * const pmProgramacionWithId_PmProgramacionOnly = await prisma.pmProgramacion.updateManyAndReturn({
     *   select: { id_PmProgramacion: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PmProgramacionUpdateManyAndReturnArgs>(args: SelectSubset<T, PmProgramacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PmProgramacion.
     * @param {PmProgramacionUpsertArgs} args - Arguments to update or create a PmProgramacion.
     * @example
     * // Update or create a PmProgramacion
     * const pmProgramacion = await prisma.pmProgramacion.upsert({
     *   create: {
     *     // ... data to create a PmProgramacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PmProgramacion we want to update
     *   }
     * })
     */
    upsert<T extends PmProgramacionUpsertArgs>(args: SelectSubset<T, PmProgramacionUpsertArgs<ExtArgs>>): Prisma__PmProgramacionClient<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PmProgramacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionCountArgs} args - Arguments to filter PmProgramacions to count.
     * @example
     * // Count the number of PmProgramacions
     * const count = await prisma.pmProgramacion.count({
     *   where: {
     *     // ... the filter for the PmProgramacions we want to count
     *   }
     * })
    **/
    count<T extends PmProgramacionCountArgs>(
      args?: Subset<T, PmProgramacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PmProgramacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PmProgramacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PmProgramacionAggregateArgs>(args: Subset<T, PmProgramacionAggregateArgs>): Prisma.PrismaPromise<GetPmProgramacionAggregateType<T>>

    /**
     * Group by PmProgramacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmProgramacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PmProgramacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PmProgramacionGroupByArgs['orderBy'] }
        : { orderBy?: PmProgramacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PmProgramacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPmProgramacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PmProgramacion model
   */
  readonly fields: PmProgramacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PmProgramacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PmProgramacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vivienda<T extends ViviendaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViviendaDefaultArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pmFrentePartida<T extends PmFrentePartidaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PmFrentePartidaDefaultArgs<ExtArgs>>): Prisma__PmFrentePartidaClient<$Result.GetResult<Prisma.$PmFrentePartidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PmProgramacion model
   */
  interface PmProgramacionFieldRefs {
    readonly id_PmProgramacion: FieldRef<"PmProgramacion", 'Int'>
    readonly viviendaId: FieldRef<"PmProgramacion", 'Int'>
    readonly fechaInicio: FieldRef<"PmProgramacion", 'DateTime'>
    readonly fechaFin: FieldRef<"PmProgramacion", 'DateTime'>
    readonly cantidad: FieldRef<"PmProgramacion", 'Int'>
    readonly pmFrentePartidaId: FieldRef<"PmProgramacion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PmProgramacion findUnique
   */
  export type PmProgramacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * Filter, which PmProgramacion to fetch.
     */
    where: PmProgramacionWhereUniqueInput
  }

  /**
   * PmProgramacion findUniqueOrThrow
   */
  export type PmProgramacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * Filter, which PmProgramacion to fetch.
     */
    where: PmProgramacionWhereUniqueInput
  }

  /**
   * PmProgramacion findFirst
   */
  export type PmProgramacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * Filter, which PmProgramacion to fetch.
     */
    where?: PmProgramacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmProgramacions to fetch.
     */
    orderBy?: PmProgramacionOrderByWithRelationInput | PmProgramacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmProgramacions.
     */
    cursor?: PmProgramacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmProgramacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmProgramacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmProgramacions.
     */
    distinct?: PmProgramacionScalarFieldEnum | PmProgramacionScalarFieldEnum[]
  }

  /**
   * PmProgramacion findFirstOrThrow
   */
  export type PmProgramacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * Filter, which PmProgramacion to fetch.
     */
    where?: PmProgramacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmProgramacions to fetch.
     */
    orderBy?: PmProgramacionOrderByWithRelationInput | PmProgramacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmProgramacions.
     */
    cursor?: PmProgramacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmProgramacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmProgramacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmProgramacions.
     */
    distinct?: PmProgramacionScalarFieldEnum | PmProgramacionScalarFieldEnum[]
  }

  /**
   * PmProgramacion findMany
   */
  export type PmProgramacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * Filter, which PmProgramacions to fetch.
     */
    where?: PmProgramacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmProgramacions to fetch.
     */
    orderBy?: PmProgramacionOrderByWithRelationInput | PmProgramacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PmProgramacions.
     */
    cursor?: PmProgramacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmProgramacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmProgramacions.
     */
    skip?: number
    distinct?: PmProgramacionScalarFieldEnum | PmProgramacionScalarFieldEnum[]
  }

  /**
   * PmProgramacion create
   */
  export type PmProgramacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * The data needed to create a PmProgramacion.
     */
    data: XOR<PmProgramacionCreateInput, PmProgramacionUncheckedCreateInput>
  }

  /**
   * PmProgramacion createMany
   */
  export type PmProgramacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PmProgramacions.
     */
    data: PmProgramacionCreateManyInput | PmProgramacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PmProgramacion createManyAndReturn
   */
  export type PmProgramacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * The data used to create many PmProgramacions.
     */
    data: PmProgramacionCreateManyInput | PmProgramacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmProgramacion update
   */
  export type PmProgramacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * The data needed to update a PmProgramacion.
     */
    data: XOR<PmProgramacionUpdateInput, PmProgramacionUncheckedUpdateInput>
    /**
     * Choose, which PmProgramacion to update.
     */
    where: PmProgramacionWhereUniqueInput
  }

  /**
   * PmProgramacion updateMany
   */
  export type PmProgramacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PmProgramacions.
     */
    data: XOR<PmProgramacionUpdateManyMutationInput, PmProgramacionUncheckedUpdateManyInput>
    /**
     * Filter which PmProgramacions to update
     */
    where?: PmProgramacionWhereInput
    /**
     * Limit how many PmProgramacions to update.
     */
    limit?: number
  }

  /**
   * PmProgramacion updateManyAndReturn
   */
  export type PmProgramacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * The data used to update PmProgramacions.
     */
    data: XOR<PmProgramacionUpdateManyMutationInput, PmProgramacionUncheckedUpdateManyInput>
    /**
     * Filter which PmProgramacions to update
     */
    where?: PmProgramacionWhereInput
    /**
     * Limit how many PmProgramacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmProgramacion upsert
   */
  export type PmProgramacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * The filter to search for the PmProgramacion to update in case it exists.
     */
    where: PmProgramacionWhereUniqueInput
    /**
     * In case the PmProgramacion found by the `where` argument doesn't exist, create a new PmProgramacion with this data.
     */
    create: XOR<PmProgramacionCreateInput, PmProgramacionUncheckedCreateInput>
    /**
     * In case the PmProgramacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PmProgramacionUpdateInput, PmProgramacionUncheckedUpdateInput>
  }

  /**
   * PmProgramacion delete
   */
  export type PmProgramacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    /**
     * Filter which PmProgramacion to delete.
     */
    where: PmProgramacionWhereUniqueInput
  }

  /**
   * PmProgramacion deleteMany
   */
  export type PmProgramacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmProgramacions to delete
     */
    where?: PmProgramacionWhereInput
    /**
     * Limit how many PmProgramacions to delete.
     */
    limit?: number
  }

  /**
   * PmProgramacion without action
   */
  export type PmProgramacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
  }


  /**
   * Model EquipoCargo
   */

  export type AggregateEquipoCargo = {
    _count: EquipoCargoCountAggregateOutputType | null
    _avg: EquipoCargoAvgAggregateOutputType | null
    _sum: EquipoCargoSumAggregateOutputType | null
    _min: EquipoCargoMinAggregateOutputType | null
    _max: EquipoCargoMaxAggregateOutputType | null
  }

  export type EquipoCargoAvgAggregateOutputType = {
    id_EquipoCargo: number | null
  }

  export type EquipoCargoSumAggregateOutputType = {
    id_EquipoCargo: number | null
  }

  export type EquipoCargoMinAggregateOutputType = {
    id_EquipoCargo: number | null
    nombre: string | null
    esActivo: boolean | null
  }

  export type EquipoCargoMaxAggregateOutputType = {
    id_EquipoCargo: number | null
    nombre: string | null
    esActivo: boolean | null
  }

  export type EquipoCargoCountAggregateOutputType = {
    id_EquipoCargo: number
    nombre: number
    esActivo: number
    _all: number
  }


  export type EquipoCargoAvgAggregateInputType = {
    id_EquipoCargo?: true
  }

  export type EquipoCargoSumAggregateInputType = {
    id_EquipoCargo?: true
  }

  export type EquipoCargoMinAggregateInputType = {
    id_EquipoCargo?: true
    nombre?: true
    esActivo?: true
  }

  export type EquipoCargoMaxAggregateInputType = {
    id_EquipoCargo?: true
    nombre?: true
    esActivo?: true
  }

  export type EquipoCargoCountAggregateInputType = {
    id_EquipoCargo?: true
    nombre?: true
    esActivo?: true
    _all?: true
  }

  export type EquipoCargoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipoCargo to aggregate.
     */
    where?: EquipoCargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoCargos to fetch.
     */
    orderBy?: EquipoCargoOrderByWithRelationInput | EquipoCargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipoCargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoCargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoCargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipoCargos
    **/
    _count?: true | EquipoCargoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipoCargoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipoCargoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipoCargoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipoCargoMaxAggregateInputType
  }

  export type GetEquipoCargoAggregateType<T extends EquipoCargoAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipoCargo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipoCargo[P]>
      : GetScalarType<T[P], AggregateEquipoCargo[P]>
  }




  export type EquipoCargoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipoCargoWhereInput
    orderBy?: EquipoCargoOrderByWithAggregationInput | EquipoCargoOrderByWithAggregationInput[]
    by: EquipoCargoScalarFieldEnum[] | EquipoCargoScalarFieldEnum
    having?: EquipoCargoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipoCargoCountAggregateInputType | true
    _avg?: EquipoCargoAvgAggregateInputType
    _sum?: EquipoCargoSumAggregateInputType
    _min?: EquipoCargoMinAggregateInputType
    _max?: EquipoCargoMaxAggregateInputType
  }

  export type EquipoCargoGroupByOutputType = {
    id_EquipoCargo: number
    nombre: string
    esActivo: boolean
    _count: EquipoCargoCountAggregateOutputType | null
    _avg: EquipoCargoAvgAggregateOutputType | null
    _sum: EquipoCargoSumAggregateOutputType | null
    _min: EquipoCargoMinAggregateOutputType | null
    _max: EquipoCargoMaxAggregateOutputType | null
  }

  type GetEquipoCargoGroupByPayload<T extends EquipoCargoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipoCargoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipoCargoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipoCargoGroupByOutputType[P]>
            : GetScalarType<T[P], EquipoCargoGroupByOutputType[P]>
        }
      >
    >


  export type EquipoCargoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_EquipoCargo?: boolean
    nombre?: boolean
    esActivo?: boolean
    pmEquipo?: boolean | EquipoCargo$pmEquipoArgs<ExtArgs>
    _count?: boolean | EquipoCargoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipoCargo"]>

  export type EquipoCargoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_EquipoCargo?: boolean
    nombre?: boolean
    esActivo?: boolean
  }, ExtArgs["result"]["equipoCargo"]>

  export type EquipoCargoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_EquipoCargo?: boolean
    nombre?: boolean
    esActivo?: boolean
  }, ExtArgs["result"]["equipoCargo"]>

  export type EquipoCargoSelectScalar = {
    id_EquipoCargo?: boolean
    nombre?: boolean
    esActivo?: boolean
  }

  export type EquipoCargoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_EquipoCargo" | "nombre" | "esActivo", ExtArgs["result"]["equipoCargo"]>
  export type EquipoCargoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmEquipo?: boolean | EquipoCargo$pmEquipoArgs<ExtArgs>
    _count?: boolean | EquipoCargoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipoCargoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EquipoCargoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipoCargoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipoCargo"
    objects: {
      pmEquipo: Prisma.$PmEquipoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_EquipoCargo: number
      nombre: string
      esActivo: boolean
    }, ExtArgs["result"]["equipoCargo"]>
    composites: {}
  }

  type EquipoCargoGetPayload<S extends boolean | null | undefined | EquipoCargoDefaultArgs> = $Result.GetResult<Prisma.$EquipoCargoPayload, S>

  type EquipoCargoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipoCargoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipoCargoCountAggregateInputType | true
    }

  export interface EquipoCargoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipoCargo'], meta: { name: 'EquipoCargo' } }
    /**
     * Find zero or one EquipoCargo that matches the filter.
     * @param {EquipoCargoFindUniqueArgs} args - Arguments to find a EquipoCargo
     * @example
     * // Get one EquipoCargo
     * const equipoCargo = await prisma.equipoCargo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipoCargoFindUniqueArgs>(args: SelectSubset<T, EquipoCargoFindUniqueArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipoCargo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipoCargoFindUniqueOrThrowArgs} args - Arguments to find a EquipoCargo
     * @example
     * // Get one EquipoCargo
     * const equipoCargo = await prisma.equipoCargo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipoCargoFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipoCargoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipoCargo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoFindFirstArgs} args - Arguments to find a EquipoCargo
     * @example
     * // Get one EquipoCargo
     * const equipoCargo = await prisma.equipoCargo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipoCargoFindFirstArgs>(args?: SelectSubset<T, EquipoCargoFindFirstArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipoCargo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoFindFirstOrThrowArgs} args - Arguments to find a EquipoCargo
     * @example
     * // Get one EquipoCargo
     * const equipoCargo = await prisma.equipoCargo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipoCargoFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipoCargoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipoCargos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipoCargos
     * const equipoCargos = await prisma.equipoCargo.findMany()
     * 
     * // Get first 10 EquipoCargos
     * const equipoCargos = await prisma.equipoCargo.findMany({ take: 10 })
     * 
     * // Only select the `id_EquipoCargo`
     * const equipoCargoWithId_EquipoCargoOnly = await prisma.equipoCargo.findMany({ select: { id_EquipoCargo: true } })
     * 
     */
    findMany<T extends EquipoCargoFindManyArgs>(args?: SelectSubset<T, EquipoCargoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipoCargo.
     * @param {EquipoCargoCreateArgs} args - Arguments to create a EquipoCargo.
     * @example
     * // Create one EquipoCargo
     * const EquipoCargo = await prisma.equipoCargo.create({
     *   data: {
     *     // ... data to create a EquipoCargo
     *   }
     * })
     * 
     */
    create<T extends EquipoCargoCreateArgs>(args: SelectSubset<T, EquipoCargoCreateArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipoCargos.
     * @param {EquipoCargoCreateManyArgs} args - Arguments to create many EquipoCargos.
     * @example
     * // Create many EquipoCargos
     * const equipoCargo = await prisma.equipoCargo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipoCargoCreateManyArgs>(args?: SelectSubset<T, EquipoCargoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipoCargos and returns the data saved in the database.
     * @param {EquipoCargoCreateManyAndReturnArgs} args - Arguments to create many EquipoCargos.
     * @example
     * // Create many EquipoCargos
     * const equipoCargo = await prisma.equipoCargo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipoCargos and only return the `id_EquipoCargo`
     * const equipoCargoWithId_EquipoCargoOnly = await prisma.equipoCargo.createManyAndReturn({
     *   select: { id_EquipoCargo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipoCargoCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipoCargoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipoCargo.
     * @param {EquipoCargoDeleteArgs} args - Arguments to delete one EquipoCargo.
     * @example
     * // Delete one EquipoCargo
     * const EquipoCargo = await prisma.equipoCargo.delete({
     *   where: {
     *     // ... filter to delete one EquipoCargo
     *   }
     * })
     * 
     */
    delete<T extends EquipoCargoDeleteArgs>(args: SelectSubset<T, EquipoCargoDeleteArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipoCargo.
     * @param {EquipoCargoUpdateArgs} args - Arguments to update one EquipoCargo.
     * @example
     * // Update one EquipoCargo
     * const equipoCargo = await prisma.equipoCargo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipoCargoUpdateArgs>(args: SelectSubset<T, EquipoCargoUpdateArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipoCargos.
     * @param {EquipoCargoDeleteManyArgs} args - Arguments to filter EquipoCargos to delete.
     * @example
     * // Delete a few EquipoCargos
     * const { count } = await prisma.equipoCargo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipoCargoDeleteManyArgs>(args?: SelectSubset<T, EquipoCargoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipoCargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipoCargos
     * const equipoCargo = await prisma.equipoCargo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipoCargoUpdateManyArgs>(args: SelectSubset<T, EquipoCargoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipoCargos and returns the data updated in the database.
     * @param {EquipoCargoUpdateManyAndReturnArgs} args - Arguments to update many EquipoCargos.
     * @example
     * // Update many EquipoCargos
     * const equipoCargo = await prisma.equipoCargo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipoCargos and only return the `id_EquipoCargo`
     * const equipoCargoWithId_EquipoCargoOnly = await prisma.equipoCargo.updateManyAndReturn({
     *   select: { id_EquipoCargo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipoCargoUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipoCargoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipoCargo.
     * @param {EquipoCargoUpsertArgs} args - Arguments to update or create a EquipoCargo.
     * @example
     * // Update or create a EquipoCargo
     * const equipoCargo = await prisma.equipoCargo.upsert({
     *   create: {
     *     // ... data to create a EquipoCargo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipoCargo we want to update
     *   }
     * })
     */
    upsert<T extends EquipoCargoUpsertArgs>(args: SelectSubset<T, EquipoCargoUpsertArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipoCargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoCountArgs} args - Arguments to filter EquipoCargos to count.
     * @example
     * // Count the number of EquipoCargos
     * const count = await prisma.equipoCargo.count({
     *   where: {
     *     // ... the filter for the EquipoCargos we want to count
     *   }
     * })
    **/
    count<T extends EquipoCargoCountArgs>(
      args?: Subset<T, EquipoCargoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipoCargoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipoCargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipoCargoAggregateArgs>(args: Subset<T, EquipoCargoAggregateArgs>): Prisma.PrismaPromise<GetEquipoCargoAggregateType<T>>

    /**
     * Group by EquipoCargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoCargoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipoCargoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipoCargoGroupByArgs['orderBy'] }
        : { orderBy?: EquipoCargoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipoCargoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipoCargoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipoCargo model
   */
  readonly fields: EquipoCargoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipoCargo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipoCargoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pmEquipo<T extends EquipoCargo$pmEquipoArgs<ExtArgs> = {}>(args?: Subset<T, EquipoCargo$pmEquipoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipoCargo model
   */
  interface EquipoCargoFieldRefs {
    readonly id_EquipoCargo: FieldRef<"EquipoCargo", 'Int'>
    readonly nombre: FieldRef<"EquipoCargo", 'String'>
    readonly esActivo: FieldRef<"EquipoCargo", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EquipoCargo findUnique
   */
  export type EquipoCargoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoCargo to fetch.
     */
    where: EquipoCargoWhereUniqueInput
  }

  /**
   * EquipoCargo findUniqueOrThrow
   */
  export type EquipoCargoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoCargo to fetch.
     */
    where: EquipoCargoWhereUniqueInput
  }

  /**
   * EquipoCargo findFirst
   */
  export type EquipoCargoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoCargo to fetch.
     */
    where?: EquipoCargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoCargos to fetch.
     */
    orderBy?: EquipoCargoOrderByWithRelationInput | EquipoCargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipoCargos.
     */
    cursor?: EquipoCargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoCargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoCargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipoCargos.
     */
    distinct?: EquipoCargoScalarFieldEnum | EquipoCargoScalarFieldEnum[]
  }

  /**
   * EquipoCargo findFirstOrThrow
   */
  export type EquipoCargoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoCargo to fetch.
     */
    where?: EquipoCargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoCargos to fetch.
     */
    orderBy?: EquipoCargoOrderByWithRelationInput | EquipoCargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipoCargos.
     */
    cursor?: EquipoCargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoCargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoCargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipoCargos.
     */
    distinct?: EquipoCargoScalarFieldEnum | EquipoCargoScalarFieldEnum[]
  }

  /**
   * EquipoCargo findMany
   */
  export type EquipoCargoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoCargos to fetch.
     */
    where?: EquipoCargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoCargos to fetch.
     */
    orderBy?: EquipoCargoOrderByWithRelationInput | EquipoCargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipoCargos.
     */
    cursor?: EquipoCargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoCargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoCargos.
     */
    skip?: number
    distinct?: EquipoCargoScalarFieldEnum | EquipoCargoScalarFieldEnum[]
  }

  /**
   * EquipoCargo create
   */
  export type EquipoCargoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipoCargo.
     */
    data: XOR<EquipoCargoCreateInput, EquipoCargoUncheckedCreateInput>
  }

  /**
   * EquipoCargo createMany
   */
  export type EquipoCargoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipoCargos.
     */
    data: EquipoCargoCreateManyInput | EquipoCargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipoCargo createManyAndReturn
   */
  export type EquipoCargoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * The data used to create many EquipoCargos.
     */
    data: EquipoCargoCreateManyInput | EquipoCargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipoCargo update
   */
  export type EquipoCargoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipoCargo.
     */
    data: XOR<EquipoCargoUpdateInput, EquipoCargoUncheckedUpdateInput>
    /**
     * Choose, which EquipoCargo to update.
     */
    where: EquipoCargoWhereUniqueInput
  }

  /**
   * EquipoCargo updateMany
   */
  export type EquipoCargoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipoCargos.
     */
    data: XOR<EquipoCargoUpdateManyMutationInput, EquipoCargoUncheckedUpdateManyInput>
    /**
     * Filter which EquipoCargos to update
     */
    where?: EquipoCargoWhereInput
    /**
     * Limit how many EquipoCargos to update.
     */
    limit?: number
  }

  /**
   * EquipoCargo updateManyAndReturn
   */
  export type EquipoCargoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * The data used to update EquipoCargos.
     */
    data: XOR<EquipoCargoUpdateManyMutationInput, EquipoCargoUncheckedUpdateManyInput>
    /**
     * Filter which EquipoCargos to update
     */
    where?: EquipoCargoWhereInput
    /**
     * Limit how many EquipoCargos to update.
     */
    limit?: number
  }

  /**
   * EquipoCargo upsert
   */
  export type EquipoCargoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipoCargo to update in case it exists.
     */
    where: EquipoCargoWhereUniqueInput
    /**
     * In case the EquipoCargo found by the `where` argument doesn't exist, create a new EquipoCargo with this data.
     */
    create: XOR<EquipoCargoCreateInput, EquipoCargoUncheckedCreateInput>
    /**
     * In case the EquipoCargo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipoCargoUpdateInput, EquipoCargoUncheckedUpdateInput>
  }

  /**
   * EquipoCargo delete
   */
  export type EquipoCargoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
    /**
     * Filter which EquipoCargo to delete.
     */
    where: EquipoCargoWhereUniqueInput
  }

  /**
   * EquipoCargo deleteMany
   */
  export type EquipoCargoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipoCargos to delete
     */
    where?: EquipoCargoWhereInput
    /**
     * Limit how many EquipoCargos to delete.
     */
    limit?: number
  }

  /**
   * EquipoCargo.pmEquipo
   */
  export type EquipoCargo$pmEquipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    where?: PmEquipoWhereInput
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    cursor?: PmEquipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmEquipoScalarFieldEnum | PmEquipoScalarFieldEnum[]
  }

  /**
   * EquipoCargo without action
   */
  export type EquipoCargoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoCargo
     */
    select?: EquipoCargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoCargo
     */
    omit?: EquipoCargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoCargoInclude<ExtArgs> | null
  }


  /**
   * Model EquipoTrabajo
   */

  export type AggregateEquipoTrabajo = {
    _count: EquipoTrabajoCountAggregateOutputType | null
    _avg: EquipoTrabajoAvgAggregateOutputType | null
    _sum: EquipoTrabajoSumAggregateOutputType | null
    _min: EquipoTrabajoMinAggregateOutputType | null
    _max: EquipoTrabajoMaxAggregateOutputType | null
  }

  export type EquipoTrabajoAvgAggregateOutputType = {
    id_EquipoTrabajo: number | null
    planMaestroId: number | null
  }

  export type EquipoTrabajoSumAggregateOutputType = {
    id_EquipoTrabajo: number | null
    planMaestroId: number | null
  }

  export type EquipoTrabajoMinAggregateOutputType = {
    id_EquipoTrabajo: number | null
    planMaestroId: number | null
  }

  export type EquipoTrabajoMaxAggregateOutputType = {
    id_EquipoTrabajo: number | null
    planMaestroId: number | null
  }

  export type EquipoTrabajoCountAggregateOutputType = {
    id_EquipoTrabajo: number
    planMaestroId: number
    _all: number
  }


  export type EquipoTrabajoAvgAggregateInputType = {
    id_EquipoTrabajo?: true
    planMaestroId?: true
  }

  export type EquipoTrabajoSumAggregateInputType = {
    id_EquipoTrabajo?: true
    planMaestroId?: true
  }

  export type EquipoTrabajoMinAggregateInputType = {
    id_EquipoTrabajo?: true
    planMaestroId?: true
  }

  export type EquipoTrabajoMaxAggregateInputType = {
    id_EquipoTrabajo?: true
    planMaestroId?: true
  }

  export type EquipoTrabajoCountAggregateInputType = {
    id_EquipoTrabajo?: true
    planMaestroId?: true
    _all?: true
  }

  export type EquipoTrabajoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipoTrabajo to aggregate.
     */
    where?: EquipoTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoTrabajos to fetch.
     */
    orderBy?: EquipoTrabajoOrderByWithRelationInput | EquipoTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipoTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoTrabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipoTrabajos
    **/
    _count?: true | EquipoTrabajoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipoTrabajoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipoTrabajoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipoTrabajoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipoTrabajoMaxAggregateInputType
  }

  export type GetEquipoTrabajoAggregateType<T extends EquipoTrabajoAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipoTrabajo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipoTrabajo[P]>
      : GetScalarType<T[P], AggregateEquipoTrabajo[P]>
  }




  export type EquipoTrabajoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipoTrabajoWhereInput
    orderBy?: EquipoTrabajoOrderByWithAggregationInput | EquipoTrabajoOrderByWithAggregationInput[]
    by: EquipoTrabajoScalarFieldEnum[] | EquipoTrabajoScalarFieldEnum
    having?: EquipoTrabajoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipoTrabajoCountAggregateInputType | true
    _avg?: EquipoTrabajoAvgAggregateInputType
    _sum?: EquipoTrabajoSumAggregateInputType
    _min?: EquipoTrabajoMinAggregateInputType
    _max?: EquipoTrabajoMaxAggregateInputType
  }

  export type EquipoTrabajoGroupByOutputType = {
    id_EquipoTrabajo: number
    planMaestroId: number
    _count: EquipoTrabajoCountAggregateOutputType | null
    _avg: EquipoTrabajoAvgAggregateOutputType | null
    _sum: EquipoTrabajoSumAggregateOutputType | null
    _min: EquipoTrabajoMinAggregateOutputType | null
    _max: EquipoTrabajoMaxAggregateOutputType | null
  }

  type GetEquipoTrabajoGroupByPayload<T extends EquipoTrabajoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipoTrabajoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipoTrabajoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipoTrabajoGroupByOutputType[P]>
            : GetScalarType<T[P], EquipoTrabajoGroupByOutputType[P]>
        }
      >
    >


  export type EquipoTrabajoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_EquipoTrabajo?: boolean
    planMaestroId?: boolean
    PlanMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
    pmEquipo?: boolean | EquipoTrabajo$pmEquipoArgs<ExtArgs>
    _count?: boolean | EquipoTrabajoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipoTrabajo"]>

  export type EquipoTrabajoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_EquipoTrabajo?: boolean
    planMaestroId?: boolean
    PlanMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipoTrabajo"]>

  export type EquipoTrabajoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_EquipoTrabajo?: boolean
    planMaestroId?: boolean
    PlanMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipoTrabajo"]>

  export type EquipoTrabajoSelectScalar = {
    id_EquipoTrabajo?: boolean
    planMaestroId?: boolean
  }

  export type EquipoTrabajoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_EquipoTrabajo" | "planMaestroId", ExtArgs["result"]["equipoTrabajo"]>
  export type EquipoTrabajoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PlanMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
    pmEquipo?: boolean | EquipoTrabajo$pmEquipoArgs<ExtArgs>
    _count?: boolean | EquipoTrabajoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipoTrabajoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PlanMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }
  export type EquipoTrabajoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PlanMaestro?: boolean | PlanMaestroDefaultArgs<ExtArgs>
  }

  export type $EquipoTrabajoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipoTrabajo"
    objects: {
      PlanMaestro: Prisma.$PlanMaestroPayload<ExtArgs>
      pmEquipo: Prisma.$PmEquipoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_EquipoTrabajo: number
      planMaestroId: number
    }, ExtArgs["result"]["equipoTrabajo"]>
    composites: {}
  }

  type EquipoTrabajoGetPayload<S extends boolean | null | undefined | EquipoTrabajoDefaultArgs> = $Result.GetResult<Prisma.$EquipoTrabajoPayload, S>

  type EquipoTrabajoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipoTrabajoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipoTrabajoCountAggregateInputType | true
    }

  export interface EquipoTrabajoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipoTrabajo'], meta: { name: 'EquipoTrabajo' } }
    /**
     * Find zero or one EquipoTrabajo that matches the filter.
     * @param {EquipoTrabajoFindUniqueArgs} args - Arguments to find a EquipoTrabajo
     * @example
     * // Get one EquipoTrabajo
     * const equipoTrabajo = await prisma.equipoTrabajo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipoTrabajoFindUniqueArgs>(args: SelectSubset<T, EquipoTrabajoFindUniqueArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipoTrabajo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipoTrabajoFindUniqueOrThrowArgs} args - Arguments to find a EquipoTrabajo
     * @example
     * // Get one EquipoTrabajo
     * const equipoTrabajo = await prisma.equipoTrabajo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipoTrabajoFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipoTrabajoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipoTrabajo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoFindFirstArgs} args - Arguments to find a EquipoTrabajo
     * @example
     * // Get one EquipoTrabajo
     * const equipoTrabajo = await prisma.equipoTrabajo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipoTrabajoFindFirstArgs>(args?: SelectSubset<T, EquipoTrabajoFindFirstArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipoTrabajo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoFindFirstOrThrowArgs} args - Arguments to find a EquipoTrabajo
     * @example
     * // Get one EquipoTrabajo
     * const equipoTrabajo = await prisma.equipoTrabajo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipoTrabajoFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipoTrabajoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipoTrabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipoTrabajos
     * const equipoTrabajos = await prisma.equipoTrabajo.findMany()
     * 
     * // Get first 10 EquipoTrabajos
     * const equipoTrabajos = await prisma.equipoTrabajo.findMany({ take: 10 })
     * 
     * // Only select the `id_EquipoTrabajo`
     * const equipoTrabajoWithId_EquipoTrabajoOnly = await prisma.equipoTrabajo.findMany({ select: { id_EquipoTrabajo: true } })
     * 
     */
    findMany<T extends EquipoTrabajoFindManyArgs>(args?: SelectSubset<T, EquipoTrabajoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipoTrabajo.
     * @param {EquipoTrabajoCreateArgs} args - Arguments to create a EquipoTrabajo.
     * @example
     * // Create one EquipoTrabajo
     * const EquipoTrabajo = await prisma.equipoTrabajo.create({
     *   data: {
     *     // ... data to create a EquipoTrabajo
     *   }
     * })
     * 
     */
    create<T extends EquipoTrabajoCreateArgs>(args: SelectSubset<T, EquipoTrabajoCreateArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipoTrabajos.
     * @param {EquipoTrabajoCreateManyArgs} args - Arguments to create many EquipoTrabajos.
     * @example
     * // Create many EquipoTrabajos
     * const equipoTrabajo = await prisma.equipoTrabajo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipoTrabajoCreateManyArgs>(args?: SelectSubset<T, EquipoTrabajoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipoTrabajos and returns the data saved in the database.
     * @param {EquipoTrabajoCreateManyAndReturnArgs} args - Arguments to create many EquipoTrabajos.
     * @example
     * // Create many EquipoTrabajos
     * const equipoTrabajo = await prisma.equipoTrabajo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipoTrabajos and only return the `id_EquipoTrabajo`
     * const equipoTrabajoWithId_EquipoTrabajoOnly = await prisma.equipoTrabajo.createManyAndReturn({
     *   select: { id_EquipoTrabajo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipoTrabajoCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipoTrabajoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipoTrabajo.
     * @param {EquipoTrabajoDeleteArgs} args - Arguments to delete one EquipoTrabajo.
     * @example
     * // Delete one EquipoTrabajo
     * const EquipoTrabajo = await prisma.equipoTrabajo.delete({
     *   where: {
     *     // ... filter to delete one EquipoTrabajo
     *   }
     * })
     * 
     */
    delete<T extends EquipoTrabajoDeleteArgs>(args: SelectSubset<T, EquipoTrabajoDeleteArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipoTrabajo.
     * @param {EquipoTrabajoUpdateArgs} args - Arguments to update one EquipoTrabajo.
     * @example
     * // Update one EquipoTrabajo
     * const equipoTrabajo = await prisma.equipoTrabajo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipoTrabajoUpdateArgs>(args: SelectSubset<T, EquipoTrabajoUpdateArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipoTrabajos.
     * @param {EquipoTrabajoDeleteManyArgs} args - Arguments to filter EquipoTrabajos to delete.
     * @example
     * // Delete a few EquipoTrabajos
     * const { count } = await prisma.equipoTrabajo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipoTrabajoDeleteManyArgs>(args?: SelectSubset<T, EquipoTrabajoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipoTrabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipoTrabajos
     * const equipoTrabajo = await prisma.equipoTrabajo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipoTrabajoUpdateManyArgs>(args: SelectSubset<T, EquipoTrabajoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipoTrabajos and returns the data updated in the database.
     * @param {EquipoTrabajoUpdateManyAndReturnArgs} args - Arguments to update many EquipoTrabajos.
     * @example
     * // Update many EquipoTrabajos
     * const equipoTrabajo = await prisma.equipoTrabajo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipoTrabajos and only return the `id_EquipoTrabajo`
     * const equipoTrabajoWithId_EquipoTrabajoOnly = await prisma.equipoTrabajo.updateManyAndReturn({
     *   select: { id_EquipoTrabajo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipoTrabajoUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipoTrabajoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipoTrabajo.
     * @param {EquipoTrabajoUpsertArgs} args - Arguments to update or create a EquipoTrabajo.
     * @example
     * // Update or create a EquipoTrabajo
     * const equipoTrabajo = await prisma.equipoTrabajo.upsert({
     *   create: {
     *     // ... data to create a EquipoTrabajo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipoTrabajo we want to update
     *   }
     * })
     */
    upsert<T extends EquipoTrabajoUpsertArgs>(args: SelectSubset<T, EquipoTrabajoUpsertArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipoTrabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoCountArgs} args - Arguments to filter EquipoTrabajos to count.
     * @example
     * // Count the number of EquipoTrabajos
     * const count = await prisma.equipoTrabajo.count({
     *   where: {
     *     // ... the filter for the EquipoTrabajos we want to count
     *   }
     * })
    **/
    count<T extends EquipoTrabajoCountArgs>(
      args?: Subset<T, EquipoTrabajoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipoTrabajoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipoTrabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipoTrabajoAggregateArgs>(args: Subset<T, EquipoTrabajoAggregateArgs>): Prisma.PrismaPromise<GetEquipoTrabajoAggregateType<T>>

    /**
     * Group by EquipoTrabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipoTrabajoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipoTrabajoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipoTrabajoGroupByArgs['orderBy'] }
        : { orderBy?: EquipoTrabajoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipoTrabajoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipoTrabajoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipoTrabajo model
   */
  readonly fields: EquipoTrabajoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipoTrabajo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipoTrabajoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PlanMaestro<T extends PlanMaestroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanMaestroDefaultArgs<ExtArgs>>): Prisma__PlanMaestroClient<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pmEquipo<T extends EquipoTrabajo$pmEquipoArgs<ExtArgs> = {}>(args?: Subset<T, EquipoTrabajo$pmEquipoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipoTrabajo model
   */
  interface EquipoTrabajoFieldRefs {
    readonly id_EquipoTrabajo: FieldRef<"EquipoTrabajo", 'Int'>
    readonly planMaestroId: FieldRef<"EquipoTrabajo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EquipoTrabajo findUnique
   */
  export type EquipoTrabajoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoTrabajo to fetch.
     */
    where: EquipoTrabajoWhereUniqueInput
  }

  /**
   * EquipoTrabajo findUniqueOrThrow
   */
  export type EquipoTrabajoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoTrabajo to fetch.
     */
    where: EquipoTrabajoWhereUniqueInput
  }

  /**
   * EquipoTrabajo findFirst
   */
  export type EquipoTrabajoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoTrabajo to fetch.
     */
    where?: EquipoTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoTrabajos to fetch.
     */
    orderBy?: EquipoTrabajoOrderByWithRelationInput | EquipoTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipoTrabajos.
     */
    cursor?: EquipoTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoTrabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipoTrabajos.
     */
    distinct?: EquipoTrabajoScalarFieldEnum | EquipoTrabajoScalarFieldEnum[]
  }

  /**
   * EquipoTrabajo findFirstOrThrow
   */
  export type EquipoTrabajoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoTrabajo to fetch.
     */
    where?: EquipoTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoTrabajos to fetch.
     */
    orderBy?: EquipoTrabajoOrderByWithRelationInput | EquipoTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipoTrabajos.
     */
    cursor?: EquipoTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoTrabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipoTrabajos.
     */
    distinct?: EquipoTrabajoScalarFieldEnum | EquipoTrabajoScalarFieldEnum[]
  }

  /**
   * EquipoTrabajo findMany
   */
  export type EquipoTrabajoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * Filter, which EquipoTrabajos to fetch.
     */
    where?: EquipoTrabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipoTrabajos to fetch.
     */
    orderBy?: EquipoTrabajoOrderByWithRelationInput | EquipoTrabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipoTrabajos.
     */
    cursor?: EquipoTrabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipoTrabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipoTrabajos.
     */
    skip?: number
    distinct?: EquipoTrabajoScalarFieldEnum | EquipoTrabajoScalarFieldEnum[]
  }

  /**
   * EquipoTrabajo create
   */
  export type EquipoTrabajoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipoTrabajo.
     */
    data: XOR<EquipoTrabajoCreateInput, EquipoTrabajoUncheckedCreateInput>
  }

  /**
   * EquipoTrabajo createMany
   */
  export type EquipoTrabajoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipoTrabajos.
     */
    data: EquipoTrabajoCreateManyInput | EquipoTrabajoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipoTrabajo createManyAndReturn
   */
  export type EquipoTrabajoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * The data used to create many EquipoTrabajos.
     */
    data: EquipoTrabajoCreateManyInput | EquipoTrabajoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipoTrabajo update
   */
  export type EquipoTrabajoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipoTrabajo.
     */
    data: XOR<EquipoTrabajoUpdateInput, EquipoTrabajoUncheckedUpdateInput>
    /**
     * Choose, which EquipoTrabajo to update.
     */
    where: EquipoTrabajoWhereUniqueInput
  }

  /**
   * EquipoTrabajo updateMany
   */
  export type EquipoTrabajoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipoTrabajos.
     */
    data: XOR<EquipoTrabajoUpdateManyMutationInput, EquipoTrabajoUncheckedUpdateManyInput>
    /**
     * Filter which EquipoTrabajos to update
     */
    where?: EquipoTrabajoWhereInput
    /**
     * Limit how many EquipoTrabajos to update.
     */
    limit?: number
  }

  /**
   * EquipoTrabajo updateManyAndReturn
   */
  export type EquipoTrabajoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * The data used to update EquipoTrabajos.
     */
    data: XOR<EquipoTrabajoUpdateManyMutationInput, EquipoTrabajoUncheckedUpdateManyInput>
    /**
     * Filter which EquipoTrabajos to update
     */
    where?: EquipoTrabajoWhereInput
    /**
     * Limit how many EquipoTrabajos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipoTrabajo upsert
   */
  export type EquipoTrabajoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipoTrabajo to update in case it exists.
     */
    where: EquipoTrabajoWhereUniqueInput
    /**
     * In case the EquipoTrabajo found by the `where` argument doesn't exist, create a new EquipoTrabajo with this data.
     */
    create: XOR<EquipoTrabajoCreateInput, EquipoTrabajoUncheckedCreateInput>
    /**
     * In case the EquipoTrabajo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipoTrabajoUpdateInput, EquipoTrabajoUncheckedUpdateInput>
  }

  /**
   * EquipoTrabajo delete
   */
  export type EquipoTrabajoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
    /**
     * Filter which EquipoTrabajo to delete.
     */
    where: EquipoTrabajoWhereUniqueInput
  }

  /**
   * EquipoTrabajo deleteMany
   */
  export type EquipoTrabajoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipoTrabajos to delete
     */
    where?: EquipoTrabajoWhereInput
    /**
     * Limit how many EquipoTrabajos to delete.
     */
    limit?: number
  }

  /**
   * EquipoTrabajo.pmEquipo
   */
  export type EquipoTrabajo$pmEquipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    where?: PmEquipoWhereInput
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    cursor?: PmEquipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmEquipoScalarFieldEnum | PmEquipoScalarFieldEnum[]
  }

  /**
   * EquipoTrabajo without action
   */
  export type EquipoTrabajoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipoTrabajo
     */
    select?: EquipoTrabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipoTrabajo
     */
    omit?: EquipoTrabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipoTrabajoInclude<ExtArgs> | null
  }


  /**
   * Model PmEquipo
   */

  export type AggregatePmEquipo = {
    _count: PmEquipoCountAggregateOutputType | null
    _avg: PmEquipoAvgAggregateOutputType | null
    _sum: PmEquipoSumAggregateOutputType | null
    _min: PmEquipoMinAggregateOutputType | null
    _max: PmEquipoMaxAggregateOutputType | null
  }

  export type PmEquipoAvgAggregateOutputType = {
    id_PmEquipo: number | null
    usuarioId: number | null
    equipoTrabajoId: number | null
    equipoCargoId: number | null
  }

  export type PmEquipoSumAggregateOutputType = {
    id_PmEquipo: number | null
    usuarioId: number | null
    equipoTrabajoId: number | null
    equipoCargoId: number | null
  }

  export type PmEquipoMinAggregateOutputType = {
    id_PmEquipo: number | null
    usuarioId: number | null
    equipoTrabajoId: number | null
    equipoCargoId: number | null
  }

  export type PmEquipoMaxAggregateOutputType = {
    id_PmEquipo: number | null
    usuarioId: number | null
    equipoTrabajoId: number | null
    equipoCargoId: number | null
  }

  export type PmEquipoCountAggregateOutputType = {
    id_PmEquipo: number
    usuarioId: number
    equipoTrabajoId: number
    equipoCargoId: number
    _all: number
  }


  export type PmEquipoAvgAggregateInputType = {
    id_PmEquipo?: true
    usuarioId?: true
    equipoTrabajoId?: true
    equipoCargoId?: true
  }

  export type PmEquipoSumAggregateInputType = {
    id_PmEquipo?: true
    usuarioId?: true
    equipoTrabajoId?: true
    equipoCargoId?: true
  }

  export type PmEquipoMinAggregateInputType = {
    id_PmEquipo?: true
    usuarioId?: true
    equipoTrabajoId?: true
    equipoCargoId?: true
  }

  export type PmEquipoMaxAggregateInputType = {
    id_PmEquipo?: true
    usuarioId?: true
    equipoTrabajoId?: true
    equipoCargoId?: true
  }

  export type PmEquipoCountAggregateInputType = {
    id_PmEquipo?: true
    usuarioId?: true
    equipoTrabajoId?: true
    equipoCargoId?: true
    _all?: true
  }

  export type PmEquipoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmEquipo to aggregate.
     */
    where?: PmEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmEquipos to fetch.
     */
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PmEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmEquipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PmEquipos
    **/
    _count?: true | PmEquipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PmEquipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PmEquipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PmEquipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PmEquipoMaxAggregateInputType
  }

  export type GetPmEquipoAggregateType<T extends PmEquipoAggregateArgs> = {
        [P in keyof T & keyof AggregatePmEquipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePmEquipo[P]>
      : GetScalarType<T[P], AggregatePmEquipo[P]>
  }




  export type PmEquipoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PmEquipoWhereInput
    orderBy?: PmEquipoOrderByWithAggregationInput | PmEquipoOrderByWithAggregationInput[]
    by: PmEquipoScalarFieldEnum[] | PmEquipoScalarFieldEnum
    having?: PmEquipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PmEquipoCountAggregateInputType | true
    _avg?: PmEquipoAvgAggregateInputType
    _sum?: PmEquipoSumAggregateInputType
    _min?: PmEquipoMinAggregateInputType
    _max?: PmEquipoMaxAggregateInputType
  }

  export type PmEquipoGroupByOutputType = {
    id_PmEquipo: number
    usuarioId: number
    equipoTrabajoId: number
    equipoCargoId: number
    _count: PmEquipoCountAggregateOutputType | null
    _avg: PmEquipoAvgAggregateOutputType | null
    _sum: PmEquipoSumAggregateOutputType | null
    _min: PmEquipoMinAggregateOutputType | null
    _max: PmEquipoMaxAggregateOutputType | null
  }

  type GetPmEquipoGroupByPayload<T extends PmEquipoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PmEquipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PmEquipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PmEquipoGroupByOutputType[P]>
            : GetScalarType<T[P], PmEquipoGroupByOutputType[P]>
        }
      >
    >


  export type PmEquipoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmEquipo?: boolean
    usuarioId?: boolean
    equipoTrabajoId?: boolean
    equipoCargoId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    equipoTrabajo?: boolean | EquipoTrabajoDefaultArgs<ExtArgs>
    equipoCargo?: boolean | EquipoCargoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmEquipo"]>

  export type PmEquipoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmEquipo?: boolean
    usuarioId?: boolean
    equipoTrabajoId?: boolean
    equipoCargoId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    equipoTrabajo?: boolean | EquipoTrabajoDefaultArgs<ExtArgs>
    equipoCargo?: boolean | EquipoCargoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmEquipo"]>

  export type PmEquipoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PmEquipo?: boolean
    usuarioId?: boolean
    equipoTrabajoId?: boolean
    equipoCargoId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    equipoTrabajo?: boolean | EquipoTrabajoDefaultArgs<ExtArgs>
    equipoCargo?: boolean | EquipoCargoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pmEquipo"]>

  export type PmEquipoSelectScalar = {
    id_PmEquipo?: boolean
    usuarioId?: boolean
    equipoTrabajoId?: boolean
    equipoCargoId?: boolean
  }

  export type PmEquipoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PmEquipo" | "usuarioId" | "equipoTrabajoId" | "equipoCargoId", ExtArgs["result"]["pmEquipo"]>
  export type PmEquipoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    equipoTrabajo?: boolean | EquipoTrabajoDefaultArgs<ExtArgs>
    equipoCargo?: boolean | EquipoCargoDefaultArgs<ExtArgs>
  }
  export type PmEquipoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    equipoTrabajo?: boolean | EquipoTrabajoDefaultArgs<ExtArgs>
    equipoCargo?: boolean | EquipoCargoDefaultArgs<ExtArgs>
  }
  export type PmEquipoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    equipoTrabajo?: boolean | EquipoTrabajoDefaultArgs<ExtArgs>
    equipoCargo?: boolean | EquipoCargoDefaultArgs<ExtArgs>
  }

  export type $PmEquipoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PmEquipo"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      equipoTrabajo: Prisma.$EquipoTrabajoPayload<ExtArgs>
      equipoCargo: Prisma.$EquipoCargoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PmEquipo: number
      usuarioId: number
      equipoTrabajoId: number
      equipoCargoId: number
    }, ExtArgs["result"]["pmEquipo"]>
    composites: {}
  }

  type PmEquipoGetPayload<S extends boolean | null | undefined | PmEquipoDefaultArgs> = $Result.GetResult<Prisma.$PmEquipoPayload, S>

  type PmEquipoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PmEquipoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PmEquipoCountAggregateInputType | true
    }

  export interface PmEquipoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PmEquipo'], meta: { name: 'PmEquipo' } }
    /**
     * Find zero or one PmEquipo that matches the filter.
     * @param {PmEquipoFindUniqueArgs} args - Arguments to find a PmEquipo
     * @example
     * // Get one PmEquipo
     * const pmEquipo = await prisma.pmEquipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PmEquipoFindUniqueArgs>(args: SelectSubset<T, PmEquipoFindUniqueArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PmEquipo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PmEquipoFindUniqueOrThrowArgs} args - Arguments to find a PmEquipo
     * @example
     * // Get one PmEquipo
     * const pmEquipo = await prisma.pmEquipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PmEquipoFindUniqueOrThrowArgs>(args: SelectSubset<T, PmEquipoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmEquipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoFindFirstArgs} args - Arguments to find a PmEquipo
     * @example
     * // Get one PmEquipo
     * const pmEquipo = await prisma.pmEquipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PmEquipoFindFirstArgs>(args?: SelectSubset<T, PmEquipoFindFirstArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PmEquipo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoFindFirstOrThrowArgs} args - Arguments to find a PmEquipo
     * @example
     * // Get one PmEquipo
     * const pmEquipo = await prisma.pmEquipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PmEquipoFindFirstOrThrowArgs>(args?: SelectSubset<T, PmEquipoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PmEquipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PmEquipos
     * const pmEquipos = await prisma.pmEquipo.findMany()
     * 
     * // Get first 10 PmEquipos
     * const pmEquipos = await prisma.pmEquipo.findMany({ take: 10 })
     * 
     * // Only select the `id_PmEquipo`
     * const pmEquipoWithId_PmEquipoOnly = await prisma.pmEquipo.findMany({ select: { id_PmEquipo: true } })
     * 
     */
    findMany<T extends PmEquipoFindManyArgs>(args?: SelectSubset<T, PmEquipoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PmEquipo.
     * @param {PmEquipoCreateArgs} args - Arguments to create a PmEquipo.
     * @example
     * // Create one PmEquipo
     * const PmEquipo = await prisma.pmEquipo.create({
     *   data: {
     *     // ... data to create a PmEquipo
     *   }
     * })
     * 
     */
    create<T extends PmEquipoCreateArgs>(args: SelectSubset<T, PmEquipoCreateArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PmEquipos.
     * @param {PmEquipoCreateManyArgs} args - Arguments to create many PmEquipos.
     * @example
     * // Create many PmEquipos
     * const pmEquipo = await prisma.pmEquipo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PmEquipoCreateManyArgs>(args?: SelectSubset<T, PmEquipoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PmEquipos and returns the data saved in the database.
     * @param {PmEquipoCreateManyAndReturnArgs} args - Arguments to create many PmEquipos.
     * @example
     * // Create many PmEquipos
     * const pmEquipo = await prisma.pmEquipo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PmEquipos and only return the `id_PmEquipo`
     * const pmEquipoWithId_PmEquipoOnly = await prisma.pmEquipo.createManyAndReturn({
     *   select: { id_PmEquipo: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PmEquipoCreateManyAndReturnArgs>(args?: SelectSubset<T, PmEquipoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PmEquipo.
     * @param {PmEquipoDeleteArgs} args - Arguments to delete one PmEquipo.
     * @example
     * // Delete one PmEquipo
     * const PmEquipo = await prisma.pmEquipo.delete({
     *   where: {
     *     // ... filter to delete one PmEquipo
     *   }
     * })
     * 
     */
    delete<T extends PmEquipoDeleteArgs>(args: SelectSubset<T, PmEquipoDeleteArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PmEquipo.
     * @param {PmEquipoUpdateArgs} args - Arguments to update one PmEquipo.
     * @example
     * // Update one PmEquipo
     * const pmEquipo = await prisma.pmEquipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PmEquipoUpdateArgs>(args: SelectSubset<T, PmEquipoUpdateArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PmEquipos.
     * @param {PmEquipoDeleteManyArgs} args - Arguments to filter PmEquipos to delete.
     * @example
     * // Delete a few PmEquipos
     * const { count } = await prisma.pmEquipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PmEquipoDeleteManyArgs>(args?: SelectSubset<T, PmEquipoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmEquipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PmEquipos
     * const pmEquipo = await prisma.pmEquipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PmEquipoUpdateManyArgs>(args: SelectSubset<T, PmEquipoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PmEquipos and returns the data updated in the database.
     * @param {PmEquipoUpdateManyAndReturnArgs} args - Arguments to update many PmEquipos.
     * @example
     * // Update many PmEquipos
     * const pmEquipo = await prisma.pmEquipo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PmEquipos and only return the `id_PmEquipo`
     * const pmEquipoWithId_PmEquipoOnly = await prisma.pmEquipo.updateManyAndReturn({
     *   select: { id_PmEquipo: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PmEquipoUpdateManyAndReturnArgs>(args: SelectSubset<T, PmEquipoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PmEquipo.
     * @param {PmEquipoUpsertArgs} args - Arguments to update or create a PmEquipo.
     * @example
     * // Update or create a PmEquipo
     * const pmEquipo = await prisma.pmEquipo.upsert({
     *   create: {
     *     // ... data to create a PmEquipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PmEquipo we want to update
     *   }
     * })
     */
    upsert<T extends PmEquipoUpsertArgs>(args: SelectSubset<T, PmEquipoUpsertArgs<ExtArgs>>): Prisma__PmEquipoClient<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PmEquipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoCountArgs} args - Arguments to filter PmEquipos to count.
     * @example
     * // Count the number of PmEquipos
     * const count = await prisma.pmEquipo.count({
     *   where: {
     *     // ... the filter for the PmEquipos we want to count
     *   }
     * })
    **/
    count<T extends PmEquipoCountArgs>(
      args?: Subset<T, PmEquipoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PmEquipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PmEquipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PmEquipoAggregateArgs>(args: Subset<T, PmEquipoAggregateArgs>): Prisma.PrismaPromise<GetPmEquipoAggregateType<T>>

    /**
     * Group by PmEquipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PmEquipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PmEquipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PmEquipoGroupByArgs['orderBy'] }
        : { orderBy?: PmEquipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PmEquipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPmEquipoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PmEquipo model
   */
  readonly fields: PmEquipoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PmEquipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PmEquipoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipoTrabajo<T extends EquipoTrabajoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipoTrabajoDefaultArgs<ExtArgs>>): Prisma__EquipoTrabajoClient<$Result.GetResult<Prisma.$EquipoTrabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipoCargo<T extends EquipoCargoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipoCargoDefaultArgs<ExtArgs>>): Prisma__EquipoCargoClient<$Result.GetResult<Prisma.$EquipoCargoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PmEquipo model
   */
  interface PmEquipoFieldRefs {
    readonly id_PmEquipo: FieldRef<"PmEquipo", 'Int'>
    readonly usuarioId: FieldRef<"PmEquipo", 'Int'>
    readonly equipoTrabajoId: FieldRef<"PmEquipo", 'Int'>
    readonly equipoCargoId: FieldRef<"PmEquipo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PmEquipo findUnique
   */
  export type PmEquipoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * Filter, which PmEquipo to fetch.
     */
    where: PmEquipoWhereUniqueInput
  }

  /**
   * PmEquipo findUniqueOrThrow
   */
  export type PmEquipoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * Filter, which PmEquipo to fetch.
     */
    where: PmEquipoWhereUniqueInput
  }

  /**
   * PmEquipo findFirst
   */
  export type PmEquipoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * Filter, which PmEquipo to fetch.
     */
    where?: PmEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmEquipos to fetch.
     */
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmEquipos.
     */
    cursor?: PmEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmEquipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmEquipos.
     */
    distinct?: PmEquipoScalarFieldEnum | PmEquipoScalarFieldEnum[]
  }

  /**
   * PmEquipo findFirstOrThrow
   */
  export type PmEquipoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * Filter, which PmEquipo to fetch.
     */
    where?: PmEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmEquipos to fetch.
     */
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PmEquipos.
     */
    cursor?: PmEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmEquipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PmEquipos.
     */
    distinct?: PmEquipoScalarFieldEnum | PmEquipoScalarFieldEnum[]
  }

  /**
   * PmEquipo findMany
   */
  export type PmEquipoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * Filter, which PmEquipos to fetch.
     */
    where?: PmEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PmEquipos to fetch.
     */
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PmEquipos.
     */
    cursor?: PmEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PmEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PmEquipos.
     */
    skip?: number
    distinct?: PmEquipoScalarFieldEnum | PmEquipoScalarFieldEnum[]
  }

  /**
   * PmEquipo create
   */
  export type PmEquipoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * The data needed to create a PmEquipo.
     */
    data: XOR<PmEquipoCreateInput, PmEquipoUncheckedCreateInput>
  }

  /**
   * PmEquipo createMany
   */
  export type PmEquipoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PmEquipos.
     */
    data: PmEquipoCreateManyInput | PmEquipoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PmEquipo createManyAndReturn
   */
  export type PmEquipoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * The data used to create many PmEquipos.
     */
    data: PmEquipoCreateManyInput | PmEquipoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmEquipo update
   */
  export type PmEquipoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * The data needed to update a PmEquipo.
     */
    data: XOR<PmEquipoUpdateInput, PmEquipoUncheckedUpdateInput>
    /**
     * Choose, which PmEquipo to update.
     */
    where: PmEquipoWhereUniqueInput
  }

  /**
   * PmEquipo updateMany
   */
  export type PmEquipoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PmEquipos.
     */
    data: XOR<PmEquipoUpdateManyMutationInput, PmEquipoUncheckedUpdateManyInput>
    /**
     * Filter which PmEquipos to update
     */
    where?: PmEquipoWhereInput
    /**
     * Limit how many PmEquipos to update.
     */
    limit?: number
  }

  /**
   * PmEquipo updateManyAndReturn
   */
  export type PmEquipoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * The data used to update PmEquipos.
     */
    data: XOR<PmEquipoUpdateManyMutationInput, PmEquipoUncheckedUpdateManyInput>
    /**
     * Filter which PmEquipos to update
     */
    where?: PmEquipoWhereInput
    /**
     * Limit how many PmEquipos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PmEquipo upsert
   */
  export type PmEquipoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * The filter to search for the PmEquipo to update in case it exists.
     */
    where: PmEquipoWhereUniqueInput
    /**
     * In case the PmEquipo found by the `where` argument doesn't exist, create a new PmEquipo with this data.
     */
    create: XOR<PmEquipoCreateInput, PmEquipoUncheckedCreateInput>
    /**
     * In case the PmEquipo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PmEquipoUpdateInput, PmEquipoUncheckedUpdateInput>
  }

  /**
   * PmEquipo delete
   */
  export type PmEquipoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    /**
     * Filter which PmEquipo to delete.
     */
    where: PmEquipoWhereUniqueInput
  }

  /**
   * PmEquipo deleteMany
   */
  export type PmEquipoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PmEquipos to delete
     */
    where?: PmEquipoWhereInput
    /**
     * Limit how many PmEquipos to delete.
     */
    limit?: number
  }

  /**
   * PmEquipo without action
   */
  export type PmEquipoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id_Usuario: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id_Usuario: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id_Usuario: number | null
    nombre: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id_Usuario: number | null
    nombre: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id_Usuario: number
    nombre: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id_Usuario?: true
  }

  export type UsuarioSumAggregateInputType = {
    id_Usuario?: true
  }

  export type UsuarioMinAggregateInputType = {
    id_Usuario?: true
    nombre?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id_Usuario?: true
    nombre?: true
  }

  export type UsuarioCountAggregateInputType = {
    id_Usuario?: true
    nombre?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id_Usuario: number
    nombre: string
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Usuario?: boolean
    nombre?: boolean
    pmEquipo?: boolean | Usuario$pmEquipoArgs<ExtArgs>
    planSemanalPartida?: boolean | Usuario$planSemanalPartidaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Usuario?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Usuario?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id_Usuario?: boolean
    nombre?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_Usuario" | "nombre", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmEquipo?: boolean | Usuario$pmEquipoArgs<ExtArgs>
    planSemanalPartida?: boolean | Usuario$planSemanalPartidaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      pmEquipo: Prisma.$PmEquipoPayload<ExtArgs>[]
      planSemanalPartida: Prisma.$PlanSemanalPartidaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_Usuario: number
      nombre: string
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id_Usuario`
     * const usuarioWithId_UsuarioOnly = await prisma.usuario.findMany({ select: { id_Usuario: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id_Usuario`
     * const usuarioWithId_UsuarioOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id_Usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id_Usuario`
     * const usuarioWithId_UsuarioOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id_Usuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pmEquipo<T extends Usuario$pmEquipoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$pmEquipoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmEquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    planSemanalPartida<T extends Usuario$planSemanalPartidaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$planSemanalPartidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id_Usuario: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.pmEquipo
   */
  export type Usuario$pmEquipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmEquipo
     */
    select?: PmEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmEquipo
     */
    omit?: PmEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmEquipoInclude<ExtArgs> | null
    where?: PmEquipoWhereInput
    orderBy?: PmEquipoOrderByWithRelationInput | PmEquipoOrderByWithRelationInput[]
    cursor?: PmEquipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmEquipoScalarFieldEnum | PmEquipoScalarFieldEnum[]
  }

  /**
   * Usuario.planSemanalPartida
   */
  export type Usuario$planSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    where?: PlanSemanalPartidaWhereInput
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    cursor?: PlanSemanalPartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model ModeloVivienda
   */

  export type AggregateModeloVivienda = {
    _count: ModeloViviendaCountAggregateOutputType | null
    _avg: ModeloViviendaAvgAggregateOutputType | null
    _sum: ModeloViviendaSumAggregateOutputType | null
    _min: ModeloViviendaMinAggregateOutputType | null
    _max: ModeloViviendaMaxAggregateOutputType | null
  }

  export type ModeloViviendaAvgAggregateOutputType = {
    id_ModeloVivienda: number | null
  }

  export type ModeloViviendaSumAggregateOutputType = {
    id_ModeloVivienda: number | null
  }

  export type ModeloViviendaMinAggregateOutputType = {
    id_ModeloVivienda: number | null
    nombre: string | null
    activo: boolean | null
  }

  export type ModeloViviendaMaxAggregateOutputType = {
    id_ModeloVivienda: number | null
    nombre: string | null
    activo: boolean | null
  }

  export type ModeloViviendaCountAggregateOutputType = {
    id_ModeloVivienda: number
    nombre: number
    activo: number
    _all: number
  }


  export type ModeloViviendaAvgAggregateInputType = {
    id_ModeloVivienda?: true
  }

  export type ModeloViviendaSumAggregateInputType = {
    id_ModeloVivienda?: true
  }

  export type ModeloViviendaMinAggregateInputType = {
    id_ModeloVivienda?: true
    nombre?: true
    activo?: true
  }

  export type ModeloViviendaMaxAggregateInputType = {
    id_ModeloVivienda?: true
    nombre?: true
    activo?: true
  }

  export type ModeloViviendaCountAggregateInputType = {
    id_ModeloVivienda?: true
    nombre?: true
    activo?: true
    _all?: true
  }

  export type ModeloViviendaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModeloVivienda to aggregate.
     */
    where?: ModeloViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloViviendas to fetch.
     */
    orderBy?: ModeloViviendaOrderByWithRelationInput | ModeloViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModeloViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloViviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloViviendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModeloViviendas
    **/
    _count?: true | ModeloViviendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModeloViviendaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModeloViviendaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModeloViviendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModeloViviendaMaxAggregateInputType
  }

  export type GetModeloViviendaAggregateType<T extends ModeloViviendaAggregateArgs> = {
        [P in keyof T & keyof AggregateModeloVivienda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModeloVivienda[P]>
      : GetScalarType<T[P], AggregateModeloVivienda[P]>
  }




  export type ModeloViviendaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModeloViviendaWhereInput
    orderBy?: ModeloViviendaOrderByWithAggregationInput | ModeloViviendaOrderByWithAggregationInput[]
    by: ModeloViviendaScalarFieldEnum[] | ModeloViviendaScalarFieldEnum
    having?: ModeloViviendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModeloViviendaCountAggregateInputType | true
    _avg?: ModeloViviendaAvgAggregateInputType
    _sum?: ModeloViviendaSumAggregateInputType
    _min?: ModeloViviendaMinAggregateInputType
    _max?: ModeloViviendaMaxAggregateInputType
  }

  export type ModeloViviendaGroupByOutputType = {
    id_ModeloVivienda: number
    nombre: string
    activo: boolean
    _count: ModeloViviendaCountAggregateOutputType | null
    _avg: ModeloViviendaAvgAggregateOutputType | null
    _sum: ModeloViviendaSumAggregateOutputType | null
    _min: ModeloViviendaMinAggregateOutputType | null
    _max: ModeloViviendaMaxAggregateOutputType | null
  }

  type GetModeloViviendaGroupByPayload<T extends ModeloViviendaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModeloViviendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModeloViviendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModeloViviendaGroupByOutputType[P]>
            : GetScalarType<T[P], ModeloViviendaGroupByOutputType[P]>
        }
      >
    >


  export type ModeloViviendaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ModeloVivienda?: boolean
    nombre?: boolean
    activo?: boolean
    vivienda?: boolean | ModeloVivienda$viviendaArgs<ExtArgs>
    _count?: boolean | ModeloViviendaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modeloVivienda"]>

  export type ModeloViviendaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ModeloVivienda?: boolean
    nombre?: boolean
    activo?: boolean
  }, ExtArgs["result"]["modeloVivienda"]>

  export type ModeloViviendaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_ModeloVivienda?: boolean
    nombre?: boolean
    activo?: boolean
  }, ExtArgs["result"]["modeloVivienda"]>

  export type ModeloViviendaSelectScalar = {
    id_ModeloVivienda?: boolean
    nombre?: boolean
    activo?: boolean
  }

  export type ModeloViviendaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_ModeloVivienda" | "nombre" | "activo", ExtArgs["result"]["modeloVivienda"]>
  export type ModeloViviendaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vivienda?: boolean | ModeloVivienda$viviendaArgs<ExtArgs>
    _count?: boolean | ModeloViviendaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModeloViviendaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ModeloViviendaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModeloViviendaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModeloVivienda"
    objects: {
      vivienda: Prisma.$ViviendaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_ModeloVivienda: number
      nombre: string
      activo: boolean
    }, ExtArgs["result"]["modeloVivienda"]>
    composites: {}
  }

  type ModeloViviendaGetPayload<S extends boolean | null | undefined | ModeloViviendaDefaultArgs> = $Result.GetResult<Prisma.$ModeloViviendaPayload, S>

  type ModeloViviendaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModeloViviendaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModeloViviendaCountAggregateInputType | true
    }

  export interface ModeloViviendaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModeloVivienda'], meta: { name: 'ModeloVivienda' } }
    /**
     * Find zero or one ModeloVivienda that matches the filter.
     * @param {ModeloViviendaFindUniqueArgs} args - Arguments to find a ModeloVivienda
     * @example
     * // Get one ModeloVivienda
     * const modeloVivienda = await prisma.modeloVivienda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModeloViviendaFindUniqueArgs>(args: SelectSubset<T, ModeloViviendaFindUniqueArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModeloVivienda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModeloViviendaFindUniqueOrThrowArgs} args - Arguments to find a ModeloVivienda
     * @example
     * // Get one ModeloVivienda
     * const modeloVivienda = await prisma.modeloVivienda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModeloViviendaFindUniqueOrThrowArgs>(args: SelectSubset<T, ModeloViviendaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModeloVivienda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaFindFirstArgs} args - Arguments to find a ModeloVivienda
     * @example
     * // Get one ModeloVivienda
     * const modeloVivienda = await prisma.modeloVivienda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModeloViviendaFindFirstArgs>(args?: SelectSubset<T, ModeloViviendaFindFirstArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModeloVivienda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaFindFirstOrThrowArgs} args - Arguments to find a ModeloVivienda
     * @example
     * // Get one ModeloVivienda
     * const modeloVivienda = await prisma.modeloVivienda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModeloViviendaFindFirstOrThrowArgs>(args?: SelectSubset<T, ModeloViviendaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModeloViviendas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModeloViviendas
     * const modeloViviendas = await prisma.modeloVivienda.findMany()
     * 
     * // Get first 10 ModeloViviendas
     * const modeloViviendas = await prisma.modeloVivienda.findMany({ take: 10 })
     * 
     * // Only select the `id_ModeloVivienda`
     * const modeloViviendaWithId_ModeloViviendaOnly = await prisma.modeloVivienda.findMany({ select: { id_ModeloVivienda: true } })
     * 
     */
    findMany<T extends ModeloViviendaFindManyArgs>(args?: SelectSubset<T, ModeloViviendaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModeloVivienda.
     * @param {ModeloViviendaCreateArgs} args - Arguments to create a ModeloVivienda.
     * @example
     * // Create one ModeloVivienda
     * const ModeloVivienda = await prisma.modeloVivienda.create({
     *   data: {
     *     // ... data to create a ModeloVivienda
     *   }
     * })
     * 
     */
    create<T extends ModeloViviendaCreateArgs>(args: SelectSubset<T, ModeloViviendaCreateArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModeloViviendas.
     * @param {ModeloViviendaCreateManyArgs} args - Arguments to create many ModeloViviendas.
     * @example
     * // Create many ModeloViviendas
     * const modeloVivienda = await prisma.modeloVivienda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModeloViviendaCreateManyArgs>(args?: SelectSubset<T, ModeloViviendaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModeloViviendas and returns the data saved in the database.
     * @param {ModeloViviendaCreateManyAndReturnArgs} args - Arguments to create many ModeloViviendas.
     * @example
     * // Create many ModeloViviendas
     * const modeloVivienda = await prisma.modeloVivienda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModeloViviendas and only return the `id_ModeloVivienda`
     * const modeloViviendaWithId_ModeloViviendaOnly = await prisma.modeloVivienda.createManyAndReturn({
     *   select: { id_ModeloVivienda: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModeloViviendaCreateManyAndReturnArgs>(args?: SelectSubset<T, ModeloViviendaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModeloVivienda.
     * @param {ModeloViviendaDeleteArgs} args - Arguments to delete one ModeloVivienda.
     * @example
     * // Delete one ModeloVivienda
     * const ModeloVivienda = await prisma.modeloVivienda.delete({
     *   where: {
     *     // ... filter to delete one ModeloVivienda
     *   }
     * })
     * 
     */
    delete<T extends ModeloViviendaDeleteArgs>(args: SelectSubset<T, ModeloViviendaDeleteArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModeloVivienda.
     * @param {ModeloViviendaUpdateArgs} args - Arguments to update one ModeloVivienda.
     * @example
     * // Update one ModeloVivienda
     * const modeloVivienda = await prisma.modeloVivienda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModeloViviendaUpdateArgs>(args: SelectSubset<T, ModeloViviendaUpdateArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModeloViviendas.
     * @param {ModeloViviendaDeleteManyArgs} args - Arguments to filter ModeloViviendas to delete.
     * @example
     * // Delete a few ModeloViviendas
     * const { count } = await prisma.modeloVivienda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModeloViviendaDeleteManyArgs>(args?: SelectSubset<T, ModeloViviendaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModeloViviendas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModeloViviendas
     * const modeloVivienda = await prisma.modeloVivienda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModeloViviendaUpdateManyArgs>(args: SelectSubset<T, ModeloViviendaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModeloViviendas and returns the data updated in the database.
     * @param {ModeloViviendaUpdateManyAndReturnArgs} args - Arguments to update many ModeloViviendas.
     * @example
     * // Update many ModeloViviendas
     * const modeloVivienda = await prisma.modeloVivienda.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModeloViviendas and only return the `id_ModeloVivienda`
     * const modeloViviendaWithId_ModeloViviendaOnly = await prisma.modeloVivienda.updateManyAndReturn({
     *   select: { id_ModeloVivienda: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModeloViviendaUpdateManyAndReturnArgs>(args: SelectSubset<T, ModeloViviendaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModeloVivienda.
     * @param {ModeloViviendaUpsertArgs} args - Arguments to update or create a ModeloVivienda.
     * @example
     * // Update or create a ModeloVivienda
     * const modeloVivienda = await prisma.modeloVivienda.upsert({
     *   create: {
     *     // ... data to create a ModeloVivienda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModeloVivienda we want to update
     *   }
     * })
     */
    upsert<T extends ModeloViviendaUpsertArgs>(args: SelectSubset<T, ModeloViviendaUpsertArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModeloViviendas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaCountArgs} args - Arguments to filter ModeloViviendas to count.
     * @example
     * // Count the number of ModeloViviendas
     * const count = await prisma.modeloVivienda.count({
     *   where: {
     *     // ... the filter for the ModeloViviendas we want to count
     *   }
     * })
    **/
    count<T extends ModeloViviendaCountArgs>(
      args?: Subset<T, ModeloViviendaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModeloViviendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModeloVivienda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModeloViviendaAggregateArgs>(args: Subset<T, ModeloViviendaAggregateArgs>): Prisma.PrismaPromise<GetModeloViviendaAggregateType<T>>

    /**
     * Group by ModeloVivienda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloViviendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModeloViviendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModeloViviendaGroupByArgs['orderBy'] }
        : { orderBy?: ModeloViviendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModeloViviendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModeloViviendaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModeloVivienda model
   */
  readonly fields: ModeloViviendaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModeloVivienda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModeloViviendaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vivienda<T extends ModeloVivienda$viviendaArgs<ExtArgs> = {}>(args?: Subset<T, ModeloVivienda$viviendaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModeloVivienda model
   */
  interface ModeloViviendaFieldRefs {
    readonly id_ModeloVivienda: FieldRef<"ModeloVivienda", 'Int'>
    readonly nombre: FieldRef<"ModeloVivienda", 'String'>
    readonly activo: FieldRef<"ModeloVivienda", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ModeloVivienda findUnique
   */
  export type ModeloViviendaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * Filter, which ModeloVivienda to fetch.
     */
    where: ModeloViviendaWhereUniqueInput
  }

  /**
   * ModeloVivienda findUniqueOrThrow
   */
  export type ModeloViviendaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * Filter, which ModeloVivienda to fetch.
     */
    where: ModeloViviendaWhereUniqueInput
  }

  /**
   * ModeloVivienda findFirst
   */
  export type ModeloViviendaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * Filter, which ModeloVivienda to fetch.
     */
    where?: ModeloViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloViviendas to fetch.
     */
    orderBy?: ModeloViviendaOrderByWithRelationInput | ModeloViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModeloViviendas.
     */
    cursor?: ModeloViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloViviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloViviendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModeloViviendas.
     */
    distinct?: ModeloViviendaScalarFieldEnum | ModeloViviendaScalarFieldEnum[]
  }

  /**
   * ModeloVivienda findFirstOrThrow
   */
  export type ModeloViviendaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * Filter, which ModeloVivienda to fetch.
     */
    where?: ModeloViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloViviendas to fetch.
     */
    orderBy?: ModeloViviendaOrderByWithRelationInput | ModeloViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModeloViviendas.
     */
    cursor?: ModeloViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloViviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloViviendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModeloViviendas.
     */
    distinct?: ModeloViviendaScalarFieldEnum | ModeloViviendaScalarFieldEnum[]
  }

  /**
   * ModeloVivienda findMany
   */
  export type ModeloViviendaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * Filter, which ModeloViviendas to fetch.
     */
    where?: ModeloViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloViviendas to fetch.
     */
    orderBy?: ModeloViviendaOrderByWithRelationInput | ModeloViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModeloViviendas.
     */
    cursor?: ModeloViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloViviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloViviendas.
     */
    skip?: number
    distinct?: ModeloViviendaScalarFieldEnum | ModeloViviendaScalarFieldEnum[]
  }

  /**
   * ModeloVivienda create
   */
  export type ModeloViviendaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * The data needed to create a ModeloVivienda.
     */
    data: XOR<ModeloViviendaCreateInput, ModeloViviendaUncheckedCreateInput>
  }

  /**
   * ModeloVivienda createMany
   */
  export type ModeloViviendaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModeloViviendas.
     */
    data: ModeloViviendaCreateManyInput | ModeloViviendaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModeloVivienda createManyAndReturn
   */
  export type ModeloViviendaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * The data used to create many ModeloViviendas.
     */
    data: ModeloViviendaCreateManyInput | ModeloViviendaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModeloVivienda update
   */
  export type ModeloViviendaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * The data needed to update a ModeloVivienda.
     */
    data: XOR<ModeloViviendaUpdateInput, ModeloViviendaUncheckedUpdateInput>
    /**
     * Choose, which ModeloVivienda to update.
     */
    where: ModeloViviendaWhereUniqueInput
  }

  /**
   * ModeloVivienda updateMany
   */
  export type ModeloViviendaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModeloViviendas.
     */
    data: XOR<ModeloViviendaUpdateManyMutationInput, ModeloViviendaUncheckedUpdateManyInput>
    /**
     * Filter which ModeloViviendas to update
     */
    where?: ModeloViviendaWhereInput
    /**
     * Limit how many ModeloViviendas to update.
     */
    limit?: number
  }

  /**
   * ModeloVivienda updateManyAndReturn
   */
  export type ModeloViviendaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * The data used to update ModeloViviendas.
     */
    data: XOR<ModeloViviendaUpdateManyMutationInput, ModeloViviendaUncheckedUpdateManyInput>
    /**
     * Filter which ModeloViviendas to update
     */
    where?: ModeloViviendaWhereInput
    /**
     * Limit how many ModeloViviendas to update.
     */
    limit?: number
  }

  /**
   * ModeloVivienda upsert
   */
  export type ModeloViviendaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * The filter to search for the ModeloVivienda to update in case it exists.
     */
    where: ModeloViviendaWhereUniqueInput
    /**
     * In case the ModeloVivienda found by the `where` argument doesn't exist, create a new ModeloVivienda with this data.
     */
    create: XOR<ModeloViviendaCreateInput, ModeloViviendaUncheckedCreateInput>
    /**
     * In case the ModeloVivienda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModeloViviendaUpdateInput, ModeloViviendaUncheckedUpdateInput>
  }

  /**
   * ModeloVivienda delete
   */
  export type ModeloViviendaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
    /**
     * Filter which ModeloVivienda to delete.
     */
    where: ModeloViviendaWhereUniqueInput
  }

  /**
   * ModeloVivienda deleteMany
   */
  export type ModeloViviendaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModeloViviendas to delete
     */
    where?: ModeloViviendaWhereInput
    /**
     * Limit how many ModeloViviendas to delete.
     */
    limit?: number
  }

  /**
   * ModeloVivienda.vivienda
   */
  export type ModeloVivienda$viviendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    where?: ViviendaWhereInput
    orderBy?: ViviendaOrderByWithRelationInput | ViviendaOrderByWithRelationInput[]
    cursor?: ViviendaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViviendaScalarFieldEnum | ViviendaScalarFieldEnum[]
  }

  /**
   * ModeloVivienda without action
   */
  export type ModeloViviendaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloVivienda
     */
    select?: ModeloViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeloVivienda
     */
    omit?: ModeloViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeloViviendaInclude<ExtArgs> | null
  }


  /**
   * Model Proyecto
   */

  export type AggregateProyecto = {
    _count: ProyectoCountAggregateOutputType | null
    _avg: ProyectoAvgAggregateOutputType | null
    _sum: ProyectoSumAggregateOutputType | null
    _min: ProyectoMinAggregateOutputType | null
    _max: ProyectoMaxAggregateOutputType | null
  }

  export type ProyectoAvgAggregateOutputType = {
    id_Proyecto: number | null
  }

  export type ProyectoSumAggregateOutputType = {
    id_Proyecto: number | null
  }

  export type ProyectoMinAggregateOutputType = {
    id_Proyecto: number | null
    nombre: string | null
    activo: boolean | null
  }

  export type ProyectoMaxAggregateOutputType = {
    id_Proyecto: number | null
    nombre: string | null
    activo: boolean | null
  }

  export type ProyectoCountAggregateOutputType = {
    id_Proyecto: number
    nombre: number
    activo: number
    _all: number
  }


  export type ProyectoAvgAggregateInputType = {
    id_Proyecto?: true
  }

  export type ProyectoSumAggregateInputType = {
    id_Proyecto?: true
  }

  export type ProyectoMinAggregateInputType = {
    id_Proyecto?: true
    nombre?: true
    activo?: true
  }

  export type ProyectoMaxAggregateInputType = {
    id_Proyecto?: true
    nombre?: true
    activo?: true
  }

  export type ProyectoCountAggregateInputType = {
    id_Proyecto?: true
    nombre?: true
    activo?: true
    _all?: true
  }

  export type ProyectoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proyecto to aggregate.
     */
    where?: ProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proyectos to fetch.
     */
    orderBy?: ProyectoOrderByWithRelationInput | ProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proyectos
    **/
    _count?: true | ProyectoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProyectoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProyectoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProyectoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProyectoMaxAggregateInputType
  }

  export type GetProyectoAggregateType<T extends ProyectoAggregateArgs> = {
        [P in keyof T & keyof AggregateProyecto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProyecto[P]>
      : GetScalarType<T[P], AggregateProyecto[P]>
  }




  export type ProyectoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProyectoWhereInput
    orderBy?: ProyectoOrderByWithAggregationInput | ProyectoOrderByWithAggregationInput[]
    by: ProyectoScalarFieldEnum[] | ProyectoScalarFieldEnum
    having?: ProyectoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProyectoCountAggregateInputType | true
    _avg?: ProyectoAvgAggregateInputType
    _sum?: ProyectoSumAggregateInputType
    _min?: ProyectoMinAggregateInputType
    _max?: ProyectoMaxAggregateInputType
  }

  export type ProyectoGroupByOutputType = {
    id_Proyecto: number
    nombre: string
    activo: boolean
    _count: ProyectoCountAggregateOutputType | null
    _avg: ProyectoAvgAggregateOutputType | null
    _sum: ProyectoSumAggregateOutputType | null
    _min: ProyectoMinAggregateOutputType | null
    _max: ProyectoMaxAggregateOutputType | null
  }

  type GetProyectoGroupByPayload<T extends ProyectoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProyectoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProyectoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProyectoGroupByOutputType[P]>
            : GetScalarType<T[P], ProyectoGroupByOutputType[P]>
        }
      >
    >


  export type ProyectoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Proyecto?: boolean
    nombre?: boolean
    activo?: boolean
    planMaestro?: boolean | Proyecto$planMaestroArgs<ExtArgs>
    _count?: boolean | ProyectoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proyecto"]>

  export type ProyectoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Proyecto?: boolean
    nombre?: boolean
    activo?: boolean
  }, ExtArgs["result"]["proyecto"]>

  export type ProyectoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Proyecto?: boolean
    nombre?: boolean
    activo?: boolean
  }, ExtArgs["result"]["proyecto"]>

  export type ProyectoSelectScalar = {
    id_Proyecto?: boolean
    nombre?: boolean
    activo?: boolean
  }

  export type ProyectoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_Proyecto" | "nombre" | "activo", ExtArgs["result"]["proyecto"]>
  export type ProyectoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planMaestro?: boolean | Proyecto$planMaestroArgs<ExtArgs>
    _count?: boolean | ProyectoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProyectoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProyectoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProyectoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proyecto"
    objects: {
      planMaestro: Prisma.$PlanMaestroPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_Proyecto: number
      nombre: string
      activo: boolean
    }, ExtArgs["result"]["proyecto"]>
    composites: {}
  }

  type ProyectoGetPayload<S extends boolean | null | undefined | ProyectoDefaultArgs> = $Result.GetResult<Prisma.$ProyectoPayload, S>

  type ProyectoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProyectoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProyectoCountAggregateInputType | true
    }

  export interface ProyectoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proyecto'], meta: { name: 'Proyecto' } }
    /**
     * Find zero or one Proyecto that matches the filter.
     * @param {ProyectoFindUniqueArgs} args - Arguments to find a Proyecto
     * @example
     * // Get one Proyecto
     * const proyecto = await prisma.proyecto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProyectoFindUniqueArgs>(args: SelectSubset<T, ProyectoFindUniqueArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proyecto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProyectoFindUniqueOrThrowArgs} args - Arguments to find a Proyecto
     * @example
     * // Get one Proyecto
     * const proyecto = await prisma.proyecto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProyectoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProyectoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proyecto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoFindFirstArgs} args - Arguments to find a Proyecto
     * @example
     * // Get one Proyecto
     * const proyecto = await prisma.proyecto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProyectoFindFirstArgs>(args?: SelectSubset<T, ProyectoFindFirstArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proyecto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoFindFirstOrThrowArgs} args - Arguments to find a Proyecto
     * @example
     * // Get one Proyecto
     * const proyecto = await prisma.proyecto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProyectoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProyectoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proyectos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proyectos
     * const proyectos = await prisma.proyecto.findMany()
     * 
     * // Get first 10 Proyectos
     * const proyectos = await prisma.proyecto.findMany({ take: 10 })
     * 
     * // Only select the `id_Proyecto`
     * const proyectoWithId_ProyectoOnly = await prisma.proyecto.findMany({ select: { id_Proyecto: true } })
     * 
     */
    findMany<T extends ProyectoFindManyArgs>(args?: SelectSubset<T, ProyectoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proyecto.
     * @param {ProyectoCreateArgs} args - Arguments to create a Proyecto.
     * @example
     * // Create one Proyecto
     * const Proyecto = await prisma.proyecto.create({
     *   data: {
     *     // ... data to create a Proyecto
     *   }
     * })
     * 
     */
    create<T extends ProyectoCreateArgs>(args: SelectSubset<T, ProyectoCreateArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proyectos.
     * @param {ProyectoCreateManyArgs} args - Arguments to create many Proyectos.
     * @example
     * // Create many Proyectos
     * const proyecto = await prisma.proyecto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProyectoCreateManyArgs>(args?: SelectSubset<T, ProyectoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proyectos and returns the data saved in the database.
     * @param {ProyectoCreateManyAndReturnArgs} args - Arguments to create many Proyectos.
     * @example
     * // Create many Proyectos
     * const proyecto = await prisma.proyecto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proyectos and only return the `id_Proyecto`
     * const proyectoWithId_ProyectoOnly = await prisma.proyecto.createManyAndReturn({
     *   select: { id_Proyecto: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProyectoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProyectoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proyecto.
     * @param {ProyectoDeleteArgs} args - Arguments to delete one Proyecto.
     * @example
     * // Delete one Proyecto
     * const Proyecto = await prisma.proyecto.delete({
     *   where: {
     *     // ... filter to delete one Proyecto
     *   }
     * })
     * 
     */
    delete<T extends ProyectoDeleteArgs>(args: SelectSubset<T, ProyectoDeleteArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proyecto.
     * @param {ProyectoUpdateArgs} args - Arguments to update one Proyecto.
     * @example
     * // Update one Proyecto
     * const proyecto = await prisma.proyecto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProyectoUpdateArgs>(args: SelectSubset<T, ProyectoUpdateArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proyectos.
     * @param {ProyectoDeleteManyArgs} args - Arguments to filter Proyectos to delete.
     * @example
     * // Delete a few Proyectos
     * const { count } = await prisma.proyecto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProyectoDeleteManyArgs>(args?: SelectSubset<T, ProyectoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proyectos
     * const proyecto = await prisma.proyecto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProyectoUpdateManyArgs>(args: SelectSubset<T, ProyectoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proyectos and returns the data updated in the database.
     * @param {ProyectoUpdateManyAndReturnArgs} args - Arguments to update many Proyectos.
     * @example
     * // Update many Proyectos
     * const proyecto = await prisma.proyecto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proyectos and only return the `id_Proyecto`
     * const proyectoWithId_ProyectoOnly = await prisma.proyecto.updateManyAndReturn({
     *   select: { id_Proyecto: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProyectoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProyectoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proyecto.
     * @param {ProyectoUpsertArgs} args - Arguments to update or create a Proyecto.
     * @example
     * // Update or create a Proyecto
     * const proyecto = await prisma.proyecto.upsert({
     *   create: {
     *     // ... data to create a Proyecto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proyecto we want to update
     *   }
     * })
     */
    upsert<T extends ProyectoUpsertArgs>(args: SelectSubset<T, ProyectoUpsertArgs<ExtArgs>>): Prisma__ProyectoClient<$Result.GetResult<Prisma.$ProyectoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proyectos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoCountArgs} args - Arguments to filter Proyectos to count.
     * @example
     * // Count the number of Proyectos
     * const count = await prisma.proyecto.count({
     *   where: {
     *     // ... the filter for the Proyectos we want to count
     *   }
     * })
    **/
    count<T extends ProyectoCountArgs>(
      args?: Subset<T, ProyectoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProyectoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProyectoAggregateArgs>(args: Subset<T, ProyectoAggregateArgs>): Prisma.PrismaPromise<GetProyectoAggregateType<T>>

    /**
     * Group by Proyecto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProyectoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProyectoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProyectoGroupByArgs['orderBy'] }
        : { orderBy?: ProyectoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProyectoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProyectoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proyecto model
   */
  readonly fields: ProyectoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proyecto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProyectoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planMaestro<T extends Proyecto$planMaestroArgs<ExtArgs> = {}>(args?: Subset<T, Proyecto$planMaestroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMaestroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proyecto model
   */
  interface ProyectoFieldRefs {
    readonly id_Proyecto: FieldRef<"Proyecto", 'Int'>
    readonly nombre: FieldRef<"Proyecto", 'String'>
    readonly activo: FieldRef<"Proyecto", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Proyecto findUnique
   */
  export type ProyectoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * Filter, which Proyecto to fetch.
     */
    where: ProyectoWhereUniqueInput
  }

  /**
   * Proyecto findUniqueOrThrow
   */
  export type ProyectoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * Filter, which Proyecto to fetch.
     */
    where: ProyectoWhereUniqueInput
  }

  /**
   * Proyecto findFirst
   */
  export type ProyectoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * Filter, which Proyecto to fetch.
     */
    where?: ProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proyectos to fetch.
     */
    orderBy?: ProyectoOrderByWithRelationInput | ProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proyectos.
     */
    cursor?: ProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proyectos.
     */
    distinct?: ProyectoScalarFieldEnum | ProyectoScalarFieldEnum[]
  }

  /**
   * Proyecto findFirstOrThrow
   */
  export type ProyectoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * Filter, which Proyecto to fetch.
     */
    where?: ProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proyectos to fetch.
     */
    orderBy?: ProyectoOrderByWithRelationInput | ProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proyectos.
     */
    cursor?: ProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proyectos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proyectos.
     */
    distinct?: ProyectoScalarFieldEnum | ProyectoScalarFieldEnum[]
  }

  /**
   * Proyecto findMany
   */
  export type ProyectoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * Filter, which Proyectos to fetch.
     */
    where?: ProyectoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proyectos to fetch.
     */
    orderBy?: ProyectoOrderByWithRelationInput | ProyectoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proyectos.
     */
    cursor?: ProyectoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proyectos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proyectos.
     */
    skip?: number
    distinct?: ProyectoScalarFieldEnum | ProyectoScalarFieldEnum[]
  }

  /**
   * Proyecto create
   */
  export type ProyectoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * The data needed to create a Proyecto.
     */
    data: XOR<ProyectoCreateInput, ProyectoUncheckedCreateInput>
  }

  /**
   * Proyecto createMany
   */
  export type ProyectoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proyectos.
     */
    data: ProyectoCreateManyInput | ProyectoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proyecto createManyAndReturn
   */
  export type ProyectoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * The data used to create many Proyectos.
     */
    data: ProyectoCreateManyInput | ProyectoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proyecto update
   */
  export type ProyectoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * The data needed to update a Proyecto.
     */
    data: XOR<ProyectoUpdateInput, ProyectoUncheckedUpdateInput>
    /**
     * Choose, which Proyecto to update.
     */
    where: ProyectoWhereUniqueInput
  }

  /**
   * Proyecto updateMany
   */
  export type ProyectoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proyectos.
     */
    data: XOR<ProyectoUpdateManyMutationInput, ProyectoUncheckedUpdateManyInput>
    /**
     * Filter which Proyectos to update
     */
    where?: ProyectoWhereInput
    /**
     * Limit how many Proyectos to update.
     */
    limit?: number
  }

  /**
   * Proyecto updateManyAndReturn
   */
  export type ProyectoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * The data used to update Proyectos.
     */
    data: XOR<ProyectoUpdateManyMutationInput, ProyectoUncheckedUpdateManyInput>
    /**
     * Filter which Proyectos to update
     */
    where?: ProyectoWhereInput
    /**
     * Limit how many Proyectos to update.
     */
    limit?: number
  }

  /**
   * Proyecto upsert
   */
  export type ProyectoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * The filter to search for the Proyecto to update in case it exists.
     */
    where: ProyectoWhereUniqueInput
    /**
     * In case the Proyecto found by the `where` argument doesn't exist, create a new Proyecto with this data.
     */
    create: XOR<ProyectoCreateInput, ProyectoUncheckedCreateInput>
    /**
     * In case the Proyecto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProyectoUpdateInput, ProyectoUncheckedUpdateInput>
  }

  /**
   * Proyecto delete
   */
  export type ProyectoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
    /**
     * Filter which Proyecto to delete.
     */
    where: ProyectoWhereUniqueInput
  }

  /**
   * Proyecto deleteMany
   */
  export type ProyectoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proyectos to delete
     */
    where?: ProyectoWhereInput
    /**
     * Limit how many Proyectos to delete.
     */
    limit?: number
  }

  /**
   * Proyecto.planMaestro
   */
  export type Proyecto$planMaestroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMaestro
     */
    select?: PlanMaestroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMaestro
     */
    omit?: PlanMaestroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanMaestroInclude<ExtArgs> | null
    where?: PlanMaestroWhereInput
    orderBy?: PlanMaestroOrderByWithRelationInput | PlanMaestroOrderByWithRelationInput[]
    cursor?: PlanMaestroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanMaestroScalarFieldEnum | PlanMaestroScalarFieldEnum[]
  }

  /**
   * Proyecto without action
   */
  export type ProyectoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proyecto
     */
    select?: ProyectoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proyecto
     */
    omit?: ProyectoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProyectoInclude<ExtArgs> | null
  }


  /**
   * Model Vivienda
   */

  export type AggregateVivienda = {
    _count: ViviendaCountAggregateOutputType | null
    _avg: ViviendaAvgAggregateOutputType | null
    _sum: ViviendaSumAggregateOutputType | null
    _min: ViviendaMinAggregateOutputType | null
    _max: ViviendaMaxAggregateOutputType | null
  }

  export type ViviendaAvgAggregateOutputType = {
    id_Vivienda: number | null
    modeloViviendaId: number | null
  }

  export type ViviendaSumAggregateOutputType = {
    id_Vivienda: number | null
    modeloViviendaId: number | null
  }

  export type ViviendaMinAggregateOutputType = {
    id_Vivienda: number | null
    numero: string | null
    id_Frente: string | null
    modeloViviendaId: number | null
  }

  export type ViviendaMaxAggregateOutputType = {
    id_Vivienda: number | null
    numero: string | null
    id_Frente: string | null
    modeloViviendaId: number | null
  }

  export type ViviendaCountAggregateOutputType = {
    id_Vivienda: number
    numero: number
    id_Frente: number
    modeloViviendaId: number
    _all: number
  }


  export type ViviendaAvgAggregateInputType = {
    id_Vivienda?: true
    modeloViviendaId?: true
  }

  export type ViviendaSumAggregateInputType = {
    id_Vivienda?: true
    modeloViviendaId?: true
  }

  export type ViviendaMinAggregateInputType = {
    id_Vivienda?: true
    numero?: true
    id_Frente?: true
    modeloViviendaId?: true
  }

  export type ViviendaMaxAggregateInputType = {
    id_Vivienda?: true
    numero?: true
    id_Frente?: true
    modeloViviendaId?: true
  }

  export type ViviendaCountAggregateInputType = {
    id_Vivienda?: true
    numero?: true
    id_Frente?: true
    modeloViviendaId?: true
    _all?: true
  }

  export type ViviendaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vivienda to aggregate.
     */
    where?: ViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viviendas to fetch.
     */
    orderBy?: ViviendaOrderByWithRelationInput | ViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viviendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Viviendas
    **/
    _count?: true | ViviendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViviendaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViviendaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViviendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViviendaMaxAggregateInputType
  }

  export type GetViviendaAggregateType<T extends ViviendaAggregateArgs> = {
        [P in keyof T & keyof AggregateVivienda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVivienda[P]>
      : GetScalarType<T[P], AggregateVivienda[P]>
  }




  export type ViviendaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViviendaWhereInput
    orderBy?: ViviendaOrderByWithAggregationInput | ViviendaOrderByWithAggregationInput[]
    by: ViviendaScalarFieldEnum[] | ViviendaScalarFieldEnum
    having?: ViviendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViviendaCountAggregateInputType | true
    _avg?: ViviendaAvgAggregateInputType
    _sum?: ViviendaSumAggregateInputType
    _min?: ViviendaMinAggregateInputType
    _max?: ViviendaMaxAggregateInputType
  }

  export type ViviendaGroupByOutputType = {
    id_Vivienda: number
    numero: string
    id_Frente: string
    modeloViviendaId: number
    _count: ViviendaCountAggregateOutputType | null
    _avg: ViviendaAvgAggregateOutputType | null
    _sum: ViviendaSumAggregateOutputType | null
    _min: ViviendaMinAggregateOutputType | null
    _max: ViviendaMaxAggregateOutputType | null
  }

  type GetViviendaGroupByPayload<T extends ViviendaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViviendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViviendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViviendaGroupByOutputType[P]>
            : GetScalarType<T[P], ViviendaGroupByOutputType[P]>
        }
      >
    >


  export type ViviendaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Vivienda?: boolean
    numero?: boolean
    id_Frente?: boolean
    modeloViviendaId?: boolean
    modeloVivienda?: boolean | ModeloViviendaDefaultArgs<ExtArgs>
    planSemanalPartida?: boolean | Vivienda$planSemanalPartidaArgs<ExtArgs>
    pmProgramacion?: boolean | Vivienda$pmProgramacionArgs<ExtArgs>
    _count?: boolean | ViviendaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vivienda"]>

  export type ViviendaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Vivienda?: boolean
    numero?: boolean
    id_Frente?: boolean
    modeloViviendaId?: boolean
    modeloVivienda?: boolean | ModeloViviendaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vivienda"]>

  export type ViviendaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_Vivienda?: boolean
    numero?: boolean
    id_Frente?: boolean
    modeloViviendaId?: boolean
    modeloVivienda?: boolean | ModeloViviendaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vivienda"]>

  export type ViviendaSelectScalar = {
    id_Vivienda?: boolean
    numero?: boolean
    id_Frente?: boolean
    modeloViviendaId?: boolean
  }

  export type ViviendaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_Vivienda" | "numero" | "id_Frente" | "modeloViviendaId", ExtArgs["result"]["vivienda"]>
  export type ViviendaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modeloVivienda?: boolean | ModeloViviendaDefaultArgs<ExtArgs>
    planSemanalPartida?: boolean | Vivienda$planSemanalPartidaArgs<ExtArgs>
    pmProgramacion?: boolean | Vivienda$pmProgramacionArgs<ExtArgs>
    _count?: boolean | ViviendaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViviendaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modeloVivienda?: boolean | ModeloViviendaDefaultArgs<ExtArgs>
  }
  export type ViviendaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modeloVivienda?: boolean | ModeloViviendaDefaultArgs<ExtArgs>
  }

  export type $ViviendaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vivienda"
    objects: {
      modeloVivienda: Prisma.$ModeloViviendaPayload<ExtArgs>
      planSemanalPartida: Prisma.$PlanSemanalPartidaPayload<ExtArgs>[]
      pmProgramacion: Prisma.$PmProgramacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_Vivienda: number
      numero: string
      id_Frente: string
      modeloViviendaId: number
    }, ExtArgs["result"]["vivienda"]>
    composites: {}
  }

  type ViviendaGetPayload<S extends boolean | null | undefined | ViviendaDefaultArgs> = $Result.GetResult<Prisma.$ViviendaPayload, S>

  type ViviendaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViviendaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViviendaCountAggregateInputType | true
    }

  export interface ViviendaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vivienda'], meta: { name: 'Vivienda' } }
    /**
     * Find zero or one Vivienda that matches the filter.
     * @param {ViviendaFindUniqueArgs} args - Arguments to find a Vivienda
     * @example
     * // Get one Vivienda
     * const vivienda = await prisma.vivienda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViviendaFindUniqueArgs>(args: SelectSubset<T, ViviendaFindUniqueArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vivienda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViviendaFindUniqueOrThrowArgs} args - Arguments to find a Vivienda
     * @example
     * // Get one Vivienda
     * const vivienda = await prisma.vivienda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViviendaFindUniqueOrThrowArgs>(args: SelectSubset<T, ViviendaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vivienda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaFindFirstArgs} args - Arguments to find a Vivienda
     * @example
     * // Get one Vivienda
     * const vivienda = await prisma.vivienda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViviendaFindFirstArgs>(args?: SelectSubset<T, ViviendaFindFirstArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vivienda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaFindFirstOrThrowArgs} args - Arguments to find a Vivienda
     * @example
     * // Get one Vivienda
     * const vivienda = await prisma.vivienda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViviendaFindFirstOrThrowArgs>(args?: SelectSubset<T, ViviendaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viviendas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viviendas
     * const viviendas = await prisma.vivienda.findMany()
     * 
     * // Get first 10 Viviendas
     * const viviendas = await prisma.vivienda.findMany({ take: 10 })
     * 
     * // Only select the `id_Vivienda`
     * const viviendaWithId_ViviendaOnly = await prisma.vivienda.findMany({ select: { id_Vivienda: true } })
     * 
     */
    findMany<T extends ViviendaFindManyArgs>(args?: SelectSubset<T, ViviendaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vivienda.
     * @param {ViviendaCreateArgs} args - Arguments to create a Vivienda.
     * @example
     * // Create one Vivienda
     * const Vivienda = await prisma.vivienda.create({
     *   data: {
     *     // ... data to create a Vivienda
     *   }
     * })
     * 
     */
    create<T extends ViviendaCreateArgs>(args: SelectSubset<T, ViviendaCreateArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viviendas.
     * @param {ViviendaCreateManyArgs} args - Arguments to create many Viviendas.
     * @example
     * // Create many Viviendas
     * const vivienda = await prisma.vivienda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViviendaCreateManyArgs>(args?: SelectSubset<T, ViviendaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viviendas and returns the data saved in the database.
     * @param {ViviendaCreateManyAndReturnArgs} args - Arguments to create many Viviendas.
     * @example
     * // Create many Viviendas
     * const vivienda = await prisma.vivienda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viviendas and only return the `id_Vivienda`
     * const viviendaWithId_ViviendaOnly = await prisma.vivienda.createManyAndReturn({
     *   select: { id_Vivienda: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViviendaCreateManyAndReturnArgs>(args?: SelectSubset<T, ViviendaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vivienda.
     * @param {ViviendaDeleteArgs} args - Arguments to delete one Vivienda.
     * @example
     * // Delete one Vivienda
     * const Vivienda = await prisma.vivienda.delete({
     *   where: {
     *     // ... filter to delete one Vivienda
     *   }
     * })
     * 
     */
    delete<T extends ViviendaDeleteArgs>(args: SelectSubset<T, ViviendaDeleteArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vivienda.
     * @param {ViviendaUpdateArgs} args - Arguments to update one Vivienda.
     * @example
     * // Update one Vivienda
     * const vivienda = await prisma.vivienda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViviendaUpdateArgs>(args: SelectSubset<T, ViviendaUpdateArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viviendas.
     * @param {ViviendaDeleteManyArgs} args - Arguments to filter Viviendas to delete.
     * @example
     * // Delete a few Viviendas
     * const { count } = await prisma.vivienda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViviendaDeleteManyArgs>(args?: SelectSubset<T, ViviendaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viviendas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viviendas
     * const vivienda = await prisma.vivienda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViviendaUpdateManyArgs>(args: SelectSubset<T, ViviendaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viviendas and returns the data updated in the database.
     * @param {ViviendaUpdateManyAndReturnArgs} args - Arguments to update many Viviendas.
     * @example
     * // Update many Viviendas
     * const vivienda = await prisma.vivienda.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viviendas and only return the `id_Vivienda`
     * const viviendaWithId_ViviendaOnly = await prisma.vivienda.updateManyAndReturn({
     *   select: { id_Vivienda: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViviendaUpdateManyAndReturnArgs>(args: SelectSubset<T, ViviendaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vivienda.
     * @param {ViviendaUpsertArgs} args - Arguments to update or create a Vivienda.
     * @example
     * // Update or create a Vivienda
     * const vivienda = await prisma.vivienda.upsert({
     *   create: {
     *     // ... data to create a Vivienda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vivienda we want to update
     *   }
     * })
     */
    upsert<T extends ViviendaUpsertArgs>(args: SelectSubset<T, ViviendaUpsertArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viviendas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaCountArgs} args - Arguments to filter Viviendas to count.
     * @example
     * // Count the number of Viviendas
     * const count = await prisma.vivienda.count({
     *   where: {
     *     // ... the filter for the Viviendas we want to count
     *   }
     * })
    **/
    count<T extends ViviendaCountArgs>(
      args?: Subset<T, ViviendaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViviendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vivienda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViviendaAggregateArgs>(args: Subset<T, ViviendaAggregateArgs>): Prisma.PrismaPromise<GetViviendaAggregateType<T>>

    /**
     * Group by Vivienda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViviendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViviendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViviendaGroupByArgs['orderBy'] }
        : { orderBy?: ViviendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViviendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViviendaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vivienda model
   */
  readonly fields: ViviendaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vivienda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViviendaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modeloVivienda<T extends ModeloViviendaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModeloViviendaDefaultArgs<ExtArgs>>): Prisma__ModeloViviendaClient<$Result.GetResult<Prisma.$ModeloViviendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    planSemanalPartida<T extends Vivienda$planSemanalPartidaArgs<ExtArgs> = {}>(args?: Subset<T, Vivienda$planSemanalPartidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pmProgramacion<T extends Vivienda$pmProgramacionArgs<ExtArgs> = {}>(args?: Subset<T, Vivienda$pmProgramacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PmProgramacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vivienda model
   */
  interface ViviendaFieldRefs {
    readonly id_Vivienda: FieldRef<"Vivienda", 'Int'>
    readonly numero: FieldRef<"Vivienda", 'String'>
    readonly id_Frente: FieldRef<"Vivienda", 'String'>
    readonly modeloViviendaId: FieldRef<"Vivienda", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Vivienda findUnique
   */
  export type ViviendaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * Filter, which Vivienda to fetch.
     */
    where: ViviendaWhereUniqueInput
  }

  /**
   * Vivienda findUniqueOrThrow
   */
  export type ViviendaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * Filter, which Vivienda to fetch.
     */
    where: ViviendaWhereUniqueInput
  }

  /**
   * Vivienda findFirst
   */
  export type ViviendaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * Filter, which Vivienda to fetch.
     */
    where?: ViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viviendas to fetch.
     */
    orderBy?: ViviendaOrderByWithRelationInput | ViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viviendas.
     */
    cursor?: ViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viviendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viviendas.
     */
    distinct?: ViviendaScalarFieldEnum | ViviendaScalarFieldEnum[]
  }

  /**
   * Vivienda findFirstOrThrow
   */
  export type ViviendaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * Filter, which Vivienda to fetch.
     */
    where?: ViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viviendas to fetch.
     */
    orderBy?: ViviendaOrderByWithRelationInput | ViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viviendas.
     */
    cursor?: ViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viviendas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viviendas.
     */
    distinct?: ViviendaScalarFieldEnum | ViviendaScalarFieldEnum[]
  }

  /**
   * Vivienda findMany
   */
  export type ViviendaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * Filter, which Viviendas to fetch.
     */
    where?: ViviendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viviendas to fetch.
     */
    orderBy?: ViviendaOrderByWithRelationInput | ViviendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Viviendas.
     */
    cursor?: ViviendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viviendas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viviendas.
     */
    skip?: number
    distinct?: ViviendaScalarFieldEnum | ViviendaScalarFieldEnum[]
  }

  /**
   * Vivienda create
   */
  export type ViviendaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * The data needed to create a Vivienda.
     */
    data: XOR<ViviendaCreateInput, ViviendaUncheckedCreateInput>
  }

  /**
   * Vivienda createMany
   */
  export type ViviendaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Viviendas.
     */
    data: ViviendaCreateManyInput | ViviendaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vivienda createManyAndReturn
   */
  export type ViviendaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * The data used to create many Viviendas.
     */
    data: ViviendaCreateManyInput | ViviendaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vivienda update
   */
  export type ViviendaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * The data needed to update a Vivienda.
     */
    data: XOR<ViviendaUpdateInput, ViviendaUncheckedUpdateInput>
    /**
     * Choose, which Vivienda to update.
     */
    where: ViviendaWhereUniqueInput
  }

  /**
   * Vivienda updateMany
   */
  export type ViviendaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Viviendas.
     */
    data: XOR<ViviendaUpdateManyMutationInput, ViviendaUncheckedUpdateManyInput>
    /**
     * Filter which Viviendas to update
     */
    where?: ViviendaWhereInput
    /**
     * Limit how many Viviendas to update.
     */
    limit?: number
  }

  /**
   * Vivienda updateManyAndReturn
   */
  export type ViviendaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * The data used to update Viviendas.
     */
    data: XOR<ViviendaUpdateManyMutationInput, ViviendaUncheckedUpdateManyInput>
    /**
     * Filter which Viviendas to update
     */
    where?: ViviendaWhereInput
    /**
     * Limit how many Viviendas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vivienda upsert
   */
  export type ViviendaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * The filter to search for the Vivienda to update in case it exists.
     */
    where: ViviendaWhereUniqueInput
    /**
     * In case the Vivienda found by the `where` argument doesn't exist, create a new Vivienda with this data.
     */
    create: XOR<ViviendaCreateInput, ViviendaUncheckedCreateInput>
    /**
     * In case the Vivienda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViviendaUpdateInput, ViviendaUncheckedUpdateInput>
  }

  /**
   * Vivienda delete
   */
  export type ViviendaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
    /**
     * Filter which Vivienda to delete.
     */
    where: ViviendaWhereUniqueInput
  }

  /**
   * Vivienda deleteMany
   */
  export type ViviendaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Viviendas to delete
     */
    where?: ViviendaWhereInput
    /**
     * Limit how many Viviendas to delete.
     */
    limit?: number
  }

  /**
   * Vivienda.planSemanalPartida
   */
  export type Vivienda$planSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    where?: PlanSemanalPartidaWhereInput
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    cursor?: PlanSemanalPartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * Vivienda.pmProgramacion
   */
  export type Vivienda$pmProgramacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PmProgramacion
     */
    select?: PmProgramacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PmProgramacion
     */
    omit?: PmProgramacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PmProgramacionInclude<ExtArgs> | null
    where?: PmProgramacionWhereInput
    orderBy?: PmProgramacionOrderByWithRelationInput | PmProgramacionOrderByWithRelationInput[]
    cursor?: PmProgramacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PmProgramacionScalarFieldEnum | PmProgramacionScalarFieldEnum[]
  }

  /**
   * Vivienda without action
   */
  export type ViviendaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vivienda
     */
    select?: ViviendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vivienda
     */
    omit?: ViviendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViviendaInclude<ExtArgs> | null
  }


  /**
   * Model PlanSemanal
   */

  export type AggregatePlanSemanal = {
    _count: PlanSemanalCountAggregateOutputType | null
    _avg: PlanSemanalAvgAggregateOutputType | null
    _sum: PlanSemanalSumAggregateOutputType | null
    _min: PlanSemanalMinAggregateOutputType | null
    _max: PlanSemanalMaxAggregateOutputType | null
  }

  export type PlanSemanalAvgAggregateOutputType = {
    id_PlanSemanal: number | null
    pmFrenteId: number | null
  }

  export type PlanSemanalSumAggregateOutputType = {
    id_PlanSemanal: number | null
    pmFrenteId: number | null
  }

  export type PlanSemanalMinAggregateOutputType = {
    id_PlanSemanal: number | null
    descripcion: string | null
    fechaInicio: Date | null
    fechaTermino: Date | null
    pmFrenteId: number | null
  }

  export type PlanSemanalMaxAggregateOutputType = {
    id_PlanSemanal: number | null
    descripcion: string | null
    fechaInicio: Date | null
    fechaTermino: Date | null
    pmFrenteId: number | null
  }

  export type PlanSemanalCountAggregateOutputType = {
    id_PlanSemanal: number
    descripcion: number
    fechaInicio: number
    fechaTermino: number
    pmFrenteId: number
    _all: number
  }


  export type PlanSemanalAvgAggregateInputType = {
    id_PlanSemanal?: true
    pmFrenteId?: true
  }

  export type PlanSemanalSumAggregateInputType = {
    id_PlanSemanal?: true
    pmFrenteId?: true
  }

  export type PlanSemanalMinAggregateInputType = {
    id_PlanSemanal?: true
    descripcion?: true
    fechaInicio?: true
    fechaTermino?: true
    pmFrenteId?: true
  }

  export type PlanSemanalMaxAggregateInputType = {
    id_PlanSemanal?: true
    descripcion?: true
    fechaInicio?: true
    fechaTermino?: true
    pmFrenteId?: true
  }

  export type PlanSemanalCountAggregateInputType = {
    id_PlanSemanal?: true
    descripcion?: true
    fechaInicio?: true
    fechaTermino?: true
    pmFrenteId?: true
    _all?: true
  }

  export type PlanSemanalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanSemanal to aggregate.
     */
    where?: PlanSemanalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanals to fetch.
     */
    orderBy?: PlanSemanalOrderByWithRelationInput | PlanSemanalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanSemanalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanSemanals
    **/
    _count?: true | PlanSemanalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanSemanalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSemanalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanSemanalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanSemanalMaxAggregateInputType
  }

  export type GetPlanSemanalAggregateType<T extends PlanSemanalAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanSemanal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanSemanal[P]>
      : GetScalarType<T[P], AggregatePlanSemanal[P]>
  }




  export type PlanSemanalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalWhereInput
    orderBy?: PlanSemanalOrderByWithAggregationInput | PlanSemanalOrderByWithAggregationInput[]
    by: PlanSemanalScalarFieldEnum[] | PlanSemanalScalarFieldEnum
    having?: PlanSemanalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanSemanalCountAggregateInputType | true
    _avg?: PlanSemanalAvgAggregateInputType
    _sum?: PlanSemanalSumAggregateInputType
    _min?: PlanSemanalMinAggregateInputType
    _max?: PlanSemanalMaxAggregateInputType
  }

  export type PlanSemanalGroupByOutputType = {
    id_PlanSemanal: number
    descripcion: string
    fechaInicio: Date
    fechaTermino: Date
    pmFrenteId: number
    _count: PlanSemanalCountAggregateOutputType | null
    _avg: PlanSemanalAvgAggregateOutputType | null
    _sum: PlanSemanalSumAggregateOutputType | null
    _min: PlanSemanalMinAggregateOutputType | null
    _max: PlanSemanalMaxAggregateOutputType | null
  }

  type GetPlanSemanalGroupByPayload<T extends PlanSemanalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanSemanalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanSemanalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanSemanalGroupByOutputType[P]>
            : GetScalarType<T[P], PlanSemanalGroupByOutputType[P]>
        }
      >
    >


  export type PlanSemanalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanSemanal?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaTermino?: boolean
    pmFrenteId?: boolean
    pmFrente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSemanal"]>

  export type PlanSemanalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanSemanal?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaTermino?: boolean
    pmFrenteId?: boolean
    pmFrente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSemanal"]>

  export type PlanSemanalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanSemanal?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaTermino?: boolean
    pmFrenteId?: boolean
    pmFrente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSemanal"]>

  export type PlanSemanalSelectScalar = {
    id_PlanSemanal?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaTermino?: boolean
    pmFrenteId?: boolean
  }

  export type PlanSemanalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PlanSemanal" | "descripcion" | "fechaInicio" | "fechaTermino" | "pmFrenteId", ExtArgs["result"]["planSemanal"]>
  export type PlanSemanalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmFrente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }
  export type PlanSemanalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmFrente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }
  export type PlanSemanalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pmFrente?: boolean | PmFrenteDefaultArgs<ExtArgs>
  }

  export type $PlanSemanalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanSemanal"
    objects: {
      pmFrente: Prisma.$PmFrentePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PlanSemanal: number
      descripcion: string
      fechaInicio: Date
      fechaTermino: Date
      pmFrenteId: number
    }, ExtArgs["result"]["planSemanal"]>
    composites: {}
  }

  type PlanSemanalGetPayload<S extends boolean | null | undefined | PlanSemanalDefaultArgs> = $Result.GetResult<Prisma.$PlanSemanalPayload, S>

  type PlanSemanalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanSemanalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanSemanalCountAggregateInputType | true
    }

  export interface PlanSemanalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanSemanal'], meta: { name: 'PlanSemanal' } }
    /**
     * Find zero or one PlanSemanal that matches the filter.
     * @param {PlanSemanalFindUniqueArgs} args - Arguments to find a PlanSemanal
     * @example
     * // Get one PlanSemanal
     * const planSemanal = await prisma.planSemanal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanSemanalFindUniqueArgs>(args: SelectSubset<T, PlanSemanalFindUniqueArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanSemanal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanSemanalFindUniqueOrThrowArgs} args - Arguments to find a PlanSemanal
     * @example
     * // Get one PlanSemanal
     * const planSemanal = await prisma.planSemanal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanSemanalFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanSemanalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanSemanal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalFindFirstArgs} args - Arguments to find a PlanSemanal
     * @example
     * // Get one PlanSemanal
     * const planSemanal = await prisma.planSemanal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanSemanalFindFirstArgs>(args?: SelectSubset<T, PlanSemanalFindFirstArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanSemanal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalFindFirstOrThrowArgs} args - Arguments to find a PlanSemanal
     * @example
     * // Get one PlanSemanal
     * const planSemanal = await prisma.planSemanal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanSemanalFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanSemanalFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanSemanals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanSemanals
     * const planSemanals = await prisma.planSemanal.findMany()
     * 
     * // Get first 10 PlanSemanals
     * const planSemanals = await prisma.planSemanal.findMany({ take: 10 })
     * 
     * // Only select the `id_PlanSemanal`
     * const planSemanalWithId_PlanSemanalOnly = await prisma.planSemanal.findMany({ select: { id_PlanSemanal: true } })
     * 
     */
    findMany<T extends PlanSemanalFindManyArgs>(args?: SelectSubset<T, PlanSemanalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanSemanal.
     * @param {PlanSemanalCreateArgs} args - Arguments to create a PlanSemanal.
     * @example
     * // Create one PlanSemanal
     * const PlanSemanal = await prisma.planSemanal.create({
     *   data: {
     *     // ... data to create a PlanSemanal
     *   }
     * })
     * 
     */
    create<T extends PlanSemanalCreateArgs>(args: SelectSubset<T, PlanSemanalCreateArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanSemanals.
     * @param {PlanSemanalCreateManyArgs} args - Arguments to create many PlanSemanals.
     * @example
     * // Create many PlanSemanals
     * const planSemanal = await prisma.planSemanal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanSemanalCreateManyArgs>(args?: SelectSubset<T, PlanSemanalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanSemanals and returns the data saved in the database.
     * @param {PlanSemanalCreateManyAndReturnArgs} args - Arguments to create many PlanSemanals.
     * @example
     * // Create many PlanSemanals
     * const planSemanal = await prisma.planSemanal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanSemanals and only return the `id_PlanSemanal`
     * const planSemanalWithId_PlanSemanalOnly = await prisma.planSemanal.createManyAndReturn({
     *   select: { id_PlanSemanal: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanSemanalCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanSemanalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanSemanal.
     * @param {PlanSemanalDeleteArgs} args - Arguments to delete one PlanSemanal.
     * @example
     * // Delete one PlanSemanal
     * const PlanSemanal = await prisma.planSemanal.delete({
     *   where: {
     *     // ... filter to delete one PlanSemanal
     *   }
     * })
     * 
     */
    delete<T extends PlanSemanalDeleteArgs>(args: SelectSubset<T, PlanSemanalDeleteArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanSemanal.
     * @param {PlanSemanalUpdateArgs} args - Arguments to update one PlanSemanal.
     * @example
     * // Update one PlanSemanal
     * const planSemanal = await prisma.planSemanal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanSemanalUpdateArgs>(args: SelectSubset<T, PlanSemanalUpdateArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanSemanals.
     * @param {PlanSemanalDeleteManyArgs} args - Arguments to filter PlanSemanals to delete.
     * @example
     * // Delete a few PlanSemanals
     * const { count } = await prisma.planSemanal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanSemanalDeleteManyArgs>(args?: SelectSubset<T, PlanSemanalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanSemanals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanSemanals
     * const planSemanal = await prisma.planSemanal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanSemanalUpdateManyArgs>(args: SelectSubset<T, PlanSemanalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanSemanals and returns the data updated in the database.
     * @param {PlanSemanalUpdateManyAndReturnArgs} args - Arguments to update many PlanSemanals.
     * @example
     * // Update many PlanSemanals
     * const planSemanal = await prisma.planSemanal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanSemanals and only return the `id_PlanSemanal`
     * const planSemanalWithId_PlanSemanalOnly = await prisma.planSemanal.updateManyAndReturn({
     *   select: { id_PlanSemanal: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanSemanalUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanSemanalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanSemanal.
     * @param {PlanSemanalUpsertArgs} args - Arguments to update or create a PlanSemanal.
     * @example
     * // Update or create a PlanSemanal
     * const planSemanal = await prisma.planSemanal.upsert({
     *   create: {
     *     // ... data to create a PlanSemanal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanSemanal we want to update
     *   }
     * })
     */
    upsert<T extends PlanSemanalUpsertArgs>(args: SelectSubset<T, PlanSemanalUpsertArgs<ExtArgs>>): Prisma__PlanSemanalClient<$Result.GetResult<Prisma.$PlanSemanalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanSemanals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalCountArgs} args - Arguments to filter PlanSemanals to count.
     * @example
     * // Count the number of PlanSemanals
     * const count = await prisma.planSemanal.count({
     *   where: {
     *     // ... the filter for the PlanSemanals we want to count
     *   }
     * })
    **/
    count<T extends PlanSemanalCountArgs>(
      args?: Subset<T, PlanSemanalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanSemanalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanSemanal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanSemanalAggregateArgs>(args: Subset<T, PlanSemanalAggregateArgs>): Prisma.PrismaPromise<GetPlanSemanalAggregateType<T>>

    /**
     * Group by PlanSemanal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanSemanalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanSemanalGroupByArgs['orderBy'] }
        : { orderBy?: PlanSemanalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanSemanalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanSemanalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanSemanal model
   */
  readonly fields: PlanSemanalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanSemanal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanSemanalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pmFrente<T extends PmFrenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PmFrenteDefaultArgs<ExtArgs>>): Prisma__PmFrenteClient<$Result.GetResult<Prisma.$PmFrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanSemanal model
   */
  interface PlanSemanalFieldRefs {
    readonly id_PlanSemanal: FieldRef<"PlanSemanal", 'Int'>
    readonly descripcion: FieldRef<"PlanSemanal", 'String'>
    readonly fechaInicio: FieldRef<"PlanSemanal", 'DateTime'>
    readonly fechaTermino: FieldRef<"PlanSemanal", 'DateTime'>
    readonly pmFrenteId: FieldRef<"PlanSemanal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlanSemanal findUnique
   */
  export type PlanSemanalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanal to fetch.
     */
    where: PlanSemanalWhereUniqueInput
  }

  /**
   * PlanSemanal findUniqueOrThrow
   */
  export type PlanSemanalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanal to fetch.
     */
    where: PlanSemanalWhereUniqueInput
  }

  /**
   * PlanSemanal findFirst
   */
  export type PlanSemanalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanal to fetch.
     */
    where?: PlanSemanalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanals to fetch.
     */
    orderBy?: PlanSemanalOrderByWithRelationInput | PlanSemanalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanSemanals.
     */
    cursor?: PlanSemanalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanSemanals.
     */
    distinct?: PlanSemanalScalarFieldEnum | PlanSemanalScalarFieldEnum[]
  }

  /**
   * PlanSemanal findFirstOrThrow
   */
  export type PlanSemanalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanal to fetch.
     */
    where?: PlanSemanalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanals to fetch.
     */
    orderBy?: PlanSemanalOrderByWithRelationInput | PlanSemanalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanSemanals.
     */
    cursor?: PlanSemanalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanSemanals.
     */
    distinct?: PlanSemanalScalarFieldEnum | PlanSemanalScalarFieldEnum[]
  }

  /**
   * PlanSemanal findMany
   */
  export type PlanSemanalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanals to fetch.
     */
    where?: PlanSemanalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanals to fetch.
     */
    orderBy?: PlanSemanalOrderByWithRelationInput | PlanSemanalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanSemanals.
     */
    cursor?: PlanSemanalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanals.
     */
    skip?: number
    distinct?: PlanSemanalScalarFieldEnum | PlanSemanalScalarFieldEnum[]
  }

  /**
   * PlanSemanal create
   */
  export type PlanSemanalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanSemanal.
     */
    data: XOR<PlanSemanalCreateInput, PlanSemanalUncheckedCreateInput>
  }

  /**
   * PlanSemanal createMany
   */
  export type PlanSemanalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanSemanals.
     */
    data: PlanSemanalCreateManyInput | PlanSemanalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanSemanal createManyAndReturn
   */
  export type PlanSemanalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * The data used to create many PlanSemanals.
     */
    data: PlanSemanalCreateManyInput | PlanSemanalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanSemanal update
   */
  export type PlanSemanalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanSemanal.
     */
    data: XOR<PlanSemanalUpdateInput, PlanSemanalUncheckedUpdateInput>
    /**
     * Choose, which PlanSemanal to update.
     */
    where: PlanSemanalWhereUniqueInput
  }

  /**
   * PlanSemanal updateMany
   */
  export type PlanSemanalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanSemanals.
     */
    data: XOR<PlanSemanalUpdateManyMutationInput, PlanSemanalUncheckedUpdateManyInput>
    /**
     * Filter which PlanSemanals to update
     */
    where?: PlanSemanalWhereInput
    /**
     * Limit how many PlanSemanals to update.
     */
    limit?: number
  }

  /**
   * PlanSemanal updateManyAndReturn
   */
  export type PlanSemanalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * The data used to update PlanSemanals.
     */
    data: XOR<PlanSemanalUpdateManyMutationInput, PlanSemanalUncheckedUpdateManyInput>
    /**
     * Filter which PlanSemanals to update
     */
    where?: PlanSemanalWhereInput
    /**
     * Limit how many PlanSemanals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanSemanal upsert
   */
  export type PlanSemanalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanSemanal to update in case it exists.
     */
    where: PlanSemanalWhereUniqueInput
    /**
     * In case the PlanSemanal found by the `where` argument doesn't exist, create a new PlanSemanal with this data.
     */
    create: XOR<PlanSemanalCreateInput, PlanSemanalUncheckedCreateInput>
    /**
     * In case the PlanSemanal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanSemanalUpdateInput, PlanSemanalUncheckedUpdateInput>
  }

  /**
   * PlanSemanal delete
   */
  export type PlanSemanalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
    /**
     * Filter which PlanSemanal to delete.
     */
    where: PlanSemanalWhereUniqueInput
  }

  /**
   * PlanSemanal deleteMany
   */
  export type PlanSemanalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanSemanals to delete
     */
    where?: PlanSemanalWhereInput
    /**
     * Limit how many PlanSemanals to delete.
     */
    limit?: number
  }

  /**
   * PlanSemanal without action
   */
  export type PlanSemanalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanal
     */
    select?: PlanSemanalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanal
     */
    omit?: PlanSemanalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalInclude<ExtArgs> | null
  }


  /**
   * Model PlanSemanalPartida
   */

  export type AggregatePlanSemanalPartida = {
    _count: PlanSemanalPartidaCountAggregateOutputType | null
    _avg: PlanSemanalPartidaAvgAggregateOutputType | null
    _sum: PlanSemanalPartidaSumAggregateOutputType | null
    _min: PlanSemanalPartidaMinAggregateOutputType | null
    _max: PlanSemanalPartidaMaxAggregateOutputType | null
  }

  export type PlanSemanalPartidaAvgAggregateOutputType = {
    id_PlanSemanalPartida: number | null
    partidaId: number | null
    viviendaId: number | null
    id_UsuarioRevision: number | null
    causaNoCumplimientoId: number | null
    responsableId: number | null
    cantidadProgramada: Decimal | null
    cantidadEjecutada: Decimal | null
    id_Cuadrilla: number | null
  }

  export type PlanSemanalPartidaSumAggregateOutputType = {
    id_PlanSemanalPartida: number | null
    partidaId: number | null
    viviendaId: number | null
    id_UsuarioRevision: number | null
    causaNoCumplimientoId: number | null
    responsableId: number | null
    cantidadProgramada: Decimal | null
    cantidadEjecutada: Decimal | null
    id_Cuadrilla: number | null
  }

  export type PlanSemanalPartidaMinAggregateOutputType = {
    id_PlanSemanalPartida: number | null
    partidaId: number | null
    viviendaId: number | null
    revisionOk: boolean | null
    id_UsuarioRevision: number | null
    fechaRevision: Date | null
    causaNoCumplimientoId: number | null
    observacion: string | null
    responsableId: number | null
    cantidadProgramada: Decimal | null
    cantidadEjecutada: Decimal | null
    id_Cuadrilla: number | null
  }

  export type PlanSemanalPartidaMaxAggregateOutputType = {
    id_PlanSemanalPartida: number | null
    partidaId: number | null
    viviendaId: number | null
    revisionOk: boolean | null
    id_UsuarioRevision: number | null
    fechaRevision: Date | null
    causaNoCumplimientoId: number | null
    observacion: string | null
    responsableId: number | null
    cantidadProgramada: Decimal | null
    cantidadEjecutada: Decimal | null
    id_Cuadrilla: number | null
  }

  export type PlanSemanalPartidaCountAggregateOutputType = {
    id_PlanSemanalPartida: number
    partidaId: number
    viviendaId: number
    revisionOk: number
    id_UsuarioRevision: number
    fechaRevision: number
    causaNoCumplimientoId: number
    observacion: number
    responsableId: number
    cantidadProgramada: number
    cantidadEjecutada: number
    id_Cuadrilla: number
    _all: number
  }


  export type PlanSemanalPartidaAvgAggregateInputType = {
    id_PlanSemanalPartida?: true
    partidaId?: true
    viviendaId?: true
    id_UsuarioRevision?: true
    causaNoCumplimientoId?: true
    responsableId?: true
    cantidadProgramada?: true
    cantidadEjecutada?: true
    id_Cuadrilla?: true
  }

  export type PlanSemanalPartidaSumAggregateInputType = {
    id_PlanSemanalPartida?: true
    partidaId?: true
    viviendaId?: true
    id_UsuarioRevision?: true
    causaNoCumplimientoId?: true
    responsableId?: true
    cantidadProgramada?: true
    cantidadEjecutada?: true
    id_Cuadrilla?: true
  }

  export type PlanSemanalPartidaMinAggregateInputType = {
    id_PlanSemanalPartida?: true
    partidaId?: true
    viviendaId?: true
    revisionOk?: true
    id_UsuarioRevision?: true
    fechaRevision?: true
    causaNoCumplimientoId?: true
    observacion?: true
    responsableId?: true
    cantidadProgramada?: true
    cantidadEjecutada?: true
    id_Cuadrilla?: true
  }

  export type PlanSemanalPartidaMaxAggregateInputType = {
    id_PlanSemanalPartida?: true
    partidaId?: true
    viviendaId?: true
    revisionOk?: true
    id_UsuarioRevision?: true
    fechaRevision?: true
    causaNoCumplimientoId?: true
    observacion?: true
    responsableId?: true
    cantidadProgramada?: true
    cantidadEjecutada?: true
    id_Cuadrilla?: true
  }

  export type PlanSemanalPartidaCountAggregateInputType = {
    id_PlanSemanalPartida?: true
    partidaId?: true
    viviendaId?: true
    revisionOk?: true
    id_UsuarioRevision?: true
    fechaRevision?: true
    causaNoCumplimientoId?: true
    observacion?: true
    responsableId?: true
    cantidadProgramada?: true
    cantidadEjecutada?: true
    id_Cuadrilla?: true
    _all?: true
  }

  export type PlanSemanalPartidaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanSemanalPartida to aggregate.
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanalPartidas to fetch.
     */
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanSemanalPartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanalPartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanalPartidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanSemanalPartidas
    **/
    _count?: true | PlanSemanalPartidaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanSemanalPartidaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSemanalPartidaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanSemanalPartidaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanSemanalPartidaMaxAggregateInputType
  }

  export type GetPlanSemanalPartidaAggregateType<T extends PlanSemanalPartidaAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanSemanalPartida]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanSemanalPartida[P]>
      : GetScalarType<T[P], AggregatePlanSemanalPartida[P]>
  }




  export type PlanSemanalPartidaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSemanalPartidaWhereInput
    orderBy?: PlanSemanalPartidaOrderByWithAggregationInput | PlanSemanalPartidaOrderByWithAggregationInput[]
    by: PlanSemanalPartidaScalarFieldEnum[] | PlanSemanalPartidaScalarFieldEnum
    having?: PlanSemanalPartidaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanSemanalPartidaCountAggregateInputType | true
    _avg?: PlanSemanalPartidaAvgAggregateInputType
    _sum?: PlanSemanalPartidaSumAggregateInputType
    _min?: PlanSemanalPartidaMinAggregateInputType
    _max?: PlanSemanalPartidaMaxAggregateInputType
  }

  export type PlanSemanalPartidaGroupByOutputType = {
    id_PlanSemanalPartida: number
    partidaId: number
    viviendaId: number
    revisionOk: boolean
    id_UsuarioRevision: number
    fechaRevision: Date
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal
    cantidadEjecutada: Decimal
    id_Cuadrilla: number
    _count: PlanSemanalPartidaCountAggregateOutputType | null
    _avg: PlanSemanalPartidaAvgAggregateOutputType | null
    _sum: PlanSemanalPartidaSumAggregateOutputType | null
    _min: PlanSemanalPartidaMinAggregateOutputType | null
    _max: PlanSemanalPartidaMaxAggregateOutputType | null
  }

  type GetPlanSemanalPartidaGroupByPayload<T extends PlanSemanalPartidaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanSemanalPartidaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanSemanalPartidaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanSemanalPartidaGroupByOutputType[P]>
            : GetScalarType<T[P], PlanSemanalPartidaGroupByOutputType[P]>
        }
      >
    >


  export type PlanSemanalPartidaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanSemanalPartida?: boolean
    partidaId?: boolean
    viviendaId?: boolean
    revisionOk?: boolean
    id_UsuarioRevision?: boolean
    fechaRevision?: boolean
    causaNoCumplimientoId?: boolean
    observacion?: boolean
    responsableId?: boolean
    cantidadProgramada?: boolean
    cantidadEjecutada?: boolean
    id_Cuadrilla?: boolean
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    causaNoCumplimiento?: boolean | CausaNoCumplimientoDefaultArgs<ExtArgs>
    responsable?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSemanalPartida"]>

  export type PlanSemanalPartidaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanSemanalPartida?: boolean
    partidaId?: boolean
    viviendaId?: boolean
    revisionOk?: boolean
    id_UsuarioRevision?: boolean
    fechaRevision?: boolean
    causaNoCumplimientoId?: boolean
    observacion?: boolean
    responsableId?: boolean
    cantidadProgramada?: boolean
    cantidadEjecutada?: boolean
    id_Cuadrilla?: boolean
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    causaNoCumplimiento?: boolean | CausaNoCumplimientoDefaultArgs<ExtArgs>
    responsable?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSemanalPartida"]>

  export type PlanSemanalPartidaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_PlanSemanalPartida?: boolean
    partidaId?: boolean
    viviendaId?: boolean
    revisionOk?: boolean
    id_UsuarioRevision?: boolean
    fechaRevision?: boolean
    causaNoCumplimientoId?: boolean
    observacion?: boolean
    responsableId?: boolean
    cantidadProgramada?: boolean
    cantidadEjecutada?: boolean
    id_Cuadrilla?: boolean
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    causaNoCumplimiento?: boolean | CausaNoCumplimientoDefaultArgs<ExtArgs>
    responsable?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSemanalPartida"]>

  export type PlanSemanalPartidaSelectScalar = {
    id_PlanSemanalPartida?: boolean
    partidaId?: boolean
    viviendaId?: boolean
    revisionOk?: boolean
    id_UsuarioRevision?: boolean
    fechaRevision?: boolean
    causaNoCumplimientoId?: boolean
    observacion?: boolean
    responsableId?: boolean
    cantidadProgramada?: boolean
    cantidadEjecutada?: boolean
    id_Cuadrilla?: boolean
  }

  export type PlanSemanalPartidaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_PlanSemanalPartida" | "partidaId" | "viviendaId" | "revisionOk" | "id_UsuarioRevision" | "fechaRevision" | "causaNoCumplimientoId" | "observacion" | "responsableId" | "cantidadProgramada" | "cantidadEjecutada" | "id_Cuadrilla", ExtArgs["result"]["planSemanalPartida"]>
  export type PlanSemanalPartidaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    causaNoCumplimiento?: boolean | CausaNoCumplimientoDefaultArgs<ExtArgs>
    responsable?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type PlanSemanalPartidaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    causaNoCumplimiento?: boolean | CausaNoCumplimientoDefaultArgs<ExtArgs>
    responsable?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type PlanSemanalPartidaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partida?: boolean | PartidaDefaultArgs<ExtArgs>
    vivienda?: boolean | ViviendaDefaultArgs<ExtArgs>
    causaNoCumplimiento?: boolean | CausaNoCumplimientoDefaultArgs<ExtArgs>
    responsable?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PlanSemanalPartidaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanSemanalPartida"
    objects: {
      partida: Prisma.$PartidaPayload<ExtArgs>
      vivienda: Prisma.$ViviendaPayload<ExtArgs>
      causaNoCumplimiento: Prisma.$CausaNoCumplimientoPayload<ExtArgs>
      responsable: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_PlanSemanalPartida: number
      partidaId: number
      viviendaId: number
      revisionOk: boolean
      id_UsuarioRevision: number
      fechaRevision: Date
      causaNoCumplimientoId: number
      observacion: string
      responsableId: number
      cantidadProgramada: Prisma.Decimal
      cantidadEjecutada: Prisma.Decimal
      id_Cuadrilla: number
    }, ExtArgs["result"]["planSemanalPartida"]>
    composites: {}
  }

  type PlanSemanalPartidaGetPayload<S extends boolean | null | undefined | PlanSemanalPartidaDefaultArgs> = $Result.GetResult<Prisma.$PlanSemanalPartidaPayload, S>

  type PlanSemanalPartidaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanSemanalPartidaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanSemanalPartidaCountAggregateInputType | true
    }

  export interface PlanSemanalPartidaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanSemanalPartida'], meta: { name: 'PlanSemanalPartida' } }
    /**
     * Find zero or one PlanSemanalPartida that matches the filter.
     * @param {PlanSemanalPartidaFindUniqueArgs} args - Arguments to find a PlanSemanalPartida
     * @example
     * // Get one PlanSemanalPartida
     * const planSemanalPartida = await prisma.planSemanalPartida.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanSemanalPartidaFindUniqueArgs>(args: SelectSubset<T, PlanSemanalPartidaFindUniqueArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanSemanalPartida that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanSemanalPartidaFindUniqueOrThrowArgs} args - Arguments to find a PlanSemanalPartida
     * @example
     * // Get one PlanSemanalPartida
     * const planSemanalPartida = await prisma.planSemanalPartida.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanSemanalPartidaFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanSemanalPartidaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanSemanalPartida that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaFindFirstArgs} args - Arguments to find a PlanSemanalPartida
     * @example
     * // Get one PlanSemanalPartida
     * const planSemanalPartida = await prisma.planSemanalPartida.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanSemanalPartidaFindFirstArgs>(args?: SelectSubset<T, PlanSemanalPartidaFindFirstArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanSemanalPartida that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaFindFirstOrThrowArgs} args - Arguments to find a PlanSemanalPartida
     * @example
     * // Get one PlanSemanalPartida
     * const planSemanalPartida = await prisma.planSemanalPartida.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanSemanalPartidaFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanSemanalPartidaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanSemanalPartidas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanSemanalPartidas
     * const planSemanalPartidas = await prisma.planSemanalPartida.findMany()
     * 
     * // Get first 10 PlanSemanalPartidas
     * const planSemanalPartidas = await prisma.planSemanalPartida.findMany({ take: 10 })
     * 
     * // Only select the `id_PlanSemanalPartida`
     * const planSemanalPartidaWithId_PlanSemanalPartidaOnly = await prisma.planSemanalPartida.findMany({ select: { id_PlanSemanalPartida: true } })
     * 
     */
    findMany<T extends PlanSemanalPartidaFindManyArgs>(args?: SelectSubset<T, PlanSemanalPartidaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanSemanalPartida.
     * @param {PlanSemanalPartidaCreateArgs} args - Arguments to create a PlanSemanalPartida.
     * @example
     * // Create one PlanSemanalPartida
     * const PlanSemanalPartida = await prisma.planSemanalPartida.create({
     *   data: {
     *     // ... data to create a PlanSemanalPartida
     *   }
     * })
     * 
     */
    create<T extends PlanSemanalPartidaCreateArgs>(args: SelectSubset<T, PlanSemanalPartidaCreateArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanSemanalPartidas.
     * @param {PlanSemanalPartidaCreateManyArgs} args - Arguments to create many PlanSemanalPartidas.
     * @example
     * // Create many PlanSemanalPartidas
     * const planSemanalPartida = await prisma.planSemanalPartida.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanSemanalPartidaCreateManyArgs>(args?: SelectSubset<T, PlanSemanalPartidaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanSemanalPartidas and returns the data saved in the database.
     * @param {PlanSemanalPartidaCreateManyAndReturnArgs} args - Arguments to create many PlanSemanalPartidas.
     * @example
     * // Create many PlanSemanalPartidas
     * const planSemanalPartida = await prisma.planSemanalPartida.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanSemanalPartidas and only return the `id_PlanSemanalPartida`
     * const planSemanalPartidaWithId_PlanSemanalPartidaOnly = await prisma.planSemanalPartida.createManyAndReturn({
     *   select: { id_PlanSemanalPartida: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanSemanalPartidaCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanSemanalPartidaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanSemanalPartida.
     * @param {PlanSemanalPartidaDeleteArgs} args - Arguments to delete one PlanSemanalPartida.
     * @example
     * // Delete one PlanSemanalPartida
     * const PlanSemanalPartida = await prisma.planSemanalPartida.delete({
     *   where: {
     *     // ... filter to delete one PlanSemanalPartida
     *   }
     * })
     * 
     */
    delete<T extends PlanSemanalPartidaDeleteArgs>(args: SelectSubset<T, PlanSemanalPartidaDeleteArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanSemanalPartida.
     * @param {PlanSemanalPartidaUpdateArgs} args - Arguments to update one PlanSemanalPartida.
     * @example
     * // Update one PlanSemanalPartida
     * const planSemanalPartida = await prisma.planSemanalPartida.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanSemanalPartidaUpdateArgs>(args: SelectSubset<T, PlanSemanalPartidaUpdateArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanSemanalPartidas.
     * @param {PlanSemanalPartidaDeleteManyArgs} args - Arguments to filter PlanSemanalPartidas to delete.
     * @example
     * // Delete a few PlanSemanalPartidas
     * const { count } = await prisma.planSemanalPartida.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanSemanalPartidaDeleteManyArgs>(args?: SelectSubset<T, PlanSemanalPartidaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanSemanalPartidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanSemanalPartidas
     * const planSemanalPartida = await prisma.planSemanalPartida.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanSemanalPartidaUpdateManyArgs>(args: SelectSubset<T, PlanSemanalPartidaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanSemanalPartidas and returns the data updated in the database.
     * @param {PlanSemanalPartidaUpdateManyAndReturnArgs} args - Arguments to update many PlanSemanalPartidas.
     * @example
     * // Update many PlanSemanalPartidas
     * const planSemanalPartida = await prisma.planSemanalPartida.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanSemanalPartidas and only return the `id_PlanSemanalPartida`
     * const planSemanalPartidaWithId_PlanSemanalPartidaOnly = await prisma.planSemanalPartida.updateManyAndReturn({
     *   select: { id_PlanSemanalPartida: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanSemanalPartidaUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanSemanalPartidaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanSemanalPartida.
     * @param {PlanSemanalPartidaUpsertArgs} args - Arguments to update or create a PlanSemanalPartida.
     * @example
     * // Update or create a PlanSemanalPartida
     * const planSemanalPartida = await prisma.planSemanalPartida.upsert({
     *   create: {
     *     // ... data to create a PlanSemanalPartida
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanSemanalPartida we want to update
     *   }
     * })
     */
    upsert<T extends PlanSemanalPartidaUpsertArgs>(args: SelectSubset<T, PlanSemanalPartidaUpsertArgs<ExtArgs>>): Prisma__PlanSemanalPartidaClient<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanSemanalPartidas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaCountArgs} args - Arguments to filter PlanSemanalPartidas to count.
     * @example
     * // Count the number of PlanSemanalPartidas
     * const count = await prisma.planSemanalPartida.count({
     *   where: {
     *     // ... the filter for the PlanSemanalPartidas we want to count
     *   }
     * })
    **/
    count<T extends PlanSemanalPartidaCountArgs>(
      args?: Subset<T, PlanSemanalPartidaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanSemanalPartidaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanSemanalPartida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanSemanalPartidaAggregateArgs>(args: Subset<T, PlanSemanalPartidaAggregateArgs>): Prisma.PrismaPromise<GetPlanSemanalPartidaAggregateType<T>>

    /**
     * Group by PlanSemanalPartida.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSemanalPartidaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanSemanalPartidaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanSemanalPartidaGroupByArgs['orderBy'] }
        : { orderBy?: PlanSemanalPartidaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanSemanalPartidaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanSemanalPartidaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanSemanalPartida model
   */
  readonly fields: PlanSemanalPartidaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanSemanalPartida.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanSemanalPartidaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partida<T extends PartidaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartidaDefaultArgs<ExtArgs>>): Prisma__PartidaClient<$Result.GetResult<Prisma.$PartidaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vivienda<T extends ViviendaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViviendaDefaultArgs<ExtArgs>>): Prisma__ViviendaClient<$Result.GetResult<Prisma.$ViviendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    causaNoCumplimiento<T extends CausaNoCumplimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CausaNoCumplimientoDefaultArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responsable<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanSemanalPartida model
   */
  interface PlanSemanalPartidaFieldRefs {
    readonly id_PlanSemanalPartida: FieldRef<"PlanSemanalPartida", 'Int'>
    readonly partidaId: FieldRef<"PlanSemanalPartida", 'Int'>
    readonly viviendaId: FieldRef<"PlanSemanalPartida", 'Int'>
    readonly revisionOk: FieldRef<"PlanSemanalPartida", 'Boolean'>
    readonly id_UsuarioRevision: FieldRef<"PlanSemanalPartida", 'Int'>
    readonly fechaRevision: FieldRef<"PlanSemanalPartida", 'DateTime'>
    readonly causaNoCumplimientoId: FieldRef<"PlanSemanalPartida", 'Int'>
    readonly observacion: FieldRef<"PlanSemanalPartida", 'String'>
    readonly responsableId: FieldRef<"PlanSemanalPartida", 'Int'>
    readonly cantidadProgramada: FieldRef<"PlanSemanalPartida", 'Decimal'>
    readonly cantidadEjecutada: FieldRef<"PlanSemanalPartida", 'Decimal'>
    readonly id_Cuadrilla: FieldRef<"PlanSemanalPartida", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlanSemanalPartida findUnique
   */
  export type PlanSemanalPartidaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanalPartida to fetch.
     */
    where: PlanSemanalPartidaWhereUniqueInput
  }

  /**
   * PlanSemanalPartida findUniqueOrThrow
   */
  export type PlanSemanalPartidaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanalPartida to fetch.
     */
    where: PlanSemanalPartidaWhereUniqueInput
  }

  /**
   * PlanSemanalPartida findFirst
   */
  export type PlanSemanalPartidaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanalPartida to fetch.
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanalPartidas to fetch.
     */
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanSemanalPartidas.
     */
    cursor?: PlanSemanalPartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanalPartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanalPartidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanSemanalPartidas.
     */
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * PlanSemanalPartida findFirstOrThrow
   */
  export type PlanSemanalPartidaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanalPartida to fetch.
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanalPartidas to fetch.
     */
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanSemanalPartidas.
     */
    cursor?: PlanSemanalPartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanalPartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanalPartidas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanSemanalPartidas.
     */
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * PlanSemanalPartida findMany
   */
  export type PlanSemanalPartidaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * Filter, which PlanSemanalPartidas to fetch.
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSemanalPartidas to fetch.
     */
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanSemanalPartidas.
     */
    cursor?: PlanSemanalPartidaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSemanalPartidas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSemanalPartidas.
     */
    skip?: number
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * PlanSemanalPartida create
   */
  export type PlanSemanalPartidaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanSemanalPartida.
     */
    data: XOR<PlanSemanalPartidaCreateInput, PlanSemanalPartidaUncheckedCreateInput>
  }

  /**
   * PlanSemanalPartida createMany
   */
  export type PlanSemanalPartidaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanSemanalPartidas.
     */
    data: PlanSemanalPartidaCreateManyInput | PlanSemanalPartidaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanSemanalPartida createManyAndReturn
   */
  export type PlanSemanalPartidaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * The data used to create many PlanSemanalPartidas.
     */
    data: PlanSemanalPartidaCreateManyInput | PlanSemanalPartidaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanSemanalPartida update
   */
  export type PlanSemanalPartidaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanSemanalPartida.
     */
    data: XOR<PlanSemanalPartidaUpdateInput, PlanSemanalPartidaUncheckedUpdateInput>
    /**
     * Choose, which PlanSemanalPartida to update.
     */
    where: PlanSemanalPartidaWhereUniqueInput
  }

  /**
   * PlanSemanalPartida updateMany
   */
  export type PlanSemanalPartidaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanSemanalPartidas.
     */
    data: XOR<PlanSemanalPartidaUpdateManyMutationInput, PlanSemanalPartidaUncheckedUpdateManyInput>
    /**
     * Filter which PlanSemanalPartidas to update
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * Limit how many PlanSemanalPartidas to update.
     */
    limit?: number
  }

  /**
   * PlanSemanalPartida updateManyAndReturn
   */
  export type PlanSemanalPartidaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * The data used to update PlanSemanalPartidas.
     */
    data: XOR<PlanSemanalPartidaUpdateManyMutationInput, PlanSemanalPartidaUncheckedUpdateManyInput>
    /**
     * Filter which PlanSemanalPartidas to update
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * Limit how many PlanSemanalPartidas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanSemanalPartida upsert
   */
  export type PlanSemanalPartidaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanSemanalPartida to update in case it exists.
     */
    where: PlanSemanalPartidaWhereUniqueInput
    /**
     * In case the PlanSemanalPartida found by the `where` argument doesn't exist, create a new PlanSemanalPartida with this data.
     */
    create: XOR<PlanSemanalPartidaCreateInput, PlanSemanalPartidaUncheckedCreateInput>
    /**
     * In case the PlanSemanalPartida was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanSemanalPartidaUpdateInput, PlanSemanalPartidaUncheckedUpdateInput>
  }

  /**
   * PlanSemanalPartida delete
   */
  export type PlanSemanalPartidaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    /**
     * Filter which PlanSemanalPartida to delete.
     */
    where: PlanSemanalPartidaWhereUniqueInput
  }

  /**
   * PlanSemanalPartida deleteMany
   */
  export type PlanSemanalPartidaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanSemanalPartidas to delete
     */
    where?: PlanSemanalPartidaWhereInput
    /**
     * Limit how many PlanSemanalPartidas to delete.
     */
    limit?: number
  }

  /**
   * PlanSemanalPartida without action
   */
  export type PlanSemanalPartidaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
  }


  /**
   * Model CausaNoCumplimiento
   */

  export type AggregateCausaNoCumplimiento = {
    _count: CausaNoCumplimientoCountAggregateOutputType | null
    _avg: CausaNoCumplimientoAvgAggregateOutputType | null
    _sum: CausaNoCumplimientoSumAggregateOutputType | null
    _min: CausaNoCumplimientoMinAggregateOutputType | null
    _max: CausaNoCumplimientoMaxAggregateOutputType | null
  }

  export type CausaNoCumplimientoAvgAggregateOutputType = {
    id_CausaNoCumplimiento: number | null
  }

  export type CausaNoCumplimientoSumAggregateOutputType = {
    id_CausaNoCumplimiento: number | null
  }

  export type CausaNoCumplimientoMinAggregateOutputType = {
    id_CausaNoCumplimiento: number | null
    nombre: string | null
    esActivo: boolean | null
  }

  export type CausaNoCumplimientoMaxAggregateOutputType = {
    id_CausaNoCumplimiento: number | null
    nombre: string | null
    esActivo: boolean | null
  }

  export type CausaNoCumplimientoCountAggregateOutputType = {
    id_CausaNoCumplimiento: number
    nombre: number
    esActivo: number
    _all: number
  }


  export type CausaNoCumplimientoAvgAggregateInputType = {
    id_CausaNoCumplimiento?: true
  }

  export type CausaNoCumplimientoSumAggregateInputType = {
    id_CausaNoCumplimiento?: true
  }

  export type CausaNoCumplimientoMinAggregateInputType = {
    id_CausaNoCumplimiento?: true
    nombre?: true
    esActivo?: true
  }

  export type CausaNoCumplimientoMaxAggregateInputType = {
    id_CausaNoCumplimiento?: true
    nombre?: true
    esActivo?: true
  }

  export type CausaNoCumplimientoCountAggregateInputType = {
    id_CausaNoCumplimiento?: true
    nombre?: true
    esActivo?: true
    _all?: true
  }

  export type CausaNoCumplimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CausaNoCumplimiento to aggregate.
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CausaNoCumplimientos to fetch.
     */
    orderBy?: CausaNoCumplimientoOrderByWithRelationInput | CausaNoCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CausaNoCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CausaNoCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CausaNoCumplimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CausaNoCumplimientos
    **/
    _count?: true | CausaNoCumplimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CausaNoCumplimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CausaNoCumplimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CausaNoCumplimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CausaNoCumplimientoMaxAggregateInputType
  }

  export type GetCausaNoCumplimientoAggregateType<T extends CausaNoCumplimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateCausaNoCumplimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCausaNoCumplimiento[P]>
      : GetScalarType<T[P], AggregateCausaNoCumplimiento[P]>
  }




  export type CausaNoCumplimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CausaNoCumplimientoWhereInput
    orderBy?: CausaNoCumplimientoOrderByWithAggregationInput | CausaNoCumplimientoOrderByWithAggregationInput[]
    by: CausaNoCumplimientoScalarFieldEnum[] | CausaNoCumplimientoScalarFieldEnum
    having?: CausaNoCumplimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CausaNoCumplimientoCountAggregateInputType | true
    _avg?: CausaNoCumplimientoAvgAggregateInputType
    _sum?: CausaNoCumplimientoSumAggregateInputType
    _min?: CausaNoCumplimientoMinAggregateInputType
    _max?: CausaNoCumplimientoMaxAggregateInputType
  }

  export type CausaNoCumplimientoGroupByOutputType = {
    id_CausaNoCumplimiento: number
    nombre: string
    esActivo: boolean
    _count: CausaNoCumplimientoCountAggregateOutputType | null
    _avg: CausaNoCumplimientoAvgAggregateOutputType | null
    _sum: CausaNoCumplimientoSumAggregateOutputType | null
    _min: CausaNoCumplimientoMinAggregateOutputType | null
    _max: CausaNoCumplimientoMaxAggregateOutputType | null
  }

  type GetCausaNoCumplimientoGroupByPayload<T extends CausaNoCumplimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CausaNoCumplimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CausaNoCumplimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CausaNoCumplimientoGroupByOutputType[P]>
            : GetScalarType<T[P], CausaNoCumplimientoGroupByOutputType[P]>
        }
      >
    >


  export type CausaNoCumplimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_CausaNoCumplimiento?: boolean
    nombre?: boolean
    esActivo?: boolean
    planSemanalPartida?: boolean | CausaNoCumplimiento$planSemanalPartidaArgs<ExtArgs>
    _count?: boolean | CausaNoCumplimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["causaNoCumplimiento"]>

  export type CausaNoCumplimientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_CausaNoCumplimiento?: boolean
    nombre?: boolean
    esActivo?: boolean
  }, ExtArgs["result"]["causaNoCumplimiento"]>

  export type CausaNoCumplimientoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_CausaNoCumplimiento?: boolean
    nombre?: boolean
    esActivo?: boolean
  }, ExtArgs["result"]["causaNoCumplimiento"]>

  export type CausaNoCumplimientoSelectScalar = {
    id_CausaNoCumplimiento?: boolean
    nombre?: boolean
    esActivo?: boolean
  }

  export type CausaNoCumplimientoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_CausaNoCumplimiento" | "nombre" | "esActivo", ExtArgs["result"]["causaNoCumplimiento"]>
  export type CausaNoCumplimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planSemanalPartida?: boolean | CausaNoCumplimiento$planSemanalPartidaArgs<ExtArgs>
    _count?: boolean | CausaNoCumplimientoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CausaNoCumplimientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CausaNoCumplimientoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CausaNoCumplimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CausaNoCumplimiento"
    objects: {
      planSemanalPartida: Prisma.$PlanSemanalPartidaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_CausaNoCumplimiento: number
      nombre: string
      esActivo: boolean
    }, ExtArgs["result"]["causaNoCumplimiento"]>
    composites: {}
  }

  type CausaNoCumplimientoGetPayload<S extends boolean | null | undefined | CausaNoCumplimientoDefaultArgs> = $Result.GetResult<Prisma.$CausaNoCumplimientoPayload, S>

  type CausaNoCumplimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CausaNoCumplimientoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CausaNoCumplimientoCountAggregateInputType | true
    }

  export interface CausaNoCumplimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CausaNoCumplimiento'], meta: { name: 'CausaNoCumplimiento' } }
    /**
     * Find zero or one CausaNoCumplimiento that matches the filter.
     * @param {CausaNoCumplimientoFindUniqueArgs} args - Arguments to find a CausaNoCumplimiento
     * @example
     * // Get one CausaNoCumplimiento
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CausaNoCumplimientoFindUniqueArgs>(args: SelectSubset<T, CausaNoCumplimientoFindUniqueArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CausaNoCumplimiento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CausaNoCumplimientoFindUniqueOrThrowArgs} args - Arguments to find a CausaNoCumplimiento
     * @example
     * // Get one CausaNoCumplimiento
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CausaNoCumplimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, CausaNoCumplimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CausaNoCumplimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoFindFirstArgs} args - Arguments to find a CausaNoCumplimiento
     * @example
     * // Get one CausaNoCumplimiento
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CausaNoCumplimientoFindFirstArgs>(args?: SelectSubset<T, CausaNoCumplimientoFindFirstArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CausaNoCumplimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoFindFirstOrThrowArgs} args - Arguments to find a CausaNoCumplimiento
     * @example
     * // Get one CausaNoCumplimiento
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CausaNoCumplimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, CausaNoCumplimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CausaNoCumplimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CausaNoCumplimientos
     * const causaNoCumplimientos = await prisma.causaNoCumplimiento.findMany()
     * 
     * // Get first 10 CausaNoCumplimientos
     * const causaNoCumplimientos = await prisma.causaNoCumplimiento.findMany({ take: 10 })
     * 
     * // Only select the `id_CausaNoCumplimiento`
     * const causaNoCumplimientoWithId_CausaNoCumplimientoOnly = await prisma.causaNoCumplimiento.findMany({ select: { id_CausaNoCumplimiento: true } })
     * 
     */
    findMany<T extends CausaNoCumplimientoFindManyArgs>(args?: SelectSubset<T, CausaNoCumplimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CausaNoCumplimiento.
     * @param {CausaNoCumplimientoCreateArgs} args - Arguments to create a CausaNoCumplimiento.
     * @example
     * // Create one CausaNoCumplimiento
     * const CausaNoCumplimiento = await prisma.causaNoCumplimiento.create({
     *   data: {
     *     // ... data to create a CausaNoCumplimiento
     *   }
     * })
     * 
     */
    create<T extends CausaNoCumplimientoCreateArgs>(args: SelectSubset<T, CausaNoCumplimientoCreateArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CausaNoCumplimientos.
     * @param {CausaNoCumplimientoCreateManyArgs} args - Arguments to create many CausaNoCumplimientos.
     * @example
     * // Create many CausaNoCumplimientos
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CausaNoCumplimientoCreateManyArgs>(args?: SelectSubset<T, CausaNoCumplimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CausaNoCumplimientos and returns the data saved in the database.
     * @param {CausaNoCumplimientoCreateManyAndReturnArgs} args - Arguments to create many CausaNoCumplimientos.
     * @example
     * // Create many CausaNoCumplimientos
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CausaNoCumplimientos and only return the `id_CausaNoCumplimiento`
     * const causaNoCumplimientoWithId_CausaNoCumplimientoOnly = await prisma.causaNoCumplimiento.createManyAndReturn({
     *   select: { id_CausaNoCumplimiento: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CausaNoCumplimientoCreateManyAndReturnArgs>(args?: SelectSubset<T, CausaNoCumplimientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CausaNoCumplimiento.
     * @param {CausaNoCumplimientoDeleteArgs} args - Arguments to delete one CausaNoCumplimiento.
     * @example
     * // Delete one CausaNoCumplimiento
     * const CausaNoCumplimiento = await prisma.causaNoCumplimiento.delete({
     *   where: {
     *     // ... filter to delete one CausaNoCumplimiento
     *   }
     * })
     * 
     */
    delete<T extends CausaNoCumplimientoDeleteArgs>(args: SelectSubset<T, CausaNoCumplimientoDeleteArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CausaNoCumplimiento.
     * @param {CausaNoCumplimientoUpdateArgs} args - Arguments to update one CausaNoCumplimiento.
     * @example
     * // Update one CausaNoCumplimiento
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CausaNoCumplimientoUpdateArgs>(args: SelectSubset<T, CausaNoCumplimientoUpdateArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CausaNoCumplimientos.
     * @param {CausaNoCumplimientoDeleteManyArgs} args - Arguments to filter CausaNoCumplimientos to delete.
     * @example
     * // Delete a few CausaNoCumplimientos
     * const { count } = await prisma.causaNoCumplimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CausaNoCumplimientoDeleteManyArgs>(args?: SelectSubset<T, CausaNoCumplimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CausaNoCumplimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CausaNoCumplimientos
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CausaNoCumplimientoUpdateManyArgs>(args: SelectSubset<T, CausaNoCumplimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CausaNoCumplimientos and returns the data updated in the database.
     * @param {CausaNoCumplimientoUpdateManyAndReturnArgs} args - Arguments to update many CausaNoCumplimientos.
     * @example
     * // Update many CausaNoCumplimientos
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CausaNoCumplimientos and only return the `id_CausaNoCumplimiento`
     * const causaNoCumplimientoWithId_CausaNoCumplimientoOnly = await prisma.causaNoCumplimiento.updateManyAndReturn({
     *   select: { id_CausaNoCumplimiento: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CausaNoCumplimientoUpdateManyAndReturnArgs>(args: SelectSubset<T, CausaNoCumplimientoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CausaNoCumplimiento.
     * @param {CausaNoCumplimientoUpsertArgs} args - Arguments to update or create a CausaNoCumplimiento.
     * @example
     * // Update or create a CausaNoCumplimiento
     * const causaNoCumplimiento = await prisma.causaNoCumplimiento.upsert({
     *   create: {
     *     // ... data to create a CausaNoCumplimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CausaNoCumplimiento we want to update
     *   }
     * })
     */
    upsert<T extends CausaNoCumplimientoUpsertArgs>(args: SelectSubset<T, CausaNoCumplimientoUpsertArgs<ExtArgs>>): Prisma__CausaNoCumplimientoClient<$Result.GetResult<Prisma.$CausaNoCumplimientoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CausaNoCumplimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoCountArgs} args - Arguments to filter CausaNoCumplimientos to count.
     * @example
     * // Count the number of CausaNoCumplimientos
     * const count = await prisma.causaNoCumplimiento.count({
     *   where: {
     *     // ... the filter for the CausaNoCumplimientos we want to count
     *   }
     * })
    **/
    count<T extends CausaNoCumplimientoCountArgs>(
      args?: Subset<T, CausaNoCumplimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CausaNoCumplimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CausaNoCumplimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CausaNoCumplimientoAggregateArgs>(args: Subset<T, CausaNoCumplimientoAggregateArgs>): Prisma.PrismaPromise<GetCausaNoCumplimientoAggregateType<T>>

    /**
     * Group by CausaNoCumplimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausaNoCumplimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CausaNoCumplimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CausaNoCumplimientoGroupByArgs['orderBy'] }
        : { orderBy?: CausaNoCumplimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CausaNoCumplimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCausaNoCumplimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CausaNoCumplimiento model
   */
  readonly fields: CausaNoCumplimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CausaNoCumplimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CausaNoCumplimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planSemanalPartida<T extends CausaNoCumplimiento$planSemanalPartidaArgs<ExtArgs> = {}>(args?: Subset<T, CausaNoCumplimiento$planSemanalPartidaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSemanalPartidaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CausaNoCumplimiento model
   */
  interface CausaNoCumplimientoFieldRefs {
    readonly id_CausaNoCumplimiento: FieldRef<"CausaNoCumplimiento", 'Int'>
    readonly nombre: FieldRef<"CausaNoCumplimiento", 'String'>
    readonly esActivo: FieldRef<"CausaNoCumplimiento", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CausaNoCumplimiento findUnique
   */
  export type CausaNoCumplimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * Filter, which CausaNoCumplimiento to fetch.
     */
    where: CausaNoCumplimientoWhereUniqueInput
  }

  /**
   * CausaNoCumplimiento findUniqueOrThrow
   */
  export type CausaNoCumplimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * Filter, which CausaNoCumplimiento to fetch.
     */
    where: CausaNoCumplimientoWhereUniqueInput
  }

  /**
   * CausaNoCumplimiento findFirst
   */
  export type CausaNoCumplimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * Filter, which CausaNoCumplimiento to fetch.
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CausaNoCumplimientos to fetch.
     */
    orderBy?: CausaNoCumplimientoOrderByWithRelationInput | CausaNoCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CausaNoCumplimientos.
     */
    cursor?: CausaNoCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CausaNoCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CausaNoCumplimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CausaNoCumplimientos.
     */
    distinct?: CausaNoCumplimientoScalarFieldEnum | CausaNoCumplimientoScalarFieldEnum[]
  }

  /**
   * CausaNoCumplimiento findFirstOrThrow
   */
  export type CausaNoCumplimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * Filter, which CausaNoCumplimiento to fetch.
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CausaNoCumplimientos to fetch.
     */
    orderBy?: CausaNoCumplimientoOrderByWithRelationInput | CausaNoCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CausaNoCumplimientos.
     */
    cursor?: CausaNoCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CausaNoCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CausaNoCumplimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CausaNoCumplimientos.
     */
    distinct?: CausaNoCumplimientoScalarFieldEnum | CausaNoCumplimientoScalarFieldEnum[]
  }

  /**
   * CausaNoCumplimiento findMany
   */
  export type CausaNoCumplimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * Filter, which CausaNoCumplimientos to fetch.
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CausaNoCumplimientos to fetch.
     */
    orderBy?: CausaNoCumplimientoOrderByWithRelationInput | CausaNoCumplimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CausaNoCumplimientos.
     */
    cursor?: CausaNoCumplimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CausaNoCumplimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CausaNoCumplimientos.
     */
    skip?: number
    distinct?: CausaNoCumplimientoScalarFieldEnum | CausaNoCumplimientoScalarFieldEnum[]
  }

  /**
   * CausaNoCumplimiento create
   */
  export type CausaNoCumplimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a CausaNoCumplimiento.
     */
    data: XOR<CausaNoCumplimientoCreateInput, CausaNoCumplimientoUncheckedCreateInput>
  }

  /**
   * CausaNoCumplimiento createMany
   */
  export type CausaNoCumplimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CausaNoCumplimientos.
     */
    data: CausaNoCumplimientoCreateManyInput | CausaNoCumplimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CausaNoCumplimiento createManyAndReturn
   */
  export type CausaNoCumplimientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * The data used to create many CausaNoCumplimientos.
     */
    data: CausaNoCumplimientoCreateManyInput | CausaNoCumplimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CausaNoCumplimiento update
   */
  export type CausaNoCumplimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a CausaNoCumplimiento.
     */
    data: XOR<CausaNoCumplimientoUpdateInput, CausaNoCumplimientoUncheckedUpdateInput>
    /**
     * Choose, which CausaNoCumplimiento to update.
     */
    where: CausaNoCumplimientoWhereUniqueInput
  }

  /**
   * CausaNoCumplimiento updateMany
   */
  export type CausaNoCumplimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CausaNoCumplimientos.
     */
    data: XOR<CausaNoCumplimientoUpdateManyMutationInput, CausaNoCumplimientoUncheckedUpdateManyInput>
    /**
     * Filter which CausaNoCumplimientos to update
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * Limit how many CausaNoCumplimientos to update.
     */
    limit?: number
  }

  /**
   * CausaNoCumplimiento updateManyAndReturn
   */
  export type CausaNoCumplimientoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * The data used to update CausaNoCumplimientos.
     */
    data: XOR<CausaNoCumplimientoUpdateManyMutationInput, CausaNoCumplimientoUncheckedUpdateManyInput>
    /**
     * Filter which CausaNoCumplimientos to update
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * Limit how many CausaNoCumplimientos to update.
     */
    limit?: number
  }

  /**
   * CausaNoCumplimiento upsert
   */
  export type CausaNoCumplimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the CausaNoCumplimiento to update in case it exists.
     */
    where: CausaNoCumplimientoWhereUniqueInput
    /**
     * In case the CausaNoCumplimiento found by the `where` argument doesn't exist, create a new CausaNoCumplimiento with this data.
     */
    create: XOR<CausaNoCumplimientoCreateInput, CausaNoCumplimientoUncheckedCreateInput>
    /**
     * In case the CausaNoCumplimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CausaNoCumplimientoUpdateInput, CausaNoCumplimientoUncheckedUpdateInput>
  }

  /**
   * CausaNoCumplimiento delete
   */
  export type CausaNoCumplimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
    /**
     * Filter which CausaNoCumplimiento to delete.
     */
    where: CausaNoCumplimientoWhereUniqueInput
  }

  /**
   * CausaNoCumplimiento deleteMany
   */
  export type CausaNoCumplimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CausaNoCumplimientos to delete
     */
    where?: CausaNoCumplimientoWhereInput
    /**
     * Limit how many CausaNoCumplimientos to delete.
     */
    limit?: number
  }

  /**
   * CausaNoCumplimiento.planSemanalPartida
   */
  export type CausaNoCumplimiento$planSemanalPartidaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSemanalPartida
     */
    select?: PlanSemanalPartidaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSemanalPartida
     */
    omit?: PlanSemanalPartidaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSemanalPartidaInclude<ExtArgs> | null
    where?: PlanSemanalPartidaWhereInput
    orderBy?: PlanSemanalPartidaOrderByWithRelationInput | PlanSemanalPartidaOrderByWithRelationInput[]
    cursor?: PlanSemanalPartidaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanSemanalPartidaScalarFieldEnum | PlanSemanalPartidaScalarFieldEnum[]
  }

  /**
   * CausaNoCumplimiento without action
   */
  export type CausaNoCumplimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CausaNoCumplimiento
     */
    select?: CausaNoCumplimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CausaNoCumplimiento
     */
    omit?: CausaNoCumplimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CausaNoCumplimientoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const HitoScalarFieldEnum: {
    id_Hito: 'id_Hito',
    nombre: 'nombre',
    descripcion: 'descripcion',
    esActivo: 'esActivo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HitoScalarFieldEnum = (typeof HitoScalarFieldEnum)[keyof typeof HitoScalarFieldEnum]


  export const PaqueteTrabajoScalarFieldEnum: {
    id_PaqueteTrabajo: 'id_PaqueteTrabajo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    esActivo: 'esActivo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaqueteTrabajoScalarFieldEnum = (typeof PaqueteTrabajoScalarFieldEnum)[keyof typeof PaqueteTrabajoScalarFieldEnum]


  export const PartidaScalarFieldEnum: {
    id_Partida: 'id_Partida',
    nombre: 'nombre',
    medida: 'medida',
    ritmo: 'ritmo',
    cuadrillasSugeridas: 'cuadrillasSugeridas',
    hitoId: 'hitoId',
    procesoConstrutivoId: 'procesoConstrutivoId',
    paqueteTrabajoId: 'paqueteTrabajoId'
  };

  export type PartidaScalarFieldEnum = (typeof PartidaScalarFieldEnum)[keyof typeof PartidaScalarFieldEnum]


  export const ProcesoConstrutivoScalarFieldEnum: {
    id_ProcesoConstrutivo: 'id_ProcesoConstrutivo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    jerarquia: 'jerarquia',
    esActivo: 'esActivo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcesoConstrutivoScalarFieldEnum = (typeof ProcesoConstrutivoScalarFieldEnum)[keyof typeof ProcesoConstrutivoScalarFieldEnum]


  export const PlanMaestroScalarFieldEnum: {
    id_PlanMaestro: 'id_PlanMaestro',
    descripcion: 'descripcion',
    fechaInicio: 'fechaInicio',
    proyectoId: 'proyectoId'
  };

  export type PlanMaestroScalarFieldEnum = (typeof PlanMaestroScalarFieldEnum)[keyof typeof PlanMaestroScalarFieldEnum]


  export const PmFrenteScalarFieldEnum: {
    id_PmFrente: 'id_PmFrente',
    planMaestroId: 'planMaestroId',
    nombre: 'nombre'
  };

  export type PmFrenteScalarFieldEnum = (typeof PmFrenteScalarFieldEnum)[keyof typeof PmFrenteScalarFieldEnum]


  export const PmFrentePartidaScalarFieldEnum: {
    id_PmFrentePartida: 'id_PmFrentePartida',
    partidaId: 'partidaId',
    cuadrilla: 'cuadrilla',
    frenteId: 'frenteId',
    orden: 'orden'
  };

  export type PmFrentePartidaScalarFieldEnum = (typeof PmFrentePartidaScalarFieldEnum)[keyof typeof PmFrentePartidaScalarFieldEnum]


  export const PmProgramacionScalarFieldEnum: {
    id_PmProgramacion: 'id_PmProgramacion',
    viviendaId: 'viviendaId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    cantidad: 'cantidad',
    pmFrentePartidaId: 'pmFrentePartidaId'
  };

  export type PmProgramacionScalarFieldEnum = (typeof PmProgramacionScalarFieldEnum)[keyof typeof PmProgramacionScalarFieldEnum]


  export const EquipoCargoScalarFieldEnum: {
    id_EquipoCargo: 'id_EquipoCargo',
    nombre: 'nombre',
    esActivo: 'esActivo'
  };

  export type EquipoCargoScalarFieldEnum = (typeof EquipoCargoScalarFieldEnum)[keyof typeof EquipoCargoScalarFieldEnum]


  export const EquipoTrabajoScalarFieldEnum: {
    id_EquipoTrabajo: 'id_EquipoTrabajo',
    planMaestroId: 'planMaestroId'
  };

  export type EquipoTrabajoScalarFieldEnum = (typeof EquipoTrabajoScalarFieldEnum)[keyof typeof EquipoTrabajoScalarFieldEnum]


  export const PmEquipoScalarFieldEnum: {
    id_PmEquipo: 'id_PmEquipo',
    usuarioId: 'usuarioId',
    equipoTrabajoId: 'equipoTrabajoId',
    equipoCargoId: 'equipoCargoId'
  };

  export type PmEquipoScalarFieldEnum = (typeof PmEquipoScalarFieldEnum)[keyof typeof PmEquipoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id_Usuario: 'id_Usuario',
    nombre: 'nombre'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ModeloViviendaScalarFieldEnum: {
    id_ModeloVivienda: 'id_ModeloVivienda',
    nombre: 'nombre',
    activo: 'activo'
  };

  export type ModeloViviendaScalarFieldEnum = (typeof ModeloViviendaScalarFieldEnum)[keyof typeof ModeloViviendaScalarFieldEnum]


  export const ProyectoScalarFieldEnum: {
    id_Proyecto: 'id_Proyecto',
    nombre: 'nombre',
    activo: 'activo'
  };

  export type ProyectoScalarFieldEnum = (typeof ProyectoScalarFieldEnum)[keyof typeof ProyectoScalarFieldEnum]


  export const ViviendaScalarFieldEnum: {
    id_Vivienda: 'id_Vivienda',
    numero: 'numero',
    id_Frente: 'id_Frente',
    modeloViviendaId: 'modeloViviendaId'
  };

  export type ViviendaScalarFieldEnum = (typeof ViviendaScalarFieldEnum)[keyof typeof ViviendaScalarFieldEnum]


  export const PlanSemanalScalarFieldEnum: {
    id_PlanSemanal: 'id_PlanSemanal',
    descripcion: 'descripcion',
    fechaInicio: 'fechaInicio',
    fechaTermino: 'fechaTermino',
    pmFrenteId: 'pmFrenteId'
  };

  export type PlanSemanalScalarFieldEnum = (typeof PlanSemanalScalarFieldEnum)[keyof typeof PlanSemanalScalarFieldEnum]


  export const PlanSemanalPartidaScalarFieldEnum: {
    id_PlanSemanalPartida: 'id_PlanSemanalPartida',
    partidaId: 'partidaId',
    viviendaId: 'viviendaId',
    revisionOk: 'revisionOk',
    id_UsuarioRevision: 'id_UsuarioRevision',
    fechaRevision: 'fechaRevision',
    causaNoCumplimientoId: 'causaNoCumplimientoId',
    observacion: 'observacion',
    responsableId: 'responsableId',
    cantidadProgramada: 'cantidadProgramada',
    cantidadEjecutada: 'cantidadEjecutada',
    id_Cuadrilla: 'id_Cuadrilla'
  };

  export type PlanSemanalPartidaScalarFieldEnum = (typeof PlanSemanalPartidaScalarFieldEnum)[keyof typeof PlanSemanalPartidaScalarFieldEnum]


  export const CausaNoCumplimientoScalarFieldEnum: {
    id_CausaNoCumplimiento: 'id_CausaNoCumplimiento',
    nombre: 'nombre',
    esActivo: 'esActivo'
  };

  export type CausaNoCumplimientoScalarFieldEnum = (typeof CausaNoCumplimientoScalarFieldEnum)[keyof typeof CausaNoCumplimientoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type HitoWhereInput = {
    AND?: HitoWhereInput | HitoWhereInput[]
    OR?: HitoWhereInput[]
    NOT?: HitoWhereInput | HitoWhereInput[]
    id_Hito?: IntFilter<"Hito"> | number
    nombre?: StringFilter<"Hito"> | string
    descripcion?: StringFilter<"Hito"> | string
    esActivo?: BoolFilter<"Hito"> | boolean
    createdAt?: DateTimeFilter<"Hito"> | Date | string
    updatedAt?: DateTimeFilter<"Hito"> | Date | string
    partida?: PartidaListRelationFilter
  }

  export type HitoOrderByWithRelationInput = {
    id_Hito?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partida?: PartidaOrderByRelationAggregateInput
  }

  export type HitoWhereUniqueInput = Prisma.AtLeast<{
    id_Hito?: number
    AND?: HitoWhereInput | HitoWhereInput[]
    OR?: HitoWhereInput[]
    NOT?: HitoWhereInput | HitoWhereInput[]
    nombre?: StringFilter<"Hito"> | string
    descripcion?: StringFilter<"Hito"> | string
    esActivo?: BoolFilter<"Hito"> | boolean
    createdAt?: DateTimeFilter<"Hito"> | Date | string
    updatedAt?: DateTimeFilter<"Hito"> | Date | string
    partida?: PartidaListRelationFilter
  }, "id_Hito">

  export type HitoOrderByWithAggregationInput = {
    id_Hito?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HitoCountOrderByAggregateInput
    _avg?: HitoAvgOrderByAggregateInput
    _max?: HitoMaxOrderByAggregateInput
    _min?: HitoMinOrderByAggregateInput
    _sum?: HitoSumOrderByAggregateInput
  }

  export type HitoScalarWhereWithAggregatesInput = {
    AND?: HitoScalarWhereWithAggregatesInput | HitoScalarWhereWithAggregatesInput[]
    OR?: HitoScalarWhereWithAggregatesInput[]
    NOT?: HitoScalarWhereWithAggregatesInput | HitoScalarWhereWithAggregatesInput[]
    id_Hito?: IntWithAggregatesFilter<"Hito"> | number
    nombre?: StringWithAggregatesFilter<"Hito"> | string
    descripcion?: StringWithAggregatesFilter<"Hito"> | string
    esActivo?: BoolWithAggregatesFilter<"Hito"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Hito"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hito"> | Date | string
  }

  export type PaqueteTrabajoWhereInput = {
    AND?: PaqueteTrabajoWhereInput | PaqueteTrabajoWhereInput[]
    OR?: PaqueteTrabajoWhereInput[]
    NOT?: PaqueteTrabajoWhereInput | PaqueteTrabajoWhereInput[]
    id_PaqueteTrabajo?: IntFilter<"PaqueteTrabajo"> | number
    nombre?: StringFilter<"PaqueteTrabajo"> | string
    descripcion?: StringFilter<"PaqueteTrabajo"> | string
    esActivo?: BoolFilter<"PaqueteTrabajo"> | boolean
    createdAt?: DateTimeFilter<"PaqueteTrabajo"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTrabajo"> | Date | string
    partida?: PartidaListRelationFilter
  }

  export type PaqueteTrabajoOrderByWithRelationInput = {
    id_PaqueteTrabajo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partida?: PartidaOrderByRelationAggregateInput
  }

  export type PaqueteTrabajoWhereUniqueInput = Prisma.AtLeast<{
    id_PaqueteTrabajo?: number
    AND?: PaqueteTrabajoWhereInput | PaqueteTrabajoWhereInput[]
    OR?: PaqueteTrabajoWhereInput[]
    NOT?: PaqueteTrabajoWhereInput | PaqueteTrabajoWhereInput[]
    nombre?: StringFilter<"PaqueteTrabajo"> | string
    descripcion?: StringFilter<"PaqueteTrabajo"> | string
    esActivo?: BoolFilter<"PaqueteTrabajo"> | boolean
    createdAt?: DateTimeFilter<"PaqueteTrabajo"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTrabajo"> | Date | string
    partida?: PartidaListRelationFilter
  }, "id_PaqueteTrabajo">

  export type PaqueteTrabajoOrderByWithAggregationInput = {
    id_PaqueteTrabajo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaqueteTrabajoCountOrderByAggregateInput
    _avg?: PaqueteTrabajoAvgOrderByAggregateInput
    _max?: PaqueteTrabajoMaxOrderByAggregateInput
    _min?: PaqueteTrabajoMinOrderByAggregateInput
    _sum?: PaqueteTrabajoSumOrderByAggregateInput
  }

  export type PaqueteTrabajoScalarWhereWithAggregatesInput = {
    AND?: PaqueteTrabajoScalarWhereWithAggregatesInput | PaqueteTrabajoScalarWhereWithAggregatesInput[]
    OR?: PaqueteTrabajoScalarWhereWithAggregatesInput[]
    NOT?: PaqueteTrabajoScalarWhereWithAggregatesInput | PaqueteTrabajoScalarWhereWithAggregatesInput[]
    id_PaqueteTrabajo?: IntWithAggregatesFilter<"PaqueteTrabajo"> | number
    nombre?: StringWithAggregatesFilter<"PaqueteTrabajo"> | string
    descripcion?: StringWithAggregatesFilter<"PaqueteTrabajo"> | string
    esActivo?: BoolWithAggregatesFilter<"PaqueteTrabajo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaqueteTrabajo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaqueteTrabajo"> | Date | string
  }

  export type PartidaWhereInput = {
    AND?: PartidaWhereInput | PartidaWhereInput[]
    OR?: PartidaWhereInput[]
    NOT?: PartidaWhereInput | PartidaWhereInput[]
    id_Partida?: IntFilter<"Partida"> | number
    nombre?: StringFilter<"Partida"> | string
    medida?: StringFilter<"Partida"> | string
    ritmo?: StringFilter<"Partida"> | string
    cuadrillasSugeridas?: IntFilter<"Partida"> | number
    hitoId?: IntFilter<"Partida"> | number
    procesoConstrutivoId?: IntFilter<"Partida"> | number
    paqueteTrabajoId?: IntFilter<"Partida"> | number
    hito?: XOR<HitoScalarRelationFilter, HitoWhereInput>
    procesoConstrutivo?: XOR<ProcesoConstrutivoScalarRelationFilter, ProcesoConstrutivoWhereInput>
    paqueteTrabajo?: XOR<PaqueteTrabajoScalarRelationFilter, PaqueteTrabajoWhereInput>
    pmFrentePartidas?: PmFrentePartidaListRelationFilter
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
  }

  export type PartidaOrderByWithRelationInput = {
    id_Partida?: SortOrder
    nombre?: SortOrder
    medida?: SortOrder
    ritmo?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
    hito?: HitoOrderByWithRelationInput
    procesoConstrutivo?: ProcesoConstrutivoOrderByWithRelationInput
    paqueteTrabajo?: PaqueteTrabajoOrderByWithRelationInput
    pmFrentePartidas?: PmFrentePartidaOrderByRelationAggregateInput
    planSemanalPartida?: PlanSemanalPartidaOrderByRelationAggregateInput
  }

  export type PartidaWhereUniqueInput = Prisma.AtLeast<{
    id_Partida?: number
    AND?: PartidaWhereInput | PartidaWhereInput[]
    OR?: PartidaWhereInput[]
    NOT?: PartidaWhereInput | PartidaWhereInput[]
    nombre?: StringFilter<"Partida"> | string
    medida?: StringFilter<"Partida"> | string
    ritmo?: StringFilter<"Partida"> | string
    cuadrillasSugeridas?: IntFilter<"Partida"> | number
    hitoId?: IntFilter<"Partida"> | number
    procesoConstrutivoId?: IntFilter<"Partida"> | number
    paqueteTrabajoId?: IntFilter<"Partida"> | number
    hito?: XOR<HitoScalarRelationFilter, HitoWhereInput>
    procesoConstrutivo?: XOR<ProcesoConstrutivoScalarRelationFilter, ProcesoConstrutivoWhereInput>
    paqueteTrabajo?: XOR<PaqueteTrabajoScalarRelationFilter, PaqueteTrabajoWhereInput>
    pmFrentePartidas?: PmFrentePartidaListRelationFilter
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
  }, "id_Partida">

  export type PartidaOrderByWithAggregationInput = {
    id_Partida?: SortOrder
    nombre?: SortOrder
    medida?: SortOrder
    ritmo?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
    _count?: PartidaCountOrderByAggregateInput
    _avg?: PartidaAvgOrderByAggregateInput
    _max?: PartidaMaxOrderByAggregateInput
    _min?: PartidaMinOrderByAggregateInput
    _sum?: PartidaSumOrderByAggregateInput
  }

  export type PartidaScalarWhereWithAggregatesInput = {
    AND?: PartidaScalarWhereWithAggregatesInput | PartidaScalarWhereWithAggregatesInput[]
    OR?: PartidaScalarWhereWithAggregatesInput[]
    NOT?: PartidaScalarWhereWithAggregatesInput | PartidaScalarWhereWithAggregatesInput[]
    id_Partida?: IntWithAggregatesFilter<"Partida"> | number
    nombre?: StringWithAggregatesFilter<"Partida"> | string
    medida?: StringWithAggregatesFilter<"Partida"> | string
    ritmo?: StringWithAggregatesFilter<"Partida"> | string
    cuadrillasSugeridas?: IntWithAggregatesFilter<"Partida"> | number
    hitoId?: IntWithAggregatesFilter<"Partida"> | number
    procesoConstrutivoId?: IntWithAggregatesFilter<"Partida"> | number
    paqueteTrabajoId?: IntWithAggregatesFilter<"Partida"> | number
  }

  export type ProcesoConstrutivoWhereInput = {
    AND?: ProcesoConstrutivoWhereInput | ProcesoConstrutivoWhereInput[]
    OR?: ProcesoConstrutivoWhereInput[]
    NOT?: ProcesoConstrutivoWhereInput | ProcesoConstrutivoWhereInput[]
    id_ProcesoConstrutivo?: IntFilter<"ProcesoConstrutivo"> | number
    nombre?: StringFilter<"ProcesoConstrutivo"> | string
    descripcion?: StringFilter<"ProcesoConstrutivo"> | string
    jerarquia?: IntFilter<"ProcesoConstrutivo"> | number
    esActivo?: BoolFilter<"ProcesoConstrutivo"> | boolean
    createdAt?: DateTimeFilter<"ProcesoConstrutivo"> | Date | string
    updatedAt?: DateTimeFilter<"ProcesoConstrutivo"> | Date | string
    partida?: PartidaListRelationFilter
  }

  export type ProcesoConstrutivoOrderByWithRelationInput = {
    id_ProcesoConstrutivo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    jerarquia?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partida?: PartidaOrderByRelationAggregateInput
  }

  export type ProcesoConstrutivoWhereUniqueInput = Prisma.AtLeast<{
    id_ProcesoConstrutivo?: number
    AND?: ProcesoConstrutivoWhereInput | ProcesoConstrutivoWhereInput[]
    OR?: ProcesoConstrutivoWhereInput[]
    NOT?: ProcesoConstrutivoWhereInput | ProcesoConstrutivoWhereInput[]
    nombre?: StringFilter<"ProcesoConstrutivo"> | string
    descripcion?: StringFilter<"ProcesoConstrutivo"> | string
    jerarquia?: IntFilter<"ProcesoConstrutivo"> | number
    esActivo?: BoolFilter<"ProcesoConstrutivo"> | boolean
    createdAt?: DateTimeFilter<"ProcesoConstrutivo"> | Date | string
    updatedAt?: DateTimeFilter<"ProcesoConstrutivo"> | Date | string
    partida?: PartidaListRelationFilter
  }, "id_ProcesoConstrutivo">

  export type ProcesoConstrutivoOrderByWithAggregationInput = {
    id_ProcesoConstrutivo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    jerarquia?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcesoConstrutivoCountOrderByAggregateInput
    _avg?: ProcesoConstrutivoAvgOrderByAggregateInput
    _max?: ProcesoConstrutivoMaxOrderByAggregateInput
    _min?: ProcesoConstrutivoMinOrderByAggregateInput
    _sum?: ProcesoConstrutivoSumOrderByAggregateInput
  }

  export type ProcesoConstrutivoScalarWhereWithAggregatesInput = {
    AND?: ProcesoConstrutivoScalarWhereWithAggregatesInput | ProcesoConstrutivoScalarWhereWithAggregatesInput[]
    OR?: ProcesoConstrutivoScalarWhereWithAggregatesInput[]
    NOT?: ProcesoConstrutivoScalarWhereWithAggregatesInput | ProcesoConstrutivoScalarWhereWithAggregatesInput[]
    id_ProcesoConstrutivo?: IntWithAggregatesFilter<"ProcesoConstrutivo"> | number
    nombre?: StringWithAggregatesFilter<"ProcesoConstrutivo"> | string
    descripcion?: StringWithAggregatesFilter<"ProcesoConstrutivo"> | string
    jerarquia?: IntWithAggregatesFilter<"ProcesoConstrutivo"> | number
    esActivo?: BoolWithAggregatesFilter<"ProcesoConstrutivo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProcesoConstrutivo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcesoConstrutivo"> | Date | string
  }

  export type PlanMaestroWhereInput = {
    AND?: PlanMaestroWhereInput | PlanMaestroWhereInput[]
    OR?: PlanMaestroWhereInput[]
    NOT?: PlanMaestroWhereInput | PlanMaestroWhereInput[]
    id_PlanMaestro?: IntFilter<"PlanMaestro"> | number
    descripcion?: StringFilter<"PlanMaestro"> | string
    fechaInicio?: DateTimeFilter<"PlanMaestro"> | Date | string
    proyectoId?: IntFilter<"PlanMaestro"> | number
    proyecto?: XOR<ProyectoScalarRelationFilter, ProyectoWhereInput>
    equipoTrabajos?: EquipoTrabajoListRelationFilter
    pmFrentes?: PmFrenteListRelationFilter
  }

  export type PlanMaestroOrderByWithRelationInput = {
    id_PlanMaestro?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    proyectoId?: SortOrder
    proyecto?: ProyectoOrderByWithRelationInput
    equipoTrabajos?: EquipoTrabajoOrderByRelationAggregateInput
    pmFrentes?: PmFrenteOrderByRelationAggregateInput
  }

  export type PlanMaestroWhereUniqueInput = Prisma.AtLeast<{
    id_PlanMaestro?: number
    AND?: PlanMaestroWhereInput | PlanMaestroWhereInput[]
    OR?: PlanMaestroWhereInput[]
    NOT?: PlanMaestroWhereInput | PlanMaestroWhereInput[]
    descripcion?: StringFilter<"PlanMaestro"> | string
    fechaInicio?: DateTimeFilter<"PlanMaestro"> | Date | string
    proyectoId?: IntFilter<"PlanMaestro"> | number
    proyecto?: XOR<ProyectoScalarRelationFilter, ProyectoWhereInput>
    equipoTrabajos?: EquipoTrabajoListRelationFilter
    pmFrentes?: PmFrenteListRelationFilter
  }, "id_PlanMaestro">

  export type PlanMaestroOrderByWithAggregationInput = {
    id_PlanMaestro?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    proyectoId?: SortOrder
    _count?: PlanMaestroCountOrderByAggregateInput
    _avg?: PlanMaestroAvgOrderByAggregateInput
    _max?: PlanMaestroMaxOrderByAggregateInput
    _min?: PlanMaestroMinOrderByAggregateInput
    _sum?: PlanMaestroSumOrderByAggregateInput
  }

  export type PlanMaestroScalarWhereWithAggregatesInput = {
    AND?: PlanMaestroScalarWhereWithAggregatesInput | PlanMaestroScalarWhereWithAggregatesInput[]
    OR?: PlanMaestroScalarWhereWithAggregatesInput[]
    NOT?: PlanMaestroScalarWhereWithAggregatesInput | PlanMaestroScalarWhereWithAggregatesInput[]
    id_PlanMaestro?: IntWithAggregatesFilter<"PlanMaestro"> | number
    descripcion?: StringWithAggregatesFilter<"PlanMaestro"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"PlanMaestro"> | Date | string
    proyectoId?: IntWithAggregatesFilter<"PlanMaestro"> | number
  }

  export type PmFrenteWhereInput = {
    AND?: PmFrenteWhereInput | PmFrenteWhereInput[]
    OR?: PmFrenteWhereInput[]
    NOT?: PmFrenteWhereInput | PmFrenteWhereInput[]
    id_PmFrente?: IntFilter<"PmFrente"> | number
    planMaestroId?: IntFilter<"PmFrente"> | number
    nombre?: StringFilter<"PmFrente"> | string
    planMaestro?: XOR<PlanMaestroScalarRelationFilter, PlanMaestroWhereInput>
    pmFrentePartidas?: PmFrentePartidaListRelationFilter
    planSemanal?: PlanSemanalListRelationFilter
  }

  export type PmFrenteOrderByWithRelationInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
    nombre?: SortOrder
    planMaestro?: PlanMaestroOrderByWithRelationInput
    pmFrentePartidas?: PmFrentePartidaOrderByRelationAggregateInput
    planSemanal?: PlanSemanalOrderByRelationAggregateInput
  }

  export type PmFrenteWhereUniqueInput = Prisma.AtLeast<{
    id_PmFrente?: number
    AND?: PmFrenteWhereInput | PmFrenteWhereInput[]
    OR?: PmFrenteWhereInput[]
    NOT?: PmFrenteWhereInput | PmFrenteWhereInput[]
    planMaestroId?: IntFilter<"PmFrente"> | number
    nombre?: StringFilter<"PmFrente"> | string
    planMaestro?: XOR<PlanMaestroScalarRelationFilter, PlanMaestroWhereInput>
    pmFrentePartidas?: PmFrentePartidaListRelationFilter
    planSemanal?: PlanSemanalListRelationFilter
  }, "id_PmFrente">

  export type PmFrenteOrderByWithAggregationInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
    nombre?: SortOrder
    _count?: PmFrenteCountOrderByAggregateInput
    _avg?: PmFrenteAvgOrderByAggregateInput
    _max?: PmFrenteMaxOrderByAggregateInput
    _min?: PmFrenteMinOrderByAggregateInput
    _sum?: PmFrenteSumOrderByAggregateInput
  }

  export type PmFrenteScalarWhereWithAggregatesInput = {
    AND?: PmFrenteScalarWhereWithAggregatesInput | PmFrenteScalarWhereWithAggregatesInput[]
    OR?: PmFrenteScalarWhereWithAggregatesInput[]
    NOT?: PmFrenteScalarWhereWithAggregatesInput | PmFrenteScalarWhereWithAggregatesInput[]
    id_PmFrente?: IntWithAggregatesFilter<"PmFrente"> | number
    planMaestroId?: IntWithAggregatesFilter<"PmFrente"> | number
    nombre?: StringWithAggregatesFilter<"PmFrente"> | string
  }

  export type PmFrentePartidaWhereInput = {
    AND?: PmFrentePartidaWhereInput | PmFrentePartidaWhereInput[]
    OR?: PmFrentePartidaWhereInput[]
    NOT?: PmFrentePartidaWhereInput | PmFrentePartidaWhereInput[]
    id_PmFrentePartida?: IntFilter<"PmFrentePartida"> | number
    partidaId?: IntFilter<"PmFrentePartida"> | number
    cuadrilla?: IntFilter<"PmFrentePartida"> | number
    frenteId?: IntFilter<"PmFrentePartida"> | number
    orden?: IntFilter<"PmFrentePartida"> | number
    partida?: XOR<PartidaScalarRelationFilter, PartidaWhereInput>
    frente?: XOR<PmFrenteScalarRelationFilter, PmFrenteWhereInput>
    pmProgramacion?: PmProgramacionListRelationFilter
  }

  export type PmFrentePartidaOrderByWithRelationInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
    partida?: PartidaOrderByWithRelationInput
    frente?: PmFrenteOrderByWithRelationInput
    pmProgramacion?: PmProgramacionOrderByRelationAggregateInput
  }

  export type PmFrentePartidaWhereUniqueInput = Prisma.AtLeast<{
    id_PmFrentePartida?: number
    AND?: PmFrentePartidaWhereInput | PmFrentePartidaWhereInput[]
    OR?: PmFrentePartidaWhereInput[]
    NOT?: PmFrentePartidaWhereInput | PmFrentePartidaWhereInput[]
    partidaId?: IntFilter<"PmFrentePartida"> | number
    cuadrilla?: IntFilter<"PmFrentePartida"> | number
    frenteId?: IntFilter<"PmFrentePartida"> | number
    orden?: IntFilter<"PmFrentePartida"> | number
    partida?: XOR<PartidaScalarRelationFilter, PartidaWhereInput>
    frente?: XOR<PmFrenteScalarRelationFilter, PmFrenteWhereInput>
    pmProgramacion?: PmProgramacionListRelationFilter
  }, "id_PmFrentePartida">

  export type PmFrentePartidaOrderByWithAggregationInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
    _count?: PmFrentePartidaCountOrderByAggregateInput
    _avg?: PmFrentePartidaAvgOrderByAggregateInput
    _max?: PmFrentePartidaMaxOrderByAggregateInput
    _min?: PmFrentePartidaMinOrderByAggregateInput
    _sum?: PmFrentePartidaSumOrderByAggregateInput
  }

  export type PmFrentePartidaScalarWhereWithAggregatesInput = {
    AND?: PmFrentePartidaScalarWhereWithAggregatesInput | PmFrentePartidaScalarWhereWithAggregatesInput[]
    OR?: PmFrentePartidaScalarWhereWithAggregatesInput[]
    NOT?: PmFrentePartidaScalarWhereWithAggregatesInput | PmFrentePartidaScalarWhereWithAggregatesInput[]
    id_PmFrentePartida?: IntWithAggregatesFilter<"PmFrentePartida"> | number
    partidaId?: IntWithAggregatesFilter<"PmFrentePartida"> | number
    cuadrilla?: IntWithAggregatesFilter<"PmFrentePartida"> | number
    frenteId?: IntWithAggregatesFilter<"PmFrentePartida"> | number
    orden?: IntWithAggregatesFilter<"PmFrentePartida"> | number
  }

  export type PmProgramacionWhereInput = {
    AND?: PmProgramacionWhereInput | PmProgramacionWhereInput[]
    OR?: PmProgramacionWhereInput[]
    NOT?: PmProgramacionWhereInput | PmProgramacionWhereInput[]
    id_PmProgramacion?: IntFilter<"PmProgramacion"> | number
    viviendaId?: IntFilter<"PmProgramacion"> | number
    fechaInicio?: DateTimeFilter<"PmProgramacion"> | Date | string
    fechaFin?: DateTimeFilter<"PmProgramacion"> | Date | string
    cantidad?: IntFilter<"PmProgramacion"> | number
    pmFrentePartidaId?: IntFilter<"PmProgramacion"> | number
    vivienda?: XOR<ViviendaScalarRelationFilter, ViviendaWhereInput>
    pmFrentePartida?: XOR<PmFrentePartidaScalarRelationFilter, PmFrentePartidaWhereInput>
  }

  export type PmProgramacionOrderByWithRelationInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
    vivienda?: ViviendaOrderByWithRelationInput
    pmFrentePartida?: PmFrentePartidaOrderByWithRelationInput
  }

  export type PmProgramacionWhereUniqueInput = Prisma.AtLeast<{
    id_PmProgramacion?: number
    AND?: PmProgramacionWhereInput | PmProgramacionWhereInput[]
    OR?: PmProgramacionWhereInput[]
    NOT?: PmProgramacionWhereInput | PmProgramacionWhereInput[]
    viviendaId?: IntFilter<"PmProgramacion"> | number
    fechaInicio?: DateTimeFilter<"PmProgramacion"> | Date | string
    fechaFin?: DateTimeFilter<"PmProgramacion"> | Date | string
    cantidad?: IntFilter<"PmProgramacion"> | number
    pmFrentePartidaId?: IntFilter<"PmProgramacion"> | number
    vivienda?: XOR<ViviendaScalarRelationFilter, ViviendaWhereInput>
    pmFrentePartida?: XOR<PmFrentePartidaScalarRelationFilter, PmFrentePartidaWhereInput>
  }, "id_PmProgramacion">

  export type PmProgramacionOrderByWithAggregationInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
    _count?: PmProgramacionCountOrderByAggregateInput
    _avg?: PmProgramacionAvgOrderByAggregateInput
    _max?: PmProgramacionMaxOrderByAggregateInput
    _min?: PmProgramacionMinOrderByAggregateInput
    _sum?: PmProgramacionSumOrderByAggregateInput
  }

  export type PmProgramacionScalarWhereWithAggregatesInput = {
    AND?: PmProgramacionScalarWhereWithAggregatesInput | PmProgramacionScalarWhereWithAggregatesInput[]
    OR?: PmProgramacionScalarWhereWithAggregatesInput[]
    NOT?: PmProgramacionScalarWhereWithAggregatesInput | PmProgramacionScalarWhereWithAggregatesInput[]
    id_PmProgramacion?: IntWithAggregatesFilter<"PmProgramacion"> | number
    viviendaId?: IntWithAggregatesFilter<"PmProgramacion"> | number
    fechaInicio?: DateTimeWithAggregatesFilter<"PmProgramacion"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"PmProgramacion"> | Date | string
    cantidad?: IntWithAggregatesFilter<"PmProgramacion"> | number
    pmFrentePartidaId?: IntWithAggregatesFilter<"PmProgramacion"> | number
  }

  export type EquipoCargoWhereInput = {
    AND?: EquipoCargoWhereInput | EquipoCargoWhereInput[]
    OR?: EquipoCargoWhereInput[]
    NOT?: EquipoCargoWhereInput | EquipoCargoWhereInput[]
    id_EquipoCargo?: IntFilter<"EquipoCargo"> | number
    nombre?: StringFilter<"EquipoCargo"> | string
    esActivo?: BoolFilter<"EquipoCargo"> | boolean
    pmEquipo?: PmEquipoListRelationFilter
  }

  export type EquipoCargoOrderByWithRelationInput = {
    id_EquipoCargo?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
    pmEquipo?: PmEquipoOrderByRelationAggregateInput
  }

  export type EquipoCargoWhereUniqueInput = Prisma.AtLeast<{
    id_EquipoCargo?: number
    AND?: EquipoCargoWhereInput | EquipoCargoWhereInput[]
    OR?: EquipoCargoWhereInput[]
    NOT?: EquipoCargoWhereInput | EquipoCargoWhereInput[]
    nombre?: StringFilter<"EquipoCargo"> | string
    esActivo?: BoolFilter<"EquipoCargo"> | boolean
    pmEquipo?: PmEquipoListRelationFilter
  }, "id_EquipoCargo">

  export type EquipoCargoOrderByWithAggregationInput = {
    id_EquipoCargo?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
    _count?: EquipoCargoCountOrderByAggregateInput
    _avg?: EquipoCargoAvgOrderByAggregateInput
    _max?: EquipoCargoMaxOrderByAggregateInput
    _min?: EquipoCargoMinOrderByAggregateInput
    _sum?: EquipoCargoSumOrderByAggregateInput
  }

  export type EquipoCargoScalarWhereWithAggregatesInput = {
    AND?: EquipoCargoScalarWhereWithAggregatesInput | EquipoCargoScalarWhereWithAggregatesInput[]
    OR?: EquipoCargoScalarWhereWithAggregatesInput[]
    NOT?: EquipoCargoScalarWhereWithAggregatesInput | EquipoCargoScalarWhereWithAggregatesInput[]
    id_EquipoCargo?: IntWithAggregatesFilter<"EquipoCargo"> | number
    nombre?: StringWithAggregatesFilter<"EquipoCargo"> | string
    esActivo?: BoolWithAggregatesFilter<"EquipoCargo"> | boolean
  }

  export type EquipoTrabajoWhereInput = {
    AND?: EquipoTrabajoWhereInput | EquipoTrabajoWhereInput[]
    OR?: EquipoTrabajoWhereInput[]
    NOT?: EquipoTrabajoWhereInput | EquipoTrabajoWhereInput[]
    id_EquipoTrabajo?: IntFilter<"EquipoTrabajo"> | number
    planMaestroId?: IntFilter<"EquipoTrabajo"> | number
    PlanMaestro?: XOR<PlanMaestroScalarRelationFilter, PlanMaestroWhereInput>
    pmEquipo?: PmEquipoListRelationFilter
  }

  export type EquipoTrabajoOrderByWithRelationInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
    PlanMaestro?: PlanMaestroOrderByWithRelationInput
    pmEquipo?: PmEquipoOrderByRelationAggregateInput
  }

  export type EquipoTrabajoWhereUniqueInput = Prisma.AtLeast<{
    id_EquipoTrabajo?: number
    AND?: EquipoTrabajoWhereInput | EquipoTrabajoWhereInput[]
    OR?: EquipoTrabajoWhereInput[]
    NOT?: EquipoTrabajoWhereInput | EquipoTrabajoWhereInput[]
    planMaestroId?: IntFilter<"EquipoTrabajo"> | number
    PlanMaestro?: XOR<PlanMaestroScalarRelationFilter, PlanMaestroWhereInput>
    pmEquipo?: PmEquipoListRelationFilter
  }, "id_EquipoTrabajo">

  export type EquipoTrabajoOrderByWithAggregationInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
    _count?: EquipoTrabajoCountOrderByAggregateInput
    _avg?: EquipoTrabajoAvgOrderByAggregateInput
    _max?: EquipoTrabajoMaxOrderByAggregateInput
    _min?: EquipoTrabajoMinOrderByAggregateInput
    _sum?: EquipoTrabajoSumOrderByAggregateInput
  }

  export type EquipoTrabajoScalarWhereWithAggregatesInput = {
    AND?: EquipoTrabajoScalarWhereWithAggregatesInput | EquipoTrabajoScalarWhereWithAggregatesInput[]
    OR?: EquipoTrabajoScalarWhereWithAggregatesInput[]
    NOT?: EquipoTrabajoScalarWhereWithAggregatesInput | EquipoTrabajoScalarWhereWithAggregatesInput[]
    id_EquipoTrabajo?: IntWithAggregatesFilter<"EquipoTrabajo"> | number
    planMaestroId?: IntWithAggregatesFilter<"EquipoTrabajo"> | number
  }

  export type PmEquipoWhereInput = {
    AND?: PmEquipoWhereInput | PmEquipoWhereInput[]
    OR?: PmEquipoWhereInput[]
    NOT?: PmEquipoWhereInput | PmEquipoWhereInput[]
    id_PmEquipo?: IntFilter<"PmEquipo"> | number
    usuarioId?: IntFilter<"PmEquipo"> | number
    equipoTrabajoId?: IntFilter<"PmEquipo"> | number
    equipoCargoId?: IntFilter<"PmEquipo"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    equipoTrabajo?: XOR<EquipoTrabajoScalarRelationFilter, EquipoTrabajoWhereInput>
    equipoCargo?: XOR<EquipoCargoScalarRelationFilter, EquipoCargoWhereInput>
  }

  export type PmEquipoOrderByWithRelationInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    equipoTrabajo?: EquipoTrabajoOrderByWithRelationInput
    equipoCargo?: EquipoCargoOrderByWithRelationInput
  }

  export type PmEquipoWhereUniqueInput = Prisma.AtLeast<{
    id_PmEquipo?: number
    AND?: PmEquipoWhereInput | PmEquipoWhereInput[]
    OR?: PmEquipoWhereInput[]
    NOT?: PmEquipoWhereInput | PmEquipoWhereInput[]
    usuarioId?: IntFilter<"PmEquipo"> | number
    equipoTrabajoId?: IntFilter<"PmEquipo"> | number
    equipoCargoId?: IntFilter<"PmEquipo"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    equipoTrabajo?: XOR<EquipoTrabajoScalarRelationFilter, EquipoTrabajoWhereInput>
    equipoCargo?: XOR<EquipoCargoScalarRelationFilter, EquipoCargoWhereInput>
  }, "id_PmEquipo">

  export type PmEquipoOrderByWithAggregationInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
    _count?: PmEquipoCountOrderByAggregateInput
    _avg?: PmEquipoAvgOrderByAggregateInput
    _max?: PmEquipoMaxOrderByAggregateInput
    _min?: PmEquipoMinOrderByAggregateInput
    _sum?: PmEquipoSumOrderByAggregateInput
  }

  export type PmEquipoScalarWhereWithAggregatesInput = {
    AND?: PmEquipoScalarWhereWithAggregatesInput | PmEquipoScalarWhereWithAggregatesInput[]
    OR?: PmEquipoScalarWhereWithAggregatesInput[]
    NOT?: PmEquipoScalarWhereWithAggregatesInput | PmEquipoScalarWhereWithAggregatesInput[]
    id_PmEquipo?: IntWithAggregatesFilter<"PmEquipo"> | number
    usuarioId?: IntWithAggregatesFilter<"PmEquipo"> | number
    equipoTrabajoId?: IntWithAggregatesFilter<"PmEquipo"> | number
    equipoCargoId?: IntWithAggregatesFilter<"PmEquipo"> | number
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id_Usuario?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    pmEquipo?: PmEquipoListRelationFilter
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id_Usuario?: SortOrder
    nombre?: SortOrder
    pmEquipo?: PmEquipoOrderByRelationAggregateInput
    planSemanalPartida?: PlanSemanalPartidaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id_Usuario?: number
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    pmEquipo?: PmEquipoListRelationFilter
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
  }, "id_Usuario">

  export type UsuarioOrderByWithAggregationInput = {
    id_Usuario?: SortOrder
    nombre?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id_Usuario?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
  }

  export type ModeloViviendaWhereInput = {
    AND?: ModeloViviendaWhereInput | ModeloViviendaWhereInput[]
    OR?: ModeloViviendaWhereInput[]
    NOT?: ModeloViviendaWhereInput | ModeloViviendaWhereInput[]
    id_ModeloVivienda?: IntFilter<"ModeloVivienda"> | number
    nombre?: StringFilter<"ModeloVivienda"> | string
    activo?: BoolFilter<"ModeloVivienda"> | boolean
    vivienda?: ViviendaListRelationFilter
  }

  export type ModeloViviendaOrderByWithRelationInput = {
    id_ModeloVivienda?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    vivienda?: ViviendaOrderByRelationAggregateInput
  }

  export type ModeloViviendaWhereUniqueInput = Prisma.AtLeast<{
    id_ModeloVivienda?: number
    AND?: ModeloViviendaWhereInput | ModeloViviendaWhereInput[]
    OR?: ModeloViviendaWhereInput[]
    NOT?: ModeloViviendaWhereInput | ModeloViviendaWhereInput[]
    nombre?: StringFilter<"ModeloVivienda"> | string
    activo?: BoolFilter<"ModeloVivienda"> | boolean
    vivienda?: ViviendaListRelationFilter
  }, "id_ModeloVivienda">

  export type ModeloViviendaOrderByWithAggregationInput = {
    id_ModeloVivienda?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    _count?: ModeloViviendaCountOrderByAggregateInput
    _avg?: ModeloViviendaAvgOrderByAggregateInput
    _max?: ModeloViviendaMaxOrderByAggregateInput
    _min?: ModeloViviendaMinOrderByAggregateInput
    _sum?: ModeloViviendaSumOrderByAggregateInput
  }

  export type ModeloViviendaScalarWhereWithAggregatesInput = {
    AND?: ModeloViviendaScalarWhereWithAggregatesInput | ModeloViviendaScalarWhereWithAggregatesInput[]
    OR?: ModeloViviendaScalarWhereWithAggregatesInput[]
    NOT?: ModeloViviendaScalarWhereWithAggregatesInput | ModeloViviendaScalarWhereWithAggregatesInput[]
    id_ModeloVivienda?: IntWithAggregatesFilter<"ModeloVivienda"> | number
    nombre?: StringWithAggregatesFilter<"ModeloVivienda"> | string
    activo?: BoolWithAggregatesFilter<"ModeloVivienda"> | boolean
  }

  export type ProyectoWhereInput = {
    AND?: ProyectoWhereInput | ProyectoWhereInput[]
    OR?: ProyectoWhereInput[]
    NOT?: ProyectoWhereInput | ProyectoWhereInput[]
    id_Proyecto?: IntFilter<"Proyecto"> | number
    nombre?: StringFilter<"Proyecto"> | string
    activo?: BoolFilter<"Proyecto"> | boolean
    planMaestro?: PlanMaestroListRelationFilter
  }

  export type ProyectoOrderByWithRelationInput = {
    id_Proyecto?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    planMaestro?: PlanMaestroOrderByRelationAggregateInput
  }

  export type ProyectoWhereUniqueInput = Prisma.AtLeast<{
    id_Proyecto?: number
    AND?: ProyectoWhereInput | ProyectoWhereInput[]
    OR?: ProyectoWhereInput[]
    NOT?: ProyectoWhereInput | ProyectoWhereInput[]
    nombre?: StringFilter<"Proyecto"> | string
    activo?: BoolFilter<"Proyecto"> | boolean
    planMaestro?: PlanMaestroListRelationFilter
  }, "id_Proyecto">

  export type ProyectoOrderByWithAggregationInput = {
    id_Proyecto?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
    _count?: ProyectoCountOrderByAggregateInput
    _avg?: ProyectoAvgOrderByAggregateInput
    _max?: ProyectoMaxOrderByAggregateInput
    _min?: ProyectoMinOrderByAggregateInput
    _sum?: ProyectoSumOrderByAggregateInput
  }

  export type ProyectoScalarWhereWithAggregatesInput = {
    AND?: ProyectoScalarWhereWithAggregatesInput | ProyectoScalarWhereWithAggregatesInput[]
    OR?: ProyectoScalarWhereWithAggregatesInput[]
    NOT?: ProyectoScalarWhereWithAggregatesInput | ProyectoScalarWhereWithAggregatesInput[]
    id_Proyecto?: IntWithAggregatesFilter<"Proyecto"> | number
    nombre?: StringWithAggregatesFilter<"Proyecto"> | string
    activo?: BoolWithAggregatesFilter<"Proyecto"> | boolean
  }

  export type ViviendaWhereInput = {
    AND?: ViviendaWhereInput | ViviendaWhereInput[]
    OR?: ViviendaWhereInput[]
    NOT?: ViviendaWhereInput | ViviendaWhereInput[]
    id_Vivienda?: IntFilter<"Vivienda"> | number
    numero?: StringFilter<"Vivienda"> | string
    id_Frente?: StringFilter<"Vivienda"> | string
    modeloViviendaId?: IntFilter<"Vivienda"> | number
    modeloVivienda?: XOR<ModeloViviendaScalarRelationFilter, ModeloViviendaWhereInput>
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
    pmProgramacion?: PmProgramacionListRelationFilter
  }

  export type ViviendaOrderByWithRelationInput = {
    id_Vivienda?: SortOrder
    numero?: SortOrder
    id_Frente?: SortOrder
    modeloViviendaId?: SortOrder
    modeloVivienda?: ModeloViviendaOrderByWithRelationInput
    planSemanalPartida?: PlanSemanalPartidaOrderByRelationAggregateInput
    pmProgramacion?: PmProgramacionOrderByRelationAggregateInput
  }

  export type ViviendaWhereUniqueInput = Prisma.AtLeast<{
    id_Vivienda?: number
    AND?: ViviendaWhereInput | ViviendaWhereInput[]
    OR?: ViviendaWhereInput[]
    NOT?: ViviendaWhereInput | ViviendaWhereInput[]
    numero?: StringFilter<"Vivienda"> | string
    id_Frente?: StringFilter<"Vivienda"> | string
    modeloViviendaId?: IntFilter<"Vivienda"> | number
    modeloVivienda?: XOR<ModeloViviendaScalarRelationFilter, ModeloViviendaWhereInput>
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
    pmProgramacion?: PmProgramacionListRelationFilter
  }, "id_Vivienda">

  export type ViviendaOrderByWithAggregationInput = {
    id_Vivienda?: SortOrder
    numero?: SortOrder
    id_Frente?: SortOrder
    modeloViviendaId?: SortOrder
    _count?: ViviendaCountOrderByAggregateInput
    _avg?: ViviendaAvgOrderByAggregateInput
    _max?: ViviendaMaxOrderByAggregateInput
    _min?: ViviendaMinOrderByAggregateInput
    _sum?: ViviendaSumOrderByAggregateInput
  }

  export type ViviendaScalarWhereWithAggregatesInput = {
    AND?: ViviendaScalarWhereWithAggregatesInput | ViviendaScalarWhereWithAggregatesInput[]
    OR?: ViviendaScalarWhereWithAggregatesInput[]
    NOT?: ViviendaScalarWhereWithAggregatesInput | ViviendaScalarWhereWithAggregatesInput[]
    id_Vivienda?: IntWithAggregatesFilter<"Vivienda"> | number
    numero?: StringWithAggregatesFilter<"Vivienda"> | string
    id_Frente?: StringWithAggregatesFilter<"Vivienda"> | string
    modeloViviendaId?: IntWithAggregatesFilter<"Vivienda"> | number
  }

  export type PlanSemanalWhereInput = {
    AND?: PlanSemanalWhereInput | PlanSemanalWhereInput[]
    OR?: PlanSemanalWhereInput[]
    NOT?: PlanSemanalWhereInput | PlanSemanalWhereInput[]
    id_PlanSemanal?: IntFilter<"PlanSemanal"> | number
    descripcion?: StringFilter<"PlanSemanal"> | string
    fechaInicio?: DateTimeFilter<"PlanSemanal"> | Date | string
    fechaTermino?: DateTimeFilter<"PlanSemanal"> | Date | string
    pmFrenteId?: IntFilter<"PlanSemanal"> | number
    pmFrente?: XOR<PmFrenteScalarRelationFilter, PmFrenteWhereInput>
  }

  export type PlanSemanalOrderByWithRelationInput = {
    id_PlanSemanal?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaTermino?: SortOrder
    pmFrenteId?: SortOrder
    pmFrente?: PmFrenteOrderByWithRelationInput
  }

  export type PlanSemanalWhereUniqueInput = Prisma.AtLeast<{
    id_PlanSemanal?: number
    AND?: PlanSemanalWhereInput | PlanSemanalWhereInput[]
    OR?: PlanSemanalWhereInput[]
    NOT?: PlanSemanalWhereInput | PlanSemanalWhereInput[]
    descripcion?: StringFilter<"PlanSemanal"> | string
    fechaInicio?: DateTimeFilter<"PlanSemanal"> | Date | string
    fechaTermino?: DateTimeFilter<"PlanSemanal"> | Date | string
    pmFrenteId?: IntFilter<"PlanSemanal"> | number
    pmFrente?: XOR<PmFrenteScalarRelationFilter, PmFrenteWhereInput>
  }, "id_PlanSemanal">

  export type PlanSemanalOrderByWithAggregationInput = {
    id_PlanSemanal?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaTermino?: SortOrder
    pmFrenteId?: SortOrder
    _count?: PlanSemanalCountOrderByAggregateInput
    _avg?: PlanSemanalAvgOrderByAggregateInput
    _max?: PlanSemanalMaxOrderByAggregateInput
    _min?: PlanSemanalMinOrderByAggregateInput
    _sum?: PlanSemanalSumOrderByAggregateInput
  }

  export type PlanSemanalScalarWhereWithAggregatesInput = {
    AND?: PlanSemanalScalarWhereWithAggregatesInput | PlanSemanalScalarWhereWithAggregatesInput[]
    OR?: PlanSemanalScalarWhereWithAggregatesInput[]
    NOT?: PlanSemanalScalarWhereWithAggregatesInput | PlanSemanalScalarWhereWithAggregatesInput[]
    id_PlanSemanal?: IntWithAggregatesFilter<"PlanSemanal"> | number
    descripcion?: StringWithAggregatesFilter<"PlanSemanal"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"PlanSemanal"> | Date | string
    fechaTermino?: DateTimeWithAggregatesFilter<"PlanSemanal"> | Date | string
    pmFrenteId?: IntWithAggregatesFilter<"PlanSemanal"> | number
  }

  export type PlanSemanalPartidaWhereInput = {
    AND?: PlanSemanalPartidaWhereInput | PlanSemanalPartidaWhereInput[]
    OR?: PlanSemanalPartidaWhereInput[]
    NOT?: PlanSemanalPartidaWhereInput | PlanSemanalPartidaWhereInput[]
    id_PlanSemanalPartida?: IntFilter<"PlanSemanalPartida"> | number
    partidaId?: IntFilter<"PlanSemanalPartida"> | number
    viviendaId?: IntFilter<"PlanSemanalPartida"> | number
    revisionOk?: BoolFilter<"PlanSemanalPartida"> | boolean
    id_UsuarioRevision?: IntFilter<"PlanSemanalPartida"> | number
    fechaRevision?: DateTimeFilter<"PlanSemanalPartida"> | Date | string
    causaNoCumplimientoId?: IntFilter<"PlanSemanalPartida"> | number
    observacion?: StringFilter<"PlanSemanalPartida"> | string
    responsableId?: IntFilter<"PlanSemanalPartida"> | number
    cantidadProgramada?: DecimalFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFilter<"PlanSemanalPartida"> | number
    partida?: XOR<PartidaScalarRelationFilter, PartidaWhereInput>
    vivienda?: XOR<ViviendaScalarRelationFilter, ViviendaWhereInput>
    causaNoCumplimiento?: XOR<CausaNoCumplimientoScalarRelationFilter, CausaNoCumplimientoWhereInput>
    responsable?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type PlanSemanalPartidaOrderByWithRelationInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    revisionOk?: SortOrder
    id_UsuarioRevision?: SortOrder
    fechaRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    observacion?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
    partida?: PartidaOrderByWithRelationInput
    vivienda?: ViviendaOrderByWithRelationInput
    causaNoCumplimiento?: CausaNoCumplimientoOrderByWithRelationInput
    responsable?: UsuarioOrderByWithRelationInput
  }

  export type PlanSemanalPartidaWhereUniqueInput = Prisma.AtLeast<{
    id_PlanSemanalPartida?: number
    AND?: PlanSemanalPartidaWhereInput | PlanSemanalPartidaWhereInput[]
    OR?: PlanSemanalPartidaWhereInput[]
    NOT?: PlanSemanalPartidaWhereInput | PlanSemanalPartidaWhereInput[]
    partidaId?: IntFilter<"PlanSemanalPartida"> | number
    viviendaId?: IntFilter<"PlanSemanalPartida"> | number
    revisionOk?: BoolFilter<"PlanSemanalPartida"> | boolean
    id_UsuarioRevision?: IntFilter<"PlanSemanalPartida"> | number
    fechaRevision?: DateTimeFilter<"PlanSemanalPartida"> | Date | string
    causaNoCumplimientoId?: IntFilter<"PlanSemanalPartida"> | number
    observacion?: StringFilter<"PlanSemanalPartida"> | string
    responsableId?: IntFilter<"PlanSemanalPartida"> | number
    cantidadProgramada?: DecimalFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFilter<"PlanSemanalPartida"> | number
    partida?: XOR<PartidaScalarRelationFilter, PartidaWhereInput>
    vivienda?: XOR<ViviendaScalarRelationFilter, ViviendaWhereInput>
    causaNoCumplimiento?: XOR<CausaNoCumplimientoScalarRelationFilter, CausaNoCumplimientoWhereInput>
    responsable?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id_PlanSemanalPartida">

  export type PlanSemanalPartidaOrderByWithAggregationInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    revisionOk?: SortOrder
    id_UsuarioRevision?: SortOrder
    fechaRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    observacion?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
    _count?: PlanSemanalPartidaCountOrderByAggregateInput
    _avg?: PlanSemanalPartidaAvgOrderByAggregateInput
    _max?: PlanSemanalPartidaMaxOrderByAggregateInput
    _min?: PlanSemanalPartidaMinOrderByAggregateInput
    _sum?: PlanSemanalPartidaSumOrderByAggregateInput
  }

  export type PlanSemanalPartidaScalarWhereWithAggregatesInput = {
    AND?: PlanSemanalPartidaScalarWhereWithAggregatesInput | PlanSemanalPartidaScalarWhereWithAggregatesInput[]
    OR?: PlanSemanalPartidaScalarWhereWithAggregatesInput[]
    NOT?: PlanSemanalPartidaScalarWhereWithAggregatesInput | PlanSemanalPartidaScalarWhereWithAggregatesInput[]
    id_PlanSemanalPartida?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
    partidaId?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
    viviendaId?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
    revisionOk?: BoolWithAggregatesFilter<"PlanSemanalPartida"> | boolean
    id_UsuarioRevision?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
    fechaRevision?: DateTimeWithAggregatesFilter<"PlanSemanalPartida"> | Date | string
    causaNoCumplimientoId?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
    observacion?: StringWithAggregatesFilter<"PlanSemanalPartida"> | string
    responsableId?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
    cantidadProgramada?: DecimalWithAggregatesFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalWithAggregatesFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntWithAggregatesFilter<"PlanSemanalPartida"> | number
  }

  export type CausaNoCumplimientoWhereInput = {
    AND?: CausaNoCumplimientoWhereInput | CausaNoCumplimientoWhereInput[]
    OR?: CausaNoCumplimientoWhereInput[]
    NOT?: CausaNoCumplimientoWhereInput | CausaNoCumplimientoWhereInput[]
    id_CausaNoCumplimiento?: IntFilter<"CausaNoCumplimiento"> | number
    nombre?: StringFilter<"CausaNoCumplimiento"> | string
    esActivo?: BoolFilter<"CausaNoCumplimiento"> | boolean
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
  }

  export type CausaNoCumplimientoOrderByWithRelationInput = {
    id_CausaNoCumplimiento?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
    planSemanalPartida?: PlanSemanalPartidaOrderByRelationAggregateInput
  }

  export type CausaNoCumplimientoWhereUniqueInput = Prisma.AtLeast<{
    id_CausaNoCumplimiento?: number
    AND?: CausaNoCumplimientoWhereInput | CausaNoCumplimientoWhereInput[]
    OR?: CausaNoCumplimientoWhereInput[]
    NOT?: CausaNoCumplimientoWhereInput | CausaNoCumplimientoWhereInput[]
    nombre?: StringFilter<"CausaNoCumplimiento"> | string
    esActivo?: BoolFilter<"CausaNoCumplimiento"> | boolean
    planSemanalPartida?: PlanSemanalPartidaListRelationFilter
  }, "id_CausaNoCumplimiento">

  export type CausaNoCumplimientoOrderByWithAggregationInput = {
    id_CausaNoCumplimiento?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
    _count?: CausaNoCumplimientoCountOrderByAggregateInput
    _avg?: CausaNoCumplimientoAvgOrderByAggregateInput
    _max?: CausaNoCumplimientoMaxOrderByAggregateInput
    _min?: CausaNoCumplimientoMinOrderByAggregateInput
    _sum?: CausaNoCumplimientoSumOrderByAggregateInput
  }

  export type CausaNoCumplimientoScalarWhereWithAggregatesInput = {
    AND?: CausaNoCumplimientoScalarWhereWithAggregatesInput | CausaNoCumplimientoScalarWhereWithAggregatesInput[]
    OR?: CausaNoCumplimientoScalarWhereWithAggregatesInput[]
    NOT?: CausaNoCumplimientoScalarWhereWithAggregatesInput | CausaNoCumplimientoScalarWhereWithAggregatesInput[]
    id_CausaNoCumplimiento?: IntWithAggregatesFilter<"CausaNoCumplimiento"> | number
    nombre?: StringWithAggregatesFilter<"CausaNoCumplimiento"> | string
    esActivo?: BoolWithAggregatesFilter<"CausaNoCumplimiento"> | boolean
  }

  export type HitoCreateInput = {
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partida?: PartidaCreateNestedManyWithoutHitoInput
  }

  export type HitoUncheckedCreateInput = {
    id_Hito?: number
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partida?: PartidaUncheckedCreateNestedManyWithoutHitoInput
  }

  export type HitoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partida?: PartidaUpdateManyWithoutHitoNestedInput
  }

  export type HitoUncheckedUpdateInput = {
    id_Hito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partida?: PartidaUncheckedUpdateManyWithoutHitoNestedInput
  }

  export type HitoCreateManyInput = {
    id_Hito?: number
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HitoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HitoUncheckedUpdateManyInput = {
    id_Hito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTrabajoCreateInput = {
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partida?: PartidaCreateNestedManyWithoutPaqueteTrabajoInput
  }

  export type PaqueteTrabajoUncheckedCreateInput = {
    id_PaqueteTrabajo?: number
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partida?: PartidaUncheckedCreateNestedManyWithoutPaqueteTrabajoInput
  }

  export type PaqueteTrabajoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partida?: PartidaUpdateManyWithoutPaqueteTrabajoNestedInput
  }

  export type PaqueteTrabajoUncheckedUpdateInput = {
    id_PaqueteTrabajo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partida?: PartidaUncheckedUpdateManyWithoutPaqueteTrabajoNestedInput
  }

  export type PaqueteTrabajoCreateManyInput = {
    id_PaqueteTrabajo?: number
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTrabajoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTrabajoUncheckedUpdateManyInput = {
    id_PaqueteTrabajo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartidaCreateInput = {
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hito: HitoCreateNestedOneWithoutPartidaInput
    procesoConstrutivo: ProcesoConstrutivoCreateNestedOneWithoutPartidaInput
    paqueteTrabajo: PaqueteTrabajoCreateNestedOneWithoutPartidaInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUncheckedCreateInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hito?: HitoUpdateOneRequiredWithoutPartidaNestedInput
    procesoConstrutivo?: ProcesoConstrutivoUpdateOneRequiredWithoutPartidaNestedInput
    paqueteTrabajo?: PaqueteTrabajoUpdateOneRequiredWithoutPartidaNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaCreateManyInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
  }

  export type PartidaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
  }

  export type PartidaUncheckedUpdateManyInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
  }

  export type ProcesoConstrutivoCreateInput = {
    nombre: string
    descripcion: string
    jerarquia: number
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partida?: PartidaCreateNestedManyWithoutProcesoConstrutivoInput
  }

  export type ProcesoConstrutivoUncheckedCreateInput = {
    id_ProcesoConstrutivo?: number
    nombre: string
    descripcion: string
    jerarquia: number
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partida?: PartidaUncheckedCreateNestedManyWithoutProcesoConstrutivoInput
  }

  export type ProcesoConstrutivoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partida?: PartidaUpdateManyWithoutProcesoConstrutivoNestedInput
  }

  export type ProcesoConstrutivoUncheckedUpdateInput = {
    id_ProcesoConstrutivo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partida?: PartidaUncheckedUpdateManyWithoutProcesoConstrutivoNestedInput
  }

  export type ProcesoConstrutivoCreateManyInput = {
    id_ProcesoConstrutivo?: number
    nombre: string
    descripcion: string
    jerarquia: number
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcesoConstrutivoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcesoConstrutivoUncheckedUpdateManyInput = {
    id_ProcesoConstrutivo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanMaestroCreateInput = {
    descripcion: string
    fechaInicio?: Date | string
    proyecto: ProyectoCreateNestedOneWithoutPlanMaestroInput
    equipoTrabajos?: EquipoTrabajoCreateNestedManyWithoutPlanMaestroInput
    pmFrentes?: PmFrenteCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroUncheckedCreateInput = {
    id_PlanMaestro?: number
    descripcion: string
    fechaInicio?: Date | string
    proyectoId: number
    equipoTrabajos?: EquipoTrabajoUncheckedCreateNestedManyWithoutPlanMaestroInput
    pmFrentes?: PmFrenteUncheckedCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProyectoUpdateOneRequiredWithoutPlanMaestroNestedInput
    equipoTrabajos?: EquipoTrabajoUpdateManyWithoutPlanMaestroNestedInput
    pmFrentes?: PmFrenteUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PlanMaestroUncheckedUpdateInput = {
    id_PlanMaestro?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    equipoTrabajos?: EquipoTrabajoUncheckedUpdateManyWithoutPlanMaestroNestedInput
    pmFrentes?: PmFrenteUncheckedUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PlanMaestroCreateManyInput = {
    id_PlanMaestro?: number
    descripcion: string
    fechaInicio?: Date | string
    proyectoId: number
  }

  export type PlanMaestroUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanMaestroUncheckedUpdateManyInput = {
    id_PlanMaestro?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmFrenteCreateInput = {
    nombre: string
    planMaestro: PlanMaestroCreateNestedOneWithoutPmFrentesInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutFrenteInput
    planSemanal?: PlanSemanalCreateNestedManyWithoutPmFrenteInput
  }

  export type PmFrenteUncheckedCreateInput = {
    id_PmFrente?: number
    planMaestroId: number
    nombre: string
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutFrenteInput
    planSemanal?: PlanSemanalUncheckedCreateNestedManyWithoutPmFrenteInput
  }

  export type PmFrenteUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    planMaestro?: PlanMaestroUpdateOneRequiredWithoutPmFrentesNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutFrenteNestedInput
    planSemanal?: PlanSemanalUpdateManyWithoutPmFrenteNestedInput
  }

  export type PmFrenteUncheckedUpdateInput = {
    id_PmFrente?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutFrenteNestedInput
    planSemanal?: PlanSemanalUncheckedUpdateManyWithoutPmFrenteNestedInput
  }

  export type PmFrenteCreateManyInput = {
    id_PmFrente?: number
    planMaestroId: number
    nombre: string
  }

  export type PmFrenteUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PmFrenteUncheckedUpdateManyInput = {
    id_PmFrente?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PmFrentePartidaCreateInput = {
    cuadrilla: number
    orden: number
    partida: PartidaCreateNestedOneWithoutPmFrentePartidasInput
    frente: PmFrenteCreateNestedOneWithoutPmFrentePartidasInput
    pmProgramacion?: PmProgramacionCreateNestedManyWithoutPmFrentePartidaInput
  }

  export type PmFrentePartidaUncheckedCreateInput = {
    id_PmFrentePartida?: number
    partidaId: number
    cuadrilla: number
    frenteId: number
    orden: number
    pmProgramacion?: PmProgramacionUncheckedCreateNestedManyWithoutPmFrentePartidaInput
  }

  export type PmFrentePartidaUpdateInput = {
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPmFrentePartidasNestedInput
    frente?: PmFrenteUpdateOneRequiredWithoutPmFrentePartidasNestedInput
    pmProgramacion?: PmProgramacionUpdateManyWithoutPmFrentePartidaNestedInput
  }

  export type PmFrentePartidaUncheckedUpdateInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    frenteId?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    pmProgramacion?: PmProgramacionUncheckedUpdateManyWithoutPmFrentePartidaNestedInput
  }

  export type PmFrentePartidaCreateManyInput = {
    id_PmFrentePartida?: number
    partidaId: number
    cuadrilla: number
    frenteId: number
    orden: number
  }

  export type PmFrentePartidaUpdateManyMutationInput = {
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PmFrentePartidaUncheckedUpdateManyInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    frenteId?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PmProgramacionCreateInput = {
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    vivienda: ViviendaCreateNestedOneWithoutPmProgramacionInput
    pmFrentePartida: PmFrentePartidaCreateNestedOneWithoutPmProgramacionInput
  }

  export type PmProgramacionUncheckedCreateInput = {
    id_PmProgramacion?: number
    viviendaId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    pmFrentePartidaId: number
  }

  export type PmProgramacionUpdateInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    vivienda?: ViviendaUpdateOneRequiredWithoutPmProgramacionNestedInput
    pmFrentePartida?: PmFrentePartidaUpdateOneRequiredWithoutPmProgramacionNestedInput
  }

  export type PmProgramacionUncheckedUpdateInput = {
    id_PmProgramacion?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    pmFrentePartidaId?: IntFieldUpdateOperationsInput | number
  }

  export type PmProgramacionCreateManyInput = {
    id_PmProgramacion?: number
    viviendaId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    pmFrentePartidaId: number
  }

  export type PmProgramacionUpdateManyMutationInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PmProgramacionUncheckedUpdateManyInput = {
    id_PmProgramacion?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    pmFrentePartidaId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipoCargoCreateInput = {
    nombre: string
    esActivo?: boolean
    pmEquipo?: PmEquipoCreateNestedManyWithoutEquipoCargoInput
  }

  export type EquipoCargoUncheckedCreateInput = {
    id_EquipoCargo?: number
    nombre: string
    esActivo?: boolean
    pmEquipo?: PmEquipoUncheckedCreateNestedManyWithoutEquipoCargoInput
  }

  export type EquipoCargoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    pmEquipo?: PmEquipoUpdateManyWithoutEquipoCargoNestedInput
  }

  export type EquipoCargoUncheckedUpdateInput = {
    id_EquipoCargo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    pmEquipo?: PmEquipoUncheckedUpdateManyWithoutEquipoCargoNestedInput
  }

  export type EquipoCargoCreateManyInput = {
    id_EquipoCargo?: number
    nombre: string
    esActivo?: boolean
  }

  export type EquipoCargoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipoCargoUncheckedUpdateManyInput = {
    id_EquipoCargo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipoTrabajoCreateInput = {
    PlanMaestro: PlanMaestroCreateNestedOneWithoutEquipoTrabajosInput
    pmEquipo?: PmEquipoCreateNestedManyWithoutEquipoTrabajoInput
  }

  export type EquipoTrabajoUncheckedCreateInput = {
    id_EquipoTrabajo?: number
    planMaestroId: number
    pmEquipo?: PmEquipoUncheckedCreateNestedManyWithoutEquipoTrabajoInput
  }

  export type EquipoTrabajoUpdateInput = {
    PlanMaestro?: PlanMaestroUpdateOneRequiredWithoutEquipoTrabajosNestedInput
    pmEquipo?: PmEquipoUpdateManyWithoutEquipoTrabajoNestedInput
  }

  export type EquipoTrabajoUncheckedUpdateInput = {
    id_EquipoTrabajo?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
    pmEquipo?: PmEquipoUncheckedUpdateManyWithoutEquipoTrabajoNestedInput
  }

  export type EquipoTrabajoCreateManyInput = {
    id_EquipoTrabajo?: number
    planMaestroId: number
  }

  export type EquipoTrabajoUpdateManyMutationInput = {

  }

  export type EquipoTrabajoUncheckedUpdateManyInput = {
    id_EquipoTrabajo?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoCreateInput = {
    usuario: UsuarioCreateNestedOneWithoutPmEquipoInput
    equipoTrabajo: EquipoTrabajoCreateNestedOneWithoutPmEquipoInput
    equipoCargo: EquipoCargoCreateNestedOneWithoutPmEquipoInput
  }

  export type PmEquipoUncheckedCreateInput = {
    id_PmEquipo?: number
    usuarioId: number
    equipoTrabajoId: number
    equipoCargoId: number
  }

  export type PmEquipoUpdateInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutPmEquipoNestedInput
    equipoTrabajo?: EquipoTrabajoUpdateOneRequiredWithoutPmEquipoNestedInput
    equipoCargo?: EquipoCargoUpdateOneRequiredWithoutPmEquipoNestedInput
  }

  export type PmEquipoUncheckedUpdateInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    equipoTrabajoId?: IntFieldUpdateOperationsInput | number
    equipoCargoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoCreateManyInput = {
    id_PmEquipo?: number
    usuarioId: number
    equipoTrabajoId: number
    equipoCargoId: number
  }

  export type PmEquipoUpdateManyMutationInput = {

  }

  export type PmEquipoUncheckedUpdateManyInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    equipoTrabajoId?: IntFieldUpdateOperationsInput | number
    equipoCargoId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateInput = {
    nombre: string
    pmEquipo?: PmEquipoCreateNestedManyWithoutUsuarioInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutResponsableInput
  }

  export type UsuarioUncheckedCreateInput = {
    id_Usuario?: number
    nombre: string
    pmEquipo?: PmEquipoUncheckedCreateNestedManyWithoutUsuarioInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    pmEquipo?: PmEquipoUpdateManyWithoutUsuarioNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutResponsableNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id_Usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    pmEquipo?: PmEquipoUncheckedUpdateManyWithoutUsuarioNestedInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type UsuarioCreateManyInput = {
    id_Usuario?: number
    nombre: string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id_Usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ModeloViviendaCreateInput = {
    nombre: string
    activo?: boolean
    vivienda?: ViviendaCreateNestedManyWithoutModeloViviendaInput
  }

  export type ModeloViviendaUncheckedCreateInput = {
    id_ModeloVivienda?: number
    nombre: string
    activo?: boolean
    vivienda?: ViviendaUncheckedCreateNestedManyWithoutModeloViviendaInput
  }

  export type ModeloViviendaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    vivienda?: ViviendaUpdateManyWithoutModeloViviendaNestedInput
  }

  export type ModeloViviendaUncheckedUpdateInput = {
    id_ModeloVivienda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    vivienda?: ViviendaUncheckedUpdateManyWithoutModeloViviendaNestedInput
  }

  export type ModeloViviendaCreateManyInput = {
    id_ModeloVivienda?: number
    nombre: string
    activo?: boolean
  }

  export type ModeloViviendaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModeloViviendaUncheckedUpdateManyInput = {
    id_ModeloVivienda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProyectoCreateInput = {
    nombre: string
    activo?: boolean
    planMaestro?: PlanMaestroCreateNestedManyWithoutProyectoInput
  }

  export type ProyectoUncheckedCreateInput = {
    id_Proyecto?: number
    nombre: string
    activo?: boolean
    planMaestro?: PlanMaestroUncheckedCreateNestedManyWithoutProyectoInput
  }

  export type ProyectoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    planMaestro?: PlanMaestroUpdateManyWithoutProyectoNestedInput
  }

  export type ProyectoUncheckedUpdateInput = {
    id_Proyecto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    planMaestro?: PlanMaestroUncheckedUpdateManyWithoutProyectoNestedInput
  }

  export type ProyectoCreateManyInput = {
    id_Proyecto?: number
    nombre: string
    activo?: boolean
  }

  export type ProyectoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProyectoUncheckedUpdateManyInput = {
    id_Proyecto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ViviendaCreateInput = {
    numero: string
    id_Frente: string
    modeloVivienda: ModeloViviendaCreateNestedOneWithoutViviendaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutViviendaInput
    pmProgramacion?: PmProgramacionCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaUncheckedCreateInput = {
    id_Vivienda?: number
    numero: string
    id_Frente: string
    modeloViviendaId: number
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutViviendaInput
    pmProgramacion?: PmProgramacionUncheckedCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloVivienda?: ModeloViviendaUpdateOneRequiredWithoutViviendaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutViviendaNestedInput
    pmProgramacion?: PmProgramacionUpdateManyWithoutViviendaNestedInput
  }

  export type ViviendaUncheckedUpdateInput = {
    id_Vivienda?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloViviendaId?: IntFieldUpdateOperationsInput | number
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutViviendaNestedInput
    pmProgramacion?: PmProgramacionUncheckedUpdateManyWithoutViviendaNestedInput
  }

  export type ViviendaCreateManyInput = {
    id_Vivienda?: number
    numero: string
    id_Frente: string
    modeloViviendaId: number
  }

  export type ViviendaUpdateManyMutationInput = {
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
  }

  export type ViviendaUncheckedUpdateManyInput = {
    id_Vivienda?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloViviendaId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalCreateInput = {
    descripcion: string
    fechaInicio?: Date | string
    fechaTermino?: Date | string
    pmFrente: PmFrenteCreateNestedOneWithoutPlanSemanalInput
  }

  export type PlanSemanalUncheckedCreateInput = {
    id_PlanSemanal?: number
    descripcion: string
    fechaInicio?: Date | string
    fechaTermino?: Date | string
    pmFrenteId: number
  }

  export type PlanSemanalUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    pmFrente?: PmFrenteUpdateOneRequiredWithoutPlanSemanalNestedInput
  }

  export type PlanSemanalUncheckedUpdateInput = {
    id_PlanSemanal?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    pmFrenteId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalCreateManyInput = {
    id_PlanSemanal?: number
    descripcion: string
    fechaInicio?: Date | string
    fechaTermino?: Date | string
    pmFrenteId: number
  }

  export type PlanSemanalUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSemanalUncheckedUpdateManyInput = {
    id_PlanSemanal?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    pmFrenteId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaCreateInput = {
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
    partida: PartidaCreateNestedOneWithoutPlanSemanalPartidaInput
    vivienda: ViviendaCreateNestedOneWithoutPlanSemanalPartidaInput
    causaNoCumplimiento: CausaNoCumplimientoCreateNestedOneWithoutPlanSemanalPartidaInput
    responsable: UsuarioCreateNestedOneWithoutPlanSemanalPartidaInput
  }

  export type PlanSemanalPartidaUncheckedCreateInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaUpdateInput = {
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    vivienda?: ViviendaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    causaNoCumplimiento?: CausaNoCumplimientoUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    responsable?: UsuarioUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
  }

  export type PlanSemanalPartidaUncheckedUpdateInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaCreateManyInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaUpdateManyMutationInput = {
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUncheckedUpdateManyInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type CausaNoCumplimientoCreateInput = {
    nombre: string
    esActivo?: boolean
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutCausaNoCumplimientoInput
  }

  export type CausaNoCumplimientoUncheckedCreateInput = {
    id_CausaNoCumplimiento?: number
    nombre: string
    esActivo?: boolean
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutCausaNoCumplimientoInput
  }

  export type CausaNoCumplimientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutCausaNoCumplimientoNestedInput
  }

  export type CausaNoCumplimientoUncheckedUpdateInput = {
    id_CausaNoCumplimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutCausaNoCumplimientoNestedInput
  }

  export type CausaNoCumplimientoCreateManyInput = {
    id_CausaNoCumplimiento?: number
    nombre: string
    esActivo?: boolean
  }

  export type CausaNoCumplimientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CausaNoCumplimientoUncheckedUpdateManyInput = {
    id_CausaNoCumplimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PartidaListRelationFilter = {
    every?: PartidaWhereInput
    some?: PartidaWhereInput
    none?: PartidaWhereInput
  }

  export type PartidaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HitoCountOrderByAggregateInput = {
    id_Hito?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HitoAvgOrderByAggregateInput = {
    id_Hito?: SortOrder
  }

  export type HitoMaxOrderByAggregateInput = {
    id_Hito?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HitoMinOrderByAggregateInput = {
    id_Hito?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HitoSumOrderByAggregateInput = {
    id_Hito?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PaqueteTrabajoCountOrderByAggregateInput = {
    id_PaqueteTrabajo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTrabajoAvgOrderByAggregateInput = {
    id_PaqueteTrabajo?: SortOrder
  }

  export type PaqueteTrabajoMaxOrderByAggregateInput = {
    id_PaqueteTrabajo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTrabajoMinOrderByAggregateInput = {
    id_PaqueteTrabajo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTrabajoSumOrderByAggregateInput = {
    id_PaqueteTrabajo?: SortOrder
  }

  export type HitoScalarRelationFilter = {
    is?: HitoWhereInput
    isNot?: HitoWhereInput
  }

  export type ProcesoConstrutivoScalarRelationFilter = {
    is?: ProcesoConstrutivoWhereInput
    isNot?: ProcesoConstrutivoWhereInput
  }

  export type PaqueteTrabajoScalarRelationFilter = {
    is?: PaqueteTrabajoWhereInput
    isNot?: PaqueteTrabajoWhereInput
  }

  export type PmFrentePartidaListRelationFilter = {
    every?: PmFrentePartidaWhereInput
    some?: PmFrentePartidaWhereInput
    none?: PmFrentePartidaWhereInput
  }

  export type PlanSemanalPartidaListRelationFilter = {
    every?: PlanSemanalPartidaWhereInput
    some?: PlanSemanalPartidaWhereInput
    none?: PlanSemanalPartidaWhereInput
  }

  export type PmFrentePartidaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanSemanalPartidaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartidaCountOrderByAggregateInput = {
    id_Partida?: SortOrder
    nombre?: SortOrder
    medida?: SortOrder
    ritmo?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
  }

  export type PartidaAvgOrderByAggregateInput = {
    id_Partida?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
  }

  export type PartidaMaxOrderByAggregateInput = {
    id_Partida?: SortOrder
    nombre?: SortOrder
    medida?: SortOrder
    ritmo?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
  }

  export type PartidaMinOrderByAggregateInput = {
    id_Partida?: SortOrder
    nombre?: SortOrder
    medida?: SortOrder
    ritmo?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
  }

  export type PartidaSumOrderByAggregateInput = {
    id_Partida?: SortOrder
    cuadrillasSugeridas?: SortOrder
    hitoId?: SortOrder
    procesoConstrutivoId?: SortOrder
    paqueteTrabajoId?: SortOrder
  }

  export type ProcesoConstrutivoCountOrderByAggregateInput = {
    id_ProcesoConstrutivo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    jerarquia?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcesoConstrutivoAvgOrderByAggregateInput = {
    id_ProcesoConstrutivo?: SortOrder
    jerarquia?: SortOrder
  }

  export type ProcesoConstrutivoMaxOrderByAggregateInput = {
    id_ProcesoConstrutivo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    jerarquia?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcesoConstrutivoMinOrderByAggregateInput = {
    id_ProcesoConstrutivo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    jerarquia?: SortOrder
    esActivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcesoConstrutivoSumOrderByAggregateInput = {
    id_ProcesoConstrutivo?: SortOrder
    jerarquia?: SortOrder
  }

  export type ProyectoScalarRelationFilter = {
    is?: ProyectoWhereInput
    isNot?: ProyectoWhereInput
  }

  export type EquipoTrabajoListRelationFilter = {
    every?: EquipoTrabajoWhereInput
    some?: EquipoTrabajoWhereInput
    none?: EquipoTrabajoWhereInput
  }

  export type PmFrenteListRelationFilter = {
    every?: PmFrenteWhereInput
    some?: PmFrenteWhereInput
    none?: PmFrenteWhereInput
  }

  export type EquipoTrabajoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PmFrenteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanMaestroCountOrderByAggregateInput = {
    id_PlanMaestro?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    proyectoId?: SortOrder
  }

  export type PlanMaestroAvgOrderByAggregateInput = {
    id_PlanMaestro?: SortOrder
    proyectoId?: SortOrder
  }

  export type PlanMaestroMaxOrderByAggregateInput = {
    id_PlanMaestro?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    proyectoId?: SortOrder
  }

  export type PlanMaestroMinOrderByAggregateInput = {
    id_PlanMaestro?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    proyectoId?: SortOrder
  }

  export type PlanMaestroSumOrderByAggregateInput = {
    id_PlanMaestro?: SortOrder
    proyectoId?: SortOrder
  }

  export type PlanMaestroScalarRelationFilter = {
    is?: PlanMaestroWhereInput
    isNot?: PlanMaestroWhereInput
  }

  export type PlanSemanalListRelationFilter = {
    every?: PlanSemanalWhereInput
    some?: PlanSemanalWhereInput
    none?: PlanSemanalWhereInput
  }

  export type PlanSemanalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PmFrenteCountOrderByAggregateInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
    nombre?: SortOrder
  }

  export type PmFrenteAvgOrderByAggregateInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
  }

  export type PmFrenteMaxOrderByAggregateInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
    nombre?: SortOrder
  }

  export type PmFrenteMinOrderByAggregateInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
    nombre?: SortOrder
  }

  export type PmFrenteSumOrderByAggregateInput = {
    id_PmFrente?: SortOrder
    planMaestroId?: SortOrder
  }

  export type PartidaScalarRelationFilter = {
    is?: PartidaWhereInput
    isNot?: PartidaWhereInput
  }

  export type PmFrenteScalarRelationFilter = {
    is?: PmFrenteWhereInput
    isNot?: PmFrenteWhereInput
  }

  export type PmProgramacionListRelationFilter = {
    every?: PmProgramacionWhereInput
    some?: PmProgramacionWhereInput
    none?: PmProgramacionWhereInput
  }

  export type PmProgramacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PmFrentePartidaCountOrderByAggregateInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
  }

  export type PmFrentePartidaAvgOrderByAggregateInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
  }

  export type PmFrentePartidaMaxOrderByAggregateInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
  }

  export type PmFrentePartidaMinOrderByAggregateInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
  }

  export type PmFrentePartidaSumOrderByAggregateInput = {
    id_PmFrentePartida?: SortOrder
    partidaId?: SortOrder
    cuadrilla?: SortOrder
    frenteId?: SortOrder
    orden?: SortOrder
  }

  export type ViviendaScalarRelationFilter = {
    is?: ViviendaWhereInput
    isNot?: ViviendaWhereInput
  }

  export type PmFrentePartidaScalarRelationFilter = {
    is?: PmFrentePartidaWhereInput
    isNot?: PmFrentePartidaWhereInput
  }

  export type PmProgramacionCountOrderByAggregateInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
  }

  export type PmProgramacionAvgOrderByAggregateInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
  }

  export type PmProgramacionMaxOrderByAggregateInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
  }

  export type PmProgramacionMinOrderByAggregateInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
  }

  export type PmProgramacionSumOrderByAggregateInput = {
    id_PmProgramacion?: SortOrder
    viviendaId?: SortOrder
    cantidad?: SortOrder
    pmFrentePartidaId?: SortOrder
  }

  export type PmEquipoListRelationFilter = {
    every?: PmEquipoWhereInput
    some?: PmEquipoWhereInput
    none?: PmEquipoWhereInput
  }

  export type PmEquipoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipoCargoCountOrderByAggregateInput = {
    id_EquipoCargo?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
  }

  export type EquipoCargoAvgOrderByAggregateInput = {
    id_EquipoCargo?: SortOrder
  }

  export type EquipoCargoMaxOrderByAggregateInput = {
    id_EquipoCargo?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
  }

  export type EquipoCargoMinOrderByAggregateInput = {
    id_EquipoCargo?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
  }

  export type EquipoCargoSumOrderByAggregateInput = {
    id_EquipoCargo?: SortOrder
  }

  export type EquipoTrabajoCountOrderByAggregateInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
  }

  export type EquipoTrabajoAvgOrderByAggregateInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
  }

  export type EquipoTrabajoMaxOrderByAggregateInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
  }

  export type EquipoTrabajoMinOrderByAggregateInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
  }

  export type EquipoTrabajoSumOrderByAggregateInput = {
    id_EquipoTrabajo?: SortOrder
    planMaestroId?: SortOrder
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type EquipoTrabajoScalarRelationFilter = {
    is?: EquipoTrabajoWhereInput
    isNot?: EquipoTrabajoWhereInput
  }

  export type EquipoCargoScalarRelationFilter = {
    is?: EquipoCargoWhereInput
    isNot?: EquipoCargoWhereInput
  }

  export type PmEquipoCountOrderByAggregateInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
  }

  export type PmEquipoAvgOrderByAggregateInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
  }

  export type PmEquipoMaxOrderByAggregateInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
  }

  export type PmEquipoMinOrderByAggregateInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
  }

  export type PmEquipoSumOrderByAggregateInput = {
    id_PmEquipo?: SortOrder
    usuarioId?: SortOrder
    equipoTrabajoId?: SortOrder
    equipoCargoId?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id_Usuario?: SortOrder
    nombre?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id_Usuario?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id_Usuario?: SortOrder
    nombre?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id_Usuario?: SortOrder
    nombre?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id_Usuario?: SortOrder
  }

  export type ViviendaListRelationFilter = {
    every?: ViviendaWhereInput
    some?: ViviendaWhereInput
    none?: ViviendaWhereInput
  }

  export type ViviendaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModeloViviendaCountOrderByAggregateInput = {
    id_ModeloVivienda?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
  }

  export type ModeloViviendaAvgOrderByAggregateInput = {
    id_ModeloVivienda?: SortOrder
  }

  export type ModeloViviendaMaxOrderByAggregateInput = {
    id_ModeloVivienda?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
  }

  export type ModeloViviendaMinOrderByAggregateInput = {
    id_ModeloVivienda?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
  }

  export type ModeloViviendaSumOrderByAggregateInput = {
    id_ModeloVivienda?: SortOrder
  }

  export type PlanMaestroListRelationFilter = {
    every?: PlanMaestroWhereInput
    some?: PlanMaestroWhereInput
    none?: PlanMaestroWhereInput
  }

  export type PlanMaestroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProyectoCountOrderByAggregateInput = {
    id_Proyecto?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
  }

  export type ProyectoAvgOrderByAggregateInput = {
    id_Proyecto?: SortOrder
  }

  export type ProyectoMaxOrderByAggregateInput = {
    id_Proyecto?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
  }

  export type ProyectoMinOrderByAggregateInput = {
    id_Proyecto?: SortOrder
    nombre?: SortOrder
    activo?: SortOrder
  }

  export type ProyectoSumOrderByAggregateInput = {
    id_Proyecto?: SortOrder
  }

  export type ModeloViviendaScalarRelationFilter = {
    is?: ModeloViviendaWhereInput
    isNot?: ModeloViviendaWhereInput
  }

  export type ViviendaCountOrderByAggregateInput = {
    id_Vivienda?: SortOrder
    numero?: SortOrder
    id_Frente?: SortOrder
    modeloViviendaId?: SortOrder
  }

  export type ViviendaAvgOrderByAggregateInput = {
    id_Vivienda?: SortOrder
    modeloViviendaId?: SortOrder
  }

  export type ViviendaMaxOrderByAggregateInput = {
    id_Vivienda?: SortOrder
    numero?: SortOrder
    id_Frente?: SortOrder
    modeloViviendaId?: SortOrder
  }

  export type ViviendaMinOrderByAggregateInput = {
    id_Vivienda?: SortOrder
    numero?: SortOrder
    id_Frente?: SortOrder
    modeloViviendaId?: SortOrder
  }

  export type ViviendaSumOrderByAggregateInput = {
    id_Vivienda?: SortOrder
    modeloViviendaId?: SortOrder
  }

  export type PlanSemanalCountOrderByAggregateInput = {
    id_PlanSemanal?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaTermino?: SortOrder
    pmFrenteId?: SortOrder
  }

  export type PlanSemanalAvgOrderByAggregateInput = {
    id_PlanSemanal?: SortOrder
    pmFrenteId?: SortOrder
  }

  export type PlanSemanalMaxOrderByAggregateInput = {
    id_PlanSemanal?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaTermino?: SortOrder
    pmFrenteId?: SortOrder
  }

  export type PlanSemanalMinOrderByAggregateInput = {
    id_PlanSemanal?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaTermino?: SortOrder
    pmFrenteId?: SortOrder
  }

  export type PlanSemanalSumOrderByAggregateInput = {
    id_PlanSemanal?: SortOrder
    pmFrenteId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CausaNoCumplimientoScalarRelationFilter = {
    is?: CausaNoCumplimientoWhereInput
    isNot?: CausaNoCumplimientoWhereInput
  }

  export type PlanSemanalPartidaCountOrderByAggregateInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    revisionOk?: SortOrder
    id_UsuarioRevision?: SortOrder
    fechaRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    observacion?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
  }

  export type PlanSemanalPartidaAvgOrderByAggregateInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    id_UsuarioRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
  }

  export type PlanSemanalPartidaMaxOrderByAggregateInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    revisionOk?: SortOrder
    id_UsuarioRevision?: SortOrder
    fechaRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    observacion?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
  }

  export type PlanSemanalPartidaMinOrderByAggregateInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    revisionOk?: SortOrder
    id_UsuarioRevision?: SortOrder
    fechaRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    observacion?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
  }

  export type PlanSemanalPartidaSumOrderByAggregateInput = {
    id_PlanSemanalPartida?: SortOrder
    partidaId?: SortOrder
    viviendaId?: SortOrder
    id_UsuarioRevision?: SortOrder
    causaNoCumplimientoId?: SortOrder
    responsableId?: SortOrder
    cantidadProgramada?: SortOrder
    cantidadEjecutada?: SortOrder
    id_Cuadrilla?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CausaNoCumplimientoCountOrderByAggregateInput = {
    id_CausaNoCumplimiento?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
  }

  export type CausaNoCumplimientoAvgOrderByAggregateInput = {
    id_CausaNoCumplimiento?: SortOrder
  }

  export type CausaNoCumplimientoMaxOrderByAggregateInput = {
    id_CausaNoCumplimiento?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
  }

  export type CausaNoCumplimientoMinOrderByAggregateInput = {
    id_CausaNoCumplimiento?: SortOrder
    nombre?: SortOrder
    esActivo?: SortOrder
  }

  export type CausaNoCumplimientoSumOrderByAggregateInput = {
    id_CausaNoCumplimiento?: SortOrder
  }

  export type PartidaCreateNestedManyWithoutHitoInput = {
    create?: XOR<PartidaCreateWithoutHitoInput, PartidaUncheckedCreateWithoutHitoInput> | PartidaCreateWithoutHitoInput[] | PartidaUncheckedCreateWithoutHitoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutHitoInput | PartidaCreateOrConnectWithoutHitoInput[]
    createMany?: PartidaCreateManyHitoInputEnvelope
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
  }

  export type PartidaUncheckedCreateNestedManyWithoutHitoInput = {
    create?: XOR<PartidaCreateWithoutHitoInput, PartidaUncheckedCreateWithoutHitoInput> | PartidaCreateWithoutHitoInput[] | PartidaUncheckedCreateWithoutHitoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutHitoInput | PartidaCreateOrConnectWithoutHitoInput[]
    createMany?: PartidaCreateManyHitoInputEnvelope
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PartidaUpdateManyWithoutHitoNestedInput = {
    create?: XOR<PartidaCreateWithoutHitoInput, PartidaUncheckedCreateWithoutHitoInput> | PartidaCreateWithoutHitoInput[] | PartidaUncheckedCreateWithoutHitoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutHitoInput | PartidaCreateOrConnectWithoutHitoInput[]
    upsert?: PartidaUpsertWithWhereUniqueWithoutHitoInput | PartidaUpsertWithWhereUniqueWithoutHitoInput[]
    createMany?: PartidaCreateManyHitoInputEnvelope
    set?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    disconnect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    delete?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    update?: PartidaUpdateWithWhereUniqueWithoutHitoInput | PartidaUpdateWithWhereUniqueWithoutHitoInput[]
    updateMany?: PartidaUpdateManyWithWhereWithoutHitoInput | PartidaUpdateManyWithWhereWithoutHitoInput[]
    deleteMany?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PartidaUncheckedUpdateManyWithoutHitoNestedInput = {
    create?: XOR<PartidaCreateWithoutHitoInput, PartidaUncheckedCreateWithoutHitoInput> | PartidaCreateWithoutHitoInput[] | PartidaUncheckedCreateWithoutHitoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutHitoInput | PartidaCreateOrConnectWithoutHitoInput[]
    upsert?: PartidaUpsertWithWhereUniqueWithoutHitoInput | PartidaUpsertWithWhereUniqueWithoutHitoInput[]
    createMany?: PartidaCreateManyHitoInputEnvelope
    set?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    disconnect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    delete?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    update?: PartidaUpdateWithWhereUniqueWithoutHitoInput | PartidaUpdateWithWhereUniqueWithoutHitoInput[]
    updateMany?: PartidaUpdateManyWithWhereWithoutHitoInput | PartidaUpdateManyWithWhereWithoutHitoInput[]
    deleteMany?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
  }

  export type PartidaCreateNestedManyWithoutPaqueteTrabajoInput = {
    create?: XOR<PartidaCreateWithoutPaqueteTrabajoInput, PartidaUncheckedCreateWithoutPaqueteTrabajoInput> | PartidaCreateWithoutPaqueteTrabajoInput[] | PartidaUncheckedCreateWithoutPaqueteTrabajoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutPaqueteTrabajoInput | PartidaCreateOrConnectWithoutPaqueteTrabajoInput[]
    createMany?: PartidaCreateManyPaqueteTrabajoInputEnvelope
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
  }

  export type PartidaUncheckedCreateNestedManyWithoutPaqueteTrabajoInput = {
    create?: XOR<PartidaCreateWithoutPaqueteTrabajoInput, PartidaUncheckedCreateWithoutPaqueteTrabajoInput> | PartidaCreateWithoutPaqueteTrabajoInput[] | PartidaUncheckedCreateWithoutPaqueteTrabajoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutPaqueteTrabajoInput | PartidaCreateOrConnectWithoutPaqueteTrabajoInput[]
    createMany?: PartidaCreateManyPaqueteTrabajoInputEnvelope
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
  }

  export type PartidaUpdateManyWithoutPaqueteTrabajoNestedInput = {
    create?: XOR<PartidaCreateWithoutPaqueteTrabajoInput, PartidaUncheckedCreateWithoutPaqueteTrabajoInput> | PartidaCreateWithoutPaqueteTrabajoInput[] | PartidaUncheckedCreateWithoutPaqueteTrabajoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutPaqueteTrabajoInput | PartidaCreateOrConnectWithoutPaqueteTrabajoInput[]
    upsert?: PartidaUpsertWithWhereUniqueWithoutPaqueteTrabajoInput | PartidaUpsertWithWhereUniqueWithoutPaqueteTrabajoInput[]
    createMany?: PartidaCreateManyPaqueteTrabajoInputEnvelope
    set?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    disconnect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    delete?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    update?: PartidaUpdateWithWhereUniqueWithoutPaqueteTrabajoInput | PartidaUpdateWithWhereUniqueWithoutPaqueteTrabajoInput[]
    updateMany?: PartidaUpdateManyWithWhereWithoutPaqueteTrabajoInput | PartidaUpdateManyWithWhereWithoutPaqueteTrabajoInput[]
    deleteMany?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
  }

  export type PartidaUncheckedUpdateManyWithoutPaqueteTrabajoNestedInput = {
    create?: XOR<PartidaCreateWithoutPaqueteTrabajoInput, PartidaUncheckedCreateWithoutPaqueteTrabajoInput> | PartidaCreateWithoutPaqueteTrabajoInput[] | PartidaUncheckedCreateWithoutPaqueteTrabajoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutPaqueteTrabajoInput | PartidaCreateOrConnectWithoutPaqueteTrabajoInput[]
    upsert?: PartidaUpsertWithWhereUniqueWithoutPaqueteTrabajoInput | PartidaUpsertWithWhereUniqueWithoutPaqueteTrabajoInput[]
    createMany?: PartidaCreateManyPaqueteTrabajoInputEnvelope
    set?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    disconnect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    delete?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    update?: PartidaUpdateWithWhereUniqueWithoutPaqueteTrabajoInput | PartidaUpdateWithWhereUniqueWithoutPaqueteTrabajoInput[]
    updateMany?: PartidaUpdateManyWithWhereWithoutPaqueteTrabajoInput | PartidaUpdateManyWithWhereWithoutPaqueteTrabajoInput[]
    deleteMany?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
  }

  export type HitoCreateNestedOneWithoutPartidaInput = {
    create?: XOR<HitoCreateWithoutPartidaInput, HitoUncheckedCreateWithoutPartidaInput>
    connectOrCreate?: HitoCreateOrConnectWithoutPartidaInput
    connect?: HitoWhereUniqueInput
  }

  export type ProcesoConstrutivoCreateNestedOneWithoutPartidaInput = {
    create?: XOR<ProcesoConstrutivoCreateWithoutPartidaInput, ProcesoConstrutivoUncheckedCreateWithoutPartidaInput>
    connectOrCreate?: ProcesoConstrutivoCreateOrConnectWithoutPartidaInput
    connect?: ProcesoConstrutivoWhereUniqueInput
  }

  export type PaqueteTrabajoCreateNestedOneWithoutPartidaInput = {
    create?: XOR<PaqueteTrabajoCreateWithoutPartidaInput, PaqueteTrabajoUncheckedCreateWithoutPartidaInput>
    connectOrCreate?: PaqueteTrabajoCreateOrConnectWithoutPartidaInput
    connect?: PaqueteTrabajoWhereUniqueInput
  }

  export type PmFrentePartidaCreateNestedManyWithoutPartidaInput = {
    create?: XOR<PmFrentePartidaCreateWithoutPartidaInput, PmFrentePartidaUncheckedCreateWithoutPartidaInput> | PmFrentePartidaCreateWithoutPartidaInput[] | PmFrentePartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutPartidaInput | PmFrentePartidaCreateOrConnectWithoutPartidaInput[]
    createMany?: PmFrentePartidaCreateManyPartidaInputEnvelope
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
  }

  export type PlanSemanalPartidaCreateNestedManyWithoutPartidaInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutPartidaInput, PlanSemanalPartidaUncheckedCreateWithoutPartidaInput> | PlanSemanalPartidaCreateWithoutPartidaInput[] | PlanSemanalPartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutPartidaInput | PlanSemanalPartidaCreateOrConnectWithoutPartidaInput[]
    createMany?: PlanSemanalPartidaCreateManyPartidaInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PmFrentePartidaUncheckedCreateNestedManyWithoutPartidaInput = {
    create?: XOR<PmFrentePartidaCreateWithoutPartidaInput, PmFrentePartidaUncheckedCreateWithoutPartidaInput> | PmFrentePartidaCreateWithoutPartidaInput[] | PmFrentePartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutPartidaInput | PmFrentePartidaCreateOrConnectWithoutPartidaInput[]
    createMany?: PmFrentePartidaCreateManyPartidaInputEnvelope
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
  }

  export type PlanSemanalPartidaUncheckedCreateNestedManyWithoutPartidaInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutPartidaInput, PlanSemanalPartidaUncheckedCreateWithoutPartidaInput> | PlanSemanalPartidaCreateWithoutPartidaInput[] | PlanSemanalPartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutPartidaInput | PlanSemanalPartidaCreateOrConnectWithoutPartidaInput[]
    createMany?: PlanSemanalPartidaCreateManyPartidaInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type HitoUpdateOneRequiredWithoutPartidaNestedInput = {
    create?: XOR<HitoCreateWithoutPartidaInput, HitoUncheckedCreateWithoutPartidaInput>
    connectOrCreate?: HitoCreateOrConnectWithoutPartidaInput
    upsert?: HitoUpsertWithoutPartidaInput
    connect?: HitoWhereUniqueInput
    update?: XOR<XOR<HitoUpdateToOneWithWhereWithoutPartidaInput, HitoUpdateWithoutPartidaInput>, HitoUncheckedUpdateWithoutPartidaInput>
  }

  export type ProcesoConstrutivoUpdateOneRequiredWithoutPartidaNestedInput = {
    create?: XOR<ProcesoConstrutivoCreateWithoutPartidaInput, ProcesoConstrutivoUncheckedCreateWithoutPartidaInput>
    connectOrCreate?: ProcesoConstrutivoCreateOrConnectWithoutPartidaInput
    upsert?: ProcesoConstrutivoUpsertWithoutPartidaInput
    connect?: ProcesoConstrutivoWhereUniqueInput
    update?: XOR<XOR<ProcesoConstrutivoUpdateToOneWithWhereWithoutPartidaInput, ProcesoConstrutivoUpdateWithoutPartidaInput>, ProcesoConstrutivoUncheckedUpdateWithoutPartidaInput>
  }

  export type PaqueteTrabajoUpdateOneRequiredWithoutPartidaNestedInput = {
    create?: XOR<PaqueteTrabajoCreateWithoutPartidaInput, PaqueteTrabajoUncheckedCreateWithoutPartidaInput>
    connectOrCreate?: PaqueteTrabajoCreateOrConnectWithoutPartidaInput
    upsert?: PaqueteTrabajoUpsertWithoutPartidaInput
    connect?: PaqueteTrabajoWhereUniqueInput
    update?: XOR<XOR<PaqueteTrabajoUpdateToOneWithWhereWithoutPartidaInput, PaqueteTrabajoUpdateWithoutPartidaInput>, PaqueteTrabajoUncheckedUpdateWithoutPartidaInput>
  }

  export type PmFrentePartidaUpdateManyWithoutPartidaNestedInput = {
    create?: XOR<PmFrentePartidaCreateWithoutPartidaInput, PmFrentePartidaUncheckedCreateWithoutPartidaInput> | PmFrentePartidaCreateWithoutPartidaInput[] | PmFrentePartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutPartidaInput | PmFrentePartidaCreateOrConnectWithoutPartidaInput[]
    upsert?: PmFrentePartidaUpsertWithWhereUniqueWithoutPartidaInput | PmFrentePartidaUpsertWithWhereUniqueWithoutPartidaInput[]
    createMany?: PmFrentePartidaCreateManyPartidaInputEnvelope
    set?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    disconnect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    delete?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    update?: PmFrentePartidaUpdateWithWhereUniqueWithoutPartidaInput | PmFrentePartidaUpdateWithWhereUniqueWithoutPartidaInput[]
    updateMany?: PmFrentePartidaUpdateManyWithWhereWithoutPartidaInput | PmFrentePartidaUpdateManyWithWhereWithoutPartidaInput[]
    deleteMany?: PmFrentePartidaScalarWhereInput | PmFrentePartidaScalarWhereInput[]
  }

  export type PlanSemanalPartidaUpdateManyWithoutPartidaNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutPartidaInput, PlanSemanalPartidaUncheckedCreateWithoutPartidaInput> | PlanSemanalPartidaCreateWithoutPartidaInput[] | PlanSemanalPartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutPartidaInput | PlanSemanalPartidaCreateOrConnectWithoutPartidaInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutPartidaInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutPartidaInput[]
    createMany?: PlanSemanalPartidaCreateManyPartidaInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutPartidaInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutPartidaInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutPartidaInput | PlanSemanalPartidaUpdateManyWithWhereWithoutPartidaInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type PmFrentePartidaUncheckedUpdateManyWithoutPartidaNestedInput = {
    create?: XOR<PmFrentePartidaCreateWithoutPartidaInput, PmFrentePartidaUncheckedCreateWithoutPartidaInput> | PmFrentePartidaCreateWithoutPartidaInput[] | PmFrentePartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutPartidaInput | PmFrentePartidaCreateOrConnectWithoutPartidaInput[]
    upsert?: PmFrentePartidaUpsertWithWhereUniqueWithoutPartidaInput | PmFrentePartidaUpsertWithWhereUniqueWithoutPartidaInput[]
    createMany?: PmFrentePartidaCreateManyPartidaInputEnvelope
    set?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    disconnect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    delete?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    update?: PmFrentePartidaUpdateWithWhereUniqueWithoutPartidaInput | PmFrentePartidaUpdateWithWhereUniqueWithoutPartidaInput[]
    updateMany?: PmFrentePartidaUpdateManyWithWhereWithoutPartidaInput | PmFrentePartidaUpdateManyWithWhereWithoutPartidaInput[]
    deleteMany?: PmFrentePartidaScalarWhereInput | PmFrentePartidaScalarWhereInput[]
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutPartidaInput, PlanSemanalPartidaUncheckedCreateWithoutPartidaInput> | PlanSemanalPartidaCreateWithoutPartidaInput[] | PlanSemanalPartidaUncheckedCreateWithoutPartidaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutPartidaInput | PlanSemanalPartidaCreateOrConnectWithoutPartidaInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutPartidaInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutPartidaInput[]
    createMany?: PlanSemanalPartidaCreateManyPartidaInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutPartidaInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutPartidaInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutPartidaInput | PlanSemanalPartidaUpdateManyWithWhereWithoutPartidaInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type PartidaCreateNestedManyWithoutProcesoConstrutivoInput = {
    create?: XOR<PartidaCreateWithoutProcesoConstrutivoInput, PartidaUncheckedCreateWithoutProcesoConstrutivoInput> | PartidaCreateWithoutProcesoConstrutivoInput[] | PartidaUncheckedCreateWithoutProcesoConstrutivoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutProcesoConstrutivoInput | PartidaCreateOrConnectWithoutProcesoConstrutivoInput[]
    createMany?: PartidaCreateManyProcesoConstrutivoInputEnvelope
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
  }

  export type PartidaUncheckedCreateNestedManyWithoutProcesoConstrutivoInput = {
    create?: XOR<PartidaCreateWithoutProcesoConstrutivoInput, PartidaUncheckedCreateWithoutProcesoConstrutivoInput> | PartidaCreateWithoutProcesoConstrutivoInput[] | PartidaUncheckedCreateWithoutProcesoConstrutivoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutProcesoConstrutivoInput | PartidaCreateOrConnectWithoutProcesoConstrutivoInput[]
    createMany?: PartidaCreateManyProcesoConstrutivoInputEnvelope
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
  }

  export type PartidaUpdateManyWithoutProcesoConstrutivoNestedInput = {
    create?: XOR<PartidaCreateWithoutProcesoConstrutivoInput, PartidaUncheckedCreateWithoutProcesoConstrutivoInput> | PartidaCreateWithoutProcesoConstrutivoInput[] | PartidaUncheckedCreateWithoutProcesoConstrutivoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutProcesoConstrutivoInput | PartidaCreateOrConnectWithoutProcesoConstrutivoInput[]
    upsert?: PartidaUpsertWithWhereUniqueWithoutProcesoConstrutivoInput | PartidaUpsertWithWhereUniqueWithoutProcesoConstrutivoInput[]
    createMany?: PartidaCreateManyProcesoConstrutivoInputEnvelope
    set?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    disconnect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    delete?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    update?: PartidaUpdateWithWhereUniqueWithoutProcesoConstrutivoInput | PartidaUpdateWithWhereUniqueWithoutProcesoConstrutivoInput[]
    updateMany?: PartidaUpdateManyWithWhereWithoutProcesoConstrutivoInput | PartidaUpdateManyWithWhereWithoutProcesoConstrutivoInput[]
    deleteMany?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
  }

  export type PartidaUncheckedUpdateManyWithoutProcesoConstrutivoNestedInput = {
    create?: XOR<PartidaCreateWithoutProcesoConstrutivoInput, PartidaUncheckedCreateWithoutProcesoConstrutivoInput> | PartidaCreateWithoutProcesoConstrutivoInput[] | PartidaUncheckedCreateWithoutProcesoConstrutivoInput[]
    connectOrCreate?: PartidaCreateOrConnectWithoutProcesoConstrutivoInput | PartidaCreateOrConnectWithoutProcesoConstrutivoInput[]
    upsert?: PartidaUpsertWithWhereUniqueWithoutProcesoConstrutivoInput | PartidaUpsertWithWhereUniqueWithoutProcesoConstrutivoInput[]
    createMany?: PartidaCreateManyProcesoConstrutivoInputEnvelope
    set?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    disconnect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    delete?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    connect?: PartidaWhereUniqueInput | PartidaWhereUniqueInput[]
    update?: PartidaUpdateWithWhereUniqueWithoutProcesoConstrutivoInput | PartidaUpdateWithWhereUniqueWithoutProcesoConstrutivoInput[]
    updateMany?: PartidaUpdateManyWithWhereWithoutProcesoConstrutivoInput | PartidaUpdateManyWithWhereWithoutProcesoConstrutivoInput[]
    deleteMany?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
  }

  export type ProyectoCreateNestedOneWithoutPlanMaestroInput = {
    create?: XOR<ProyectoCreateWithoutPlanMaestroInput, ProyectoUncheckedCreateWithoutPlanMaestroInput>
    connectOrCreate?: ProyectoCreateOrConnectWithoutPlanMaestroInput
    connect?: ProyectoWhereUniqueInput
  }

  export type EquipoTrabajoCreateNestedManyWithoutPlanMaestroInput = {
    create?: XOR<EquipoTrabajoCreateWithoutPlanMaestroInput, EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput> | EquipoTrabajoCreateWithoutPlanMaestroInput[] | EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput | EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput[]
    createMany?: EquipoTrabajoCreateManyPlanMaestroInputEnvelope
    connect?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
  }

  export type PmFrenteCreateNestedManyWithoutPlanMaestroInput = {
    create?: XOR<PmFrenteCreateWithoutPlanMaestroInput, PmFrenteUncheckedCreateWithoutPlanMaestroInput> | PmFrenteCreateWithoutPlanMaestroInput[] | PmFrenteUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPlanMaestroInput | PmFrenteCreateOrConnectWithoutPlanMaestroInput[]
    createMany?: PmFrenteCreateManyPlanMaestroInputEnvelope
    connect?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
  }

  export type EquipoTrabajoUncheckedCreateNestedManyWithoutPlanMaestroInput = {
    create?: XOR<EquipoTrabajoCreateWithoutPlanMaestroInput, EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput> | EquipoTrabajoCreateWithoutPlanMaestroInput[] | EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput | EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput[]
    createMany?: EquipoTrabajoCreateManyPlanMaestroInputEnvelope
    connect?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
  }

  export type PmFrenteUncheckedCreateNestedManyWithoutPlanMaestroInput = {
    create?: XOR<PmFrenteCreateWithoutPlanMaestroInput, PmFrenteUncheckedCreateWithoutPlanMaestroInput> | PmFrenteCreateWithoutPlanMaestroInput[] | PmFrenteUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPlanMaestroInput | PmFrenteCreateOrConnectWithoutPlanMaestroInput[]
    createMany?: PmFrenteCreateManyPlanMaestroInputEnvelope
    connect?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
  }

  export type ProyectoUpdateOneRequiredWithoutPlanMaestroNestedInput = {
    create?: XOR<ProyectoCreateWithoutPlanMaestroInput, ProyectoUncheckedCreateWithoutPlanMaestroInput>
    connectOrCreate?: ProyectoCreateOrConnectWithoutPlanMaestroInput
    upsert?: ProyectoUpsertWithoutPlanMaestroInput
    connect?: ProyectoWhereUniqueInput
    update?: XOR<XOR<ProyectoUpdateToOneWithWhereWithoutPlanMaestroInput, ProyectoUpdateWithoutPlanMaestroInput>, ProyectoUncheckedUpdateWithoutPlanMaestroInput>
  }

  export type EquipoTrabajoUpdateManyWithoutPlanMaestroNestedInput = {
    create?: XOR<EquipoTrabajoCreateWithoutPlanMaestroInput, EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput> | EquipoTrabajoCreateWithoutPlanMaestroInput[] | EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput | EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput[]
    upsert?: EquipoTrabajoUpsertWithWhereUniqueWithoutPlanMaestroInput | EquipoTrabajoUpsertWithWhereUniqueWithoutPlanMaestroInput[]
    createMany?: EquipoTrabajoCreateManyPlanMaestroInputEnvelope
    set?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    disconnect?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    delete?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    connect?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    update?: EquipoTrabajoUpdateWithWhereUniqueWithoutPlanMaestroInput | EquipoTrabajoUpdateWithWhereUniqueWithoutPlanMaestroInput[]
    updateMany?: EquipoTrabajoUpdateManyWithWhereWithoutPlanMaestroInput | EquipoTrabajoUpdateManyWithWhereWithoutPlanMaestroInput[]
    deleteMany?: EquipoTrabajoScalarWhereInput | EquipoTrabajoScalarWhereInput[]
  }

  export type PmFrenteUpdateManyWithoutPlanMaestroNestedInput = {
    create?: XOR<PmFrenteCreateWithoutPlanMaestroInput, PmFrenteUncheckedCreateWithoutPlanMaestroInput> | PmFrenteCreateWithoutPlanMaestroInput[] | PmFrenteUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPlanMaestroInput | PmFrenteCreateOrConnectWithoutPlanMaestroInput[]
    upsert?: PmFrenteUpsertWithWhereUniqueWithoutPlanMaestroInput | PmFrenteUpsertWithWhereUniqueWithoutPlanMaestroInput[]
    createMany?: PmFrenteCreateManyPlanMaestroInputEnvelope
    set?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    disconnect?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    delete?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    connect?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    update?: PmFrenteUpdateWithWhereUniqueWithoutPlanMaestroInput | PmFrenteUpdateWithWhereUniqueWithoutPlanMaestroInput[]
    updateMany?: PmFrenteUpdateManyWithWhereWithoutPlanMaestroInput | PmFrenteUpdateManyWithWhereWithoutPlanMaestroInput[]
    deleteMany?: PmFrenteScalarWhereInput | PmFrenteScalarWhereInput[]
  }

  export type EquipoTrabajoUncheckedUpdateManyWithoutPlanMaestroNestedInput = {
    create?: XOR<EquipoTrabajoCreateWithoutPlanMaestroInput, EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput> | EquipoTrabajoCreateWithoutPlanMaestroInput[] | EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput | EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput[]
    upsert?: EquipoTrabajoUpsertWithWhereUniqueWithoutPlanMaestroInput | EquipoTrabajoUpsertWithWhereUniqueWithoutPlanMaestroInput[]
    createMany?: EquipoTrabajoCreateManyPlanMaestroInputEnvelope
    set?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    disconnect?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    delete?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    connect?: EquipoTrabajoWhereUniqueInput | EquipoTrabajoWhereUniqueInput[]
    update?: EquipoTrabajoUpdateWithWhereUniqueWithoutPlanMaestroInput | EquipoTrabajoUpdateWithWhereUniqueWithoutPlanMaestroInput[]
    updateMany?: EquipoTrabajoUpdateManyWithWhereWithoutPlanMaestroInput | EquipoTrabajoUpdateManyWithWhereWithoutPlanMaestroInput[]
    deleteMany?: EquipoTrabajoScalarWhereInput | EquipoTrabajoScalarWhereInput[]
  }

  export type PmFrenteUncheckedUpdateManyWithoutPlanMaestroNestedInput = {
    create?: XOR<PmFrenteCreateWithoutPlanMaestroInput, PmFrenteUncheckedCreateWithoutPlanMaestroInput> | PmFrenteCreateWithoutPlanMaestroInput[] | PmFrenteUncheckedCreateWithoutPlanMaestroInput[]
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPlanMaestroInput | PmFrenteCreateOrConnectWithoutPlanMaestroInput[]
    upsert?: PmFrenteUpsertWithWhereUniqueWithoutPlanMaestroInput | PmFrenteUpsertWithWhereUniqueWithoutPlanMaestroInput[]
    createMany?: PmFrenteCreateManyPlanMaestroInputEnvelope
    set?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    disconnect?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    delete?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    connect?: PmFrenteWhereUniqueInput | PmFrenteWhereUniqueInput[]
    update?: PmFrenteUpdateWithWhereUniqueWithoutPlanMaestroInput | PmFrenteUpdateWithWhereUniqueWithoutPlanMaestroInput[]
    updateMany?: PmFrenteUpdateManyWithWhereWithoutPlanMaestroInput | PmFrenteUpdateManyWithWhereWithoutPlanMaestroInput[]
    deleteMany?: PmFrenteScalarWhereInput | PmFrenteScalarWhereInput[]
  }

  export type PlanMaestroCreateNestedOneWithoutPmFrentesInput = {
    create?: XOR<PlanMaestroCreateWithoutPmFrentesInput, PlanMaestroUncheckedCreateWithoutPmFrentesInput>
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutPmFrentesInput
    connect?: PlanMaestroWhereUniqueInput
  }

  export type PmFrentePartidaCreateNestedManyWithoutFrenteInput = {
    create?: XOR<PmFrentePartidaCreateWithoutFrenteInput, PmFrentePartidaUncheckedCreateWithoutFrenteInput> | PmFrentePartidaCreateWithoutFrenteInput[] | PmFrentePartidaUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutFrenteInput | PmFrentePartidaCreateOrConnectWithoutFrenteInput[]
    createMany?: PmFrentePartidaCreateManyFrenteInputEnvelope
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
  }

  export type PlanSemanalCreateNestedManyWithoutPmFrenteInput = {
    create?: XOR<PlanSemanalCreateWithoutPmFrenteInput, PlanSemanalUncheckedCreateWithoutPmFrenteInput> | PlanSemanalCreateWithoutPmFrenteInput[] | PlanSemanalUncheckedCreateWithoutPmFrenteInput[]
    connectOrCreate?: PlanSemanalCreateOrConnectWithoutPmFrenteInput | PlanSemanalCreateOrConnectWithoutPmFrenteInput[]
    createMany?: PlanSemanalCreateManyPmFrenteInputEnvelope
    connect?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
  }

  export type PmFrentePartidaUncheckedCreateNestedManyWithoutFrenteInput = {
    create?: XOR<PmFrentePartidaCreateWithoutFrenteInput, PmFrentePartidaUncheckedCreateWithoutFrenteInput> | PmFrentePartidaCreateWithoutFrenteInput[] | PmFrentePartidaUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutFrenteInput | PmFrentePartidaCreateOrConnectWithoutFrenteInput[]
    createMany?: PmFrentePartidaCreateManyFrenteInputEnvelope
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
  }

  export type PlanSemanalUncheckedCreateNestedManyWithoutPmFrenteInput = {
    create?: XOR<PlanSemanalCreateWithoutPmFrenteInput, PlanSemanalUncheckedCreateWithoutPmFrenteInput> | PlanSemanalCreateWithoutPmFrenteInput[] | PlanSemanalUncheckedCreateWithoutPmFrenteInput[]
    connectOrCreate?: PlanSemanalCreateOrConnectWithoutPmFrenteInput | PlanSemanalCreateOrConnectWithoutPmFrenteInput[]
    createMany?: PlanSemanalCreateManyPmFrenteInputEnvelope
    connect?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
  }

  export type PlanMaestroUpdateOneRequiredWithoutPmFrentesNestedInput = {
    create?: XOR<PlanMaestroCreateWithoutPmFrentesInput, PlanMaestroUncheckedCreateWithoutPmFrentesInput>
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutPmFrentesInput
    upsert?: PlanMaestroUpsertWithoutPmFrentesInput
    connect?: PlanMaestroWhereUniqueInput
    update?: XOR<XOR<PlanMaestroUpdateToOneWithWhereWithoutPmFrentesInput, PlanMaestroUpdateWithoutPmFrentesInput>, PlanMaestroUncheckedUpdateWithoutPmFrentesInput>
  }

  export type PmFrentePartidaUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<PmFrentePartidaCreateWithoutFrenteInput, PmFrentePartidaUncheckedCreateWithoutFrenteInput> | PmFrentePartidaCreateWithoutFrenteInput[] | PmFrentePartidaUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutFrenteInput | PmFrentePartidaCreateOrConnectWithoutFrenteInput[]
    upsert?: PmFrentePartidaUpsertWithWhereUniqueWithoutFrenteInput | PmFrentePartidaUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: PmFrentePartidaCreateManyFrenteInputEnvelope
    set?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    disconnect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    delete?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    update?: PmFrentePartidaUpdateWithWhereUniqueWithoutFrenteInput | PmFrentePartidaUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: PmFrentePartidaUpdateManyWithWhereWithoutFrenteInput | PmFrentePartidaUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: PmFrentePartidaScalarWhereInput | PmFrentePartidaScalarWhereInput[]
  }

  export type PlanSemanalUpdateManyWithoutPmFrenteNestedInput = {
    create?: XOR<PlanSemanalCreateWithoutPmFrenteInput, PlanSemanalUncheckedCreateWithoutPmFrenteInput> | PlanSemanalCreateWithoutPmFrenteInput[] | PlanSemanalUncheckedCreateWithoutPmFrenteInput[]
    connectOrCreate?: PlanSemanalCreateOrConnectWithoutPmFrenteInput | PlanSemanalCreateOrConnectWithoutPmFrenteInput[]
    upsert?: PlanSemanalUpsertWithWhereUniqueWithoutPmFrenteInput | PlanSemanalUpsertWithWhereUniqueWithoutPmFrenteInput[]
    createMany?: PlanSemanalCreateManyPmFrenteInputEnvelope
    set?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    disconnect?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    delete?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    connect?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    update?: PlanSemanalUpdateWithWhereUniqueWithoutPmFrenteInput | PlanSemanalUpdateWithWhereUniqueWithoutPmFrenteInput[]
    updateMany?: PlanSemanalUpdateManyWithWhereWithoutPmFrenteInput | PlanSemanalUpdateManyWithWhereWithoutPmFrenteInput[]
    deleteMany?: PlanSemanalScalarWhereInput | PlanSemanalScalarWhereInput[]
  }

  export type PmFrentePartidaUncheckedUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<PmFrentePartidaCreateWithoutFrenteInput, PmFrentePartidaUncheckedCreateWithoutFrenteInput> | PmFrentePartidaCreateWithoutFrenteInput[] | PmFrentePartidaUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutFrenteInput | PmFrentePartidaCreateOrConnectWithoutFrenteInput[]
    upsert?: PmFrentePartidaUpsertWithWhereUniqueWithoutFrenteInput | PmFrentePartidaUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: PmFrentePartidaCreateManyFrenteInputEnvelope
    set?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    disconnect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    delete?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    connect?: PmFrentePartidaWhereUniqueInput | PmFrentePartidaWhereUniqueInput[]
    update?: PmFrentePartidaUpdateWithWhereUniqueWithoutFrenteInput | PmFrentePartidaUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: PmFrentePartidaUpdateManyWithWhereWithoutFrenteInput | PmFrentePartidaUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: PmFrentePartidaScalarWhereInput | PmFrentePartidaScalarWhereInput[]
  }

  export type PlanSemanalUncheckedUpdateManyWithoutPmFrenteNestedInput = {
    create?: XOR<PlanSemanalCreateWithoutPmFrenteInput, PlanSemanalUncheckedCreateWithoutPmFrenteInput> | PlanSemanalCreateWithoutPmFrenteInput[] | PlanSemanalUncheckedCreateWithoutPmFrenteInput[]
    connectOrCreate?: PlanSemanalCreateOrConnectWithoutPmFrenteInput | PlanSemanalCreateOrConnectWithoutPmFrenteInput[]
    upsert?: PlanSemanalUpsertWithWhereUniqueWithoutPmFrenteInput | PlanSemanalUpsertWithWhereUniqueWithoutPmFrenteInput[]
    createMany?: PlanSemanalCreateManyPmFrenteInputEnvelope
    set?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    disconnect?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    delete?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    connect?: PlanSemanalWhereUniqueInput | PlanSemanalWhereUniqueInput[]
    update?: PlanSemanalUpdateWithWhereUniqueWithoutPmFrenteInput | PlanSemanalUpdateWithWhereUniqueWithoutPmFrenteInput[]
    updateMany?: PlanSemanalUpdateManyWithWhereWithoutPmFrenteInput | PlanSemanalUpdateManyWithWhereWithoutPmFrenteInput[]
    deleteMany?: PlanSemanalScalarWhereInput | PlanSemanalScalarWhereInput[]
  }

  export type PartidaCreateNestedOneWithoutPmFrentePartidasInput = {
    create?: XOR<PartidaCreateWithoutPmFrentePartidasInput, PartidaUncheckedCreateWithoutPmFrentePartidasInput>
    connectOrCreate?: PartidaCreateOrConnectWithoutPmFrentePartidasInput
    connect?: PartidaWhereUniqueInput
  }

  export type PmFrenteCreateNestedOneWithoutPmFrentePartidasInput = {
    create?: XOR<PmFrenteCreateWithoutPmFrentePartidasInput, PmFrenteUncheckedCreateWithoutPmFrentePartidasInput>
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPmFrentePartidasInput
    connect?: PmFrenteWhereUniqueInput
  }

  export type PmProgramacionCreateNestedManyWithoutPmFrentePartidaInput = {
    create?: XOR<PmProgramacionCreateWithoutPmFrentePartidaInput, PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput> | PmProgramacionCreateWithoutPmFrentePartidaInput[] | PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput | PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput[]
    createMany?: PmProgramacionCreateManyPmFrentePartidaInputEnvelope
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
  }

  export type PmProgramacionUncheckedCreateNestedManyWithoutPmFrentePartidaInput = {
    create?: XOR<PmProgramacionCreateWithoutPmFrentePartidaInput, PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput> | PmProgramacionCreateWithoutPmFrentePartidaInput[] | PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput | PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput[]
    createMany?: PmProgramacionCreateManyPmFrentePartidaInputEnvelope
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
  }

  export type PartidaUpdateOneRequiredWithoutPmFrentePartidasNestedInput = {
    create?: XOR<PartidaCreateWithoutPmFrentePartidasInput, PartidaUncheckedCreateWithoutPmFrentePartidasInput>
    connectOrCreate?: PartidaCreateOrConnectWithoutPmFrentePartidasInput
    upsert?: PartidaUpsertWithoutPmFrentePartidasInput
    connect?: PartidaWhereUniqueInput
    update?: XOR<XOR<PartidaUpdateToOneWithWhereWithoutPmFrentePartidasInput, PartidaUpdateWithoutPmFrentePartidasInput>, PartidaUncheckedUpdateWithoutPmFrentePartidasInput>
  }

  export type PmFrenteUpdateOneRequiredWithoutPmFrentePartidasNestedInput = {
    create?: XOR<PmFrenteCreateWithoutPmFrentePartidasInput, PmFrenteUncheckedCreateWithoutPmFrentePartidasInput>
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPmFrentePartidasInput
    upsert?: PmFrenteUpsertWithoutPmFrentePartidasInput
    connect?: PmFrenteWhereUniqueInput
    update?: XOR<XOR<PmFrenteUpdateToOneWithWhereWithoutPmFrentePartidasInput, PmFrenteUpdateWithoutPmFrentePartidasInput>, PmFrenteUncheckedUpdateWithoutPmFrentePartidasInput>
  }

  export type PmProgramacionUpdateManyWithoutPmFrentePartidaNestedInput = {
    create?: XOR<PmProgramacionCreateWithoutPmFrentePartidaInput, PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput> | PmProgramacionCreateWithoutPmFrentePartidaInput[] | PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput | PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput[]
    upsert?: PmProgramacionUpsertWithWhereUniqueWithoutPmFrentePartidaInput | PmProgramacionUpsertWithWhereUniqueWithoutPmFrentePartidaInput[]
    createMany?: PmProgramacionCreateManyPmFrentePartidaInputEnvelope
    set?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    disconnect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    delete?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    update?: PmProgramacionUpdateWithWhereUniqueWithoutPmFrentePartidaInput | PmProgramacionUpdateWithWhereUniqueWithoutPmFrentePartidaInput[]
    updateMany?: PmProgramacionUpdateManyWithWhereWithoutPmFrentePartidaInput | PmProgramacionUpdateManyWithWhereWithoutPmFrentePartidaInput[]
    deleteMany?: PmProgramacionScalarWhereInput | PmProgramacionScalarWhereInput[]
  }

  export type PmProgramacionUncheckedUpdateManyWithoutPmFrentePartidaNestedInput = {
    create?: XOR<PmProgramacionCreateWithoutPmFrentePartidaInput, PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput> | PmProgramacionCreateWithoutPmFrentePartidaInput[] | PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput | PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput[]
    upsert?: PmProgramacionUpsertWithWhereUniqueWithoutPmFrentePartidaInput | PmProgramacionUpsertWithWhereUniqueWithoutPmFrentePartidaInput[]
    createMany?: PmProgramacionCreateManyPmFrentePartidaInputEnvelope
    set?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    disconnect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    delete?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    update?: PmProgramacionUpdateWithWhereUniqueWithoutPmFrentePartidaInput | PmProgramacionUpdateWithWhereUniqueWithoutPmFrentePartidaInput[]
    updateMany?: PmProgramacionUpdateManyWithWhereWithoutPmFrentePartidaInput | PmProgramacionUpdateManyWithWhereWithoutPmFrentePartidaInput[]
    deleteMany?: PmProgramacionScalarWhereInput | PmProgramacionScalarWhereInput[]
  }

  export type ViviendaCreateNestedOneWithoutPmProgramacionInput = {
    create?: XOR<ViviendaCreateWithoutPmProgramacionInput, ViviendaUncheckedCreateWithoutPmProgramacionInput>
    connectOrCreate?: ViviendaCreateOrConnectWithoutPmProgramacionInput
    connect?: ViviendaWhereUniqueInput
  }

  export type PmFrentePartidaCreateNestedOneWithoutPmProgramacionInput = {
    create?: XOR<PmFrentePartidaCreateWithoutPmProgramacionInput, PmFrentePartidaUncheckedCreateWithoutPmProgramacionInput>
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutPmProgramacionInput
    connect?: PmFrentePartidaWhereUniqueInput
  }

  export type ViviendaUpdateOneRequiredWithoutPmProgramacionNestedInput = {
    create?: XOR<ViviendaCreateWithoutPmProgramacionInput, ViviendaUncheckedCreateWithoutPmProgramacionInput>
    connectOrCreate?: ViviendaCreateOrConnectWithoutPmProgramacionInput
    upsert?: ViviendaUpsertWithoutPmProgramacionInput
    connect?: ViviendaWhereUniqueInput
    update?: XOR<XOR<ViviendaUpdateToOneWithWhereWithoutPmProgramacionInput, ViviendaUpdateWithoutPmProgramacionInput>, ViviendaUncheckedUpdateWithoutPmProgramacionInput>
  }

  export type PmFrentePartidaUpdateOneRequiredWithoutPmProgramacionNestedInput = {
    create?: XOR<PmFrentePartidaCreateWithoutPmProgramacionInput, PmFrentePartidaUncheckedCreateWithoutPmProgramacionInput>
    connectOrCreate?: PmFrentePartidaCreateOrConnectWithoutPmProgramacionInput
    upsert?: PmFrentePartidaUpsertWithoutPmProgramacionInput
    connect?: PmFrentePartidaWhereUniqueInput
    update?: XOR<XOR<PmFrentePartidaUpdateToOneWithWhereWithoutPmProgramacionInput, PmFrentePartidaUpdateWithoutPmProgramacionInput>, PmFrentePartidaUncheckedUpdateWithoutPmProgramacionInput>
  }

  export type PmEquipoCreateNestedManyWithoutEquipoCargoInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoCargoInput, PmEquipoUncheckedCreateWithoutEquipoCargoInput> | PmEquipoCreateWithoutEquipoCargoInput[] | PmEquipoUncheckedCreateWithoutEquipoCargoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoCargoInput | PmEquipoCreateOrConnectWithoutEquipoCargoInput[]
    createMany?: PmEquipoCreateManyEquipoCargoInputEnvelope
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
  }

  export type PmEquipoUncheckedCreateNestedManyWithoutEquipoCargoInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoCargoInput, PmEquipoUncheckedCreateWithoutEquipoCargoInput> | PmEquipoCreateWithoutEquipoCargoInput[] | PmEquipoUncheckedCreateWithoutEquipoCargoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoCargoInput | PmEquipoCreateOrConnectWithoutEquipoCargoInput[]
    createMany?: PmEquipoCreateManyEquipoCargoInputEnvelope
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
  }

  export type PmEquipoUpdateManyWithoutEquipoCargoNestedInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoCargoInput, PmEquipoUncheckedCreateWithoutEquipoCargoInput> | PmEquipoCreateWithoutEquipoCargoInput[] | PmEquipoUncheckedCreateWithoutEquipoCargoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoCargoInput | PmEquipoCreateOrConnectWithoutEquipoCargoInput[]
    upsert?: PmEquipoUpsertWithWhereUniqueWithoutEquipoCargoInput | PmEquipoUpsertWithWhereUniqueWithoutEquipoCargoInput[]
    createMany?: PmEquipoCreateManyEquipoCargoInputEnvelope
    set?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    disconnect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    delete?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    update?: PmEquipoUpdateWithWhereUniqueWithoutEquipoCargoInput | PmEquipoUpdateWithWhereUniqueWithoutEquipoCargoInput[]
    updateMany?: PmEquipoUpdateManyWithWhereWithoutEquipoCargoInput | PmEquipoUpdateManyWithWhereWithoutEquipoCargoInput[]
    deleteMany?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
  }

  export type PmEquipoUncheckedUpdateManyWithoutEquipoCargoNestedInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoCargoInput, PmEquipoUncheckedCreateWithoutEquipoCargoInput> | PmEquipoCreateWithoutEquipoCargoInput[] | PmEquipoUncheckedCreateWithoutEquipoCargoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoCargoInput | PmEquipoCreateOrConnectWithoutEquipoCargoInput[]
    upsert?: PmEquipoUpsertWithWhereUniqueWithoutEquipoCargoInput | PmEquipoUpsertWithWhereUniqueWithoutEquipoCargoInput[]
    createMany?: PmEquipoCreateManyEquipoCargoInputEnvelope
    set?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    disconnect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    delete?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    update?: PmEquipoUpdateWithWhereUniqueWithoutEquipoCargoInput | PmEquipoUpdateWithWhereUniqueWithoutEquipoCargoInput[]
    updateMany?: PmEquipoUpdateManyWithWhereWithoutEquipoCargoInput | PmEquipoUpdateManyWithWhereWithoutEquipoCargoInput[]
    deleteMany?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
  }

  export type PlanMaestroCreateNestedOneWithoutEquipoTrabajosInput = {
    create?: XOR<PlanMaestroCreateWithoutEquipoTrabajosInput, PlanMaestroUncheckedCreateWithoutEquipoTrabajosInput>
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutEquipoTrabajosInput
    connect?: PlanMaestroWhereUniqueInput
  }

  export type PmEquipoCreateNestedManyWithoutEquipoTrabajoInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoTrabajoInput, PmEquipoUncheckedCreateWithoutEquipoTrabajoInput> | PmEquipoCreateWithoutEquipoTrabajoInput[] | PmEquipoUncheckedCreateWithoutEquipoTrabajoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoTrabajoInput | PmEquipoCreateOrConnectWithoutEquipoTrabajoInput[]
    createMany?: PmEquipoCreateManyEquipoTrabajoInputEnvelope
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
  }

  export type PmEquipoUncheckedCreateNestedManyWithoutEquipoTrabajoInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoTrabajoInput, PmEquipoUncheckedCreateWithoutEquipoTrabajoInput> | PmEquipoCreateWithoutEquipoTrabajoInput[] | PmEquipoUncheckedCreateWithoutEquipoTrabajoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoTrabajoInput | PmEquipoCreateOrConnectWithoutEquipoTrabajoInput[]
    createMany?: PmEquipoCreateManyEquipoTrabajoInputEnvelope
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
  }

  export type PlanMaestroUpdateOneRequiredWithoutEquipoTrabajosNestedInput = {
    create?: XOR<PlanMaestroCreateWithoutEquipoTrabajosInput, PlanMaestroUncheckedCreateWithoutEquipoTrabajosInput>
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutEquipoTrabajosInput
    upsert?: PlanMaestroUpsertWithoutEquipoTrabajosInput
    connect?: PlanMaestroWhereUniqueInput
    update?: XOR<XOR<PlanMaestroUpdateToOneWithWhereWithoutEquipoTrabajosInput, PlanMaestroUpdateWithoutEquipoTrabajosInput>, PlanMaestroUncheckedUpdateWithoutEquipoTrabajosInput>
  }

  export type PmEquipoUpdateManyWithoutEquipoTrabajoNestedInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoTrabajoInput, PmEquipoUncheckedCreateWithoutEquipoTrabajoInput> | PmEquipoCreateWithoutEquipoTrabajoInput[] | PmEquipoUncheckedCreateWithoutEquipoTrabajoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoTrabajoInput | PmEquipoCreateOrConnectWithoutEquipoTrabajoInput[]
    upsert?: PmEquipoUpsertWithWhereUniqueWithoutEquipoTrabajoInput | PmEquipoUpsertWithWhereUniqueWithoutEquipoTrabajoInput[]
    createMany?: PmEquipoCreateManyEquipoTrabajoInputEnvelope
    set?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    disconnect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    delete?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    update?: PmEquipoUpdateWithWhereUniqueWithoutEquipoTrabajoInput | PmEquipoUpdateWithWhereUniqueWithoutEquipoTrabajoInput[]
    updateMany?: PmEquipoUpdateManyWithWhereWithoutEquipoTrabajoInput | PmEquipoUpdateManyWithWhereWithoutEquipoTrabajoInput[]
    deleteMany?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
  }

  export type PmEquipoUncheckedUpdateManyWithoutEquipoTrabajoNestedInput = {
    create?: XOR<PmEquipoCreateWithoutEquipoTrabajoInput, PmEquipoUncheckedCreateWithoutEquipoTrabajoInput> | PmEquipoCreateWithoutEquipoTrabajoInput[] | PmEquipoUncheckedCreateWithoutEquipoTrabajoInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutEquipoTrabajoInput | PmEquipoCreateOrConnectWithoutEquipoTrabajoInput[]
    upsert?: PmEquipoUpsertWithWhereUniqueWithoutEquipoTrabajoInput | PmEquipoUpsertWithWhereUniqueWithoutEquipoTrabajoInput[]
    createMany?: PmEquipoCreateManyEquipoTrabajoInputEnvelope
    set?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    disconnect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    delete?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    update?: PmEquipoUpdateWithWhereUniqueWithoutEquipoTrabajoInput | PmEquipoUpdateWithWhereUniqueWithoutEquipoTrabajoInput[]
    updateMany?: PmEquipoUpdateManyWithWhereWithoutEquipoTrabajoInput | PmEquipoUpdateManyWithWhereWithoutEquipoTrabajoInput[]
    deleteMany?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutPmEquipoInput = {
    create?: XOR<UsuarioCreateWithoutPmEquipoInput, UsuarioUncheckedCreateWithoutPmEquipoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPmEquipoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EquipoTrabajoCreateNestedOneWithoutPmEquipoInput = {
    create?: XOR<EquipoTrabajoCreateWithoutPmEquipoInput, EquipoTrabajoUncheckedCreateWithoutPmEquipoInput>
    connectOrCreate?: EquipoTrabajoCreateOrConnectWithoutPmEquipoInput
    connect?: EquipoTrabajoWhereUniqueInput
  }

  export type EquipoCargoCreateNestedOneWithoutPmEquipoInput = {
    create?: XOR<EquipoCargoCreateWithoutPmEquipoInput, EquipoCargoUncheckedCreateWithoutPmEquipoInput>
    connectOrCreate?: EquipoCargoCreateOrConnectWithoutPmEquipoInput
    connect?: EquipoCargoWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutPmEquipoNestedInput = {
    create?: XOR<UsuarioCreateWithoutPmEquipoInput, UsuarioUncheckedCreateWithoutPmEquipoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPmEquipoInput
    upsert?: UsuarioUpsertWithoutPmEquipoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPmEquipoInput, UsuarioUpdateWithoutPmEquipoInput>, UsuarioUncheckedUpdateWithoutPmEquipoInput>
  }

  export type EquipoTrabajoUpdateOneRequiredWithoutPmEquipoNestedInput = {
    create?: XOR<EquipoTrabajoCreateWithoutPmEquipoInput, EquipoTrabajoUncheckedCreateWithoutPmEquipoInput>
    connectOrCreate?: EquipoTrabajoCreateOrConnectWithoutPmEquipoInput
    upsert?: EquipoTrabajoUpsertWithoutPmEquipoInput
    connect?: EquipoTrabajoWhereUniqueInput
    update?: XOR<XOR<EquipoTrabajoUpdateToOneWithWhereWithoutPmEquipoInput, EquipoTrabajoUpdateWithoutPmEquipoInput>, EquipoTrabajoUncheckedUpdateWithoutPmEquipoInput>
  }

  export type EquipoCargoUpdateOneRequiredWithoutPmEquipoNestedInput = {
    create?: XOR<EquipoCargoCreateWithoutPmEquipoInput, EquipoCargoUncheckedCreateWithoutPmEquipoInput>
    connectOrCreate?: EquipoCargoCreateOrConnectWithoutPmEquipoInput
    upsert?: EquipoCargoUpsertWithoutPmEquipoInput
    connect?: EquipoCargoWhereUniqueInput
    update?: XOR<XOR<EquipoCargoUpdateToOneWithWhereWithoutPmEquipoInput, EquipoCargoUpdateWithoutPmEquipoInput>, EquipoCargoUncheckedUpdateWithoutPmEquipoInput>
  }

  export type PmEquipoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PmEquipoCreateWithoutUsuarioInput, PmEquipoUncheckedCreateWithoutUsuarioInput> | PmEquipoCreateWithoutUsuarioInput[] | PmEquipoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutUsuarioInput | PmEquipoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PmEquipoCreateManyUsuarioInputEnvelope
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
  }

  export type PlanSemanalPartidaCreateNestedManyWithoutResponsableInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutResponsableInput, PlanSemanalPartidaUncheckedCreateWithoutResponsableInput> | PlanSemanalPartidaCreateWithoutResponsableInput[] | PlanSemanalPartidaUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutResponsableInput | PlanSemanalPartidaCreateOrConnectWithoutResponsableInput[]
    createMany?: PlanSemanalPartidaCreateManyResponsableInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PmEquipoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PmEquipoCreateWithoutUsuarioInput, PmEquipoUncheckedCreateWithoutUsuarioInput> | PmEquipoCreateWithoutUsuarioInput[] | PmEquipoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutUsuarioInput | PmEquipoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PmEquipoCreateManyUsuarioInputEnvelope
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
  }

  export type PlanSemanalPartidaUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutResponsableInput, PlanSemanalPartidaUncheckedCreateWithoutResponsableInput> | PlanSemanalPartidaCreateWithoutResponsableInput[] | PlanSemanalPartidaUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutResponsableInput | PlanSemanalPartidaCreateOrConnectWithoutResponsableInput[]
    createMany?: PlanSemanalPartidaCreateManyResponsableInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PmEquipoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PmEquipoCreateWithoutUsuarioInput, PmEquipoUncheckedCreateWithoutUsuarioInput> | PmEquipoCreateWithoutUsuarioInput[] | PmEquipoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutUsuarioInput | PmEquipoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PmEquipoUpsertWithWhereUniqueWithoutUsuarioInput | PmEquipoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PmEquipoCreateManyUsuarioInputEnvelope
    set?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    disconnect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    delete?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    update?: PmEquipoUpdateWithWhereUniqueWithoutUsuarioInput | PmEquipoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PmEquipoUpdateManyWithWhereWithoutUsuarioInput | PmEquipoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
  }

  export type PlanSemanalPartidaUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutResponsableInput, PlanSemanalPartidaUncheckedCreateWithoutResponsableInput> | PlanSemanalPartidaCreateWithoutResponsableInput[] | PlanSemanalPartidaUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutResponsableInput | PlanSemanalPartidaCreateOrConnectWithoutResponsableInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutResponsableInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: PlanSemanalPartidaCreateManyResponsableInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutResponsableInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutResponsableInput | PlanSemanalPartidaUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type PmEquipoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PmEquipoCreateWithoutUsuarioInput, PmEquipoUncheckedCreateWithoutUsuarioInput> | PmEquipoCreateWithoutUsuarioInput[] | PmEquipoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PmEquipoCreateOrConnectWithoutUsuarioInput | PmEquipoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PmEquipoUpsertWithWhereUniqueWithoutUsuarioInput | PmEquipoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PmEquipoCreateManyUsuarioInputEnvelope
    set?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    disconnect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    delete?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    connect?: PmEquipoWhereUniqueInput | PmEquipoWhereUniqueInput[]
    update?: PmEquipoUpdateWithWhereUniqueWithoutUsuarioInput | PmEquipoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PmEquipoUpdateManyWithWhereWithoutUsuarioInput | PmEquipoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutResponsableInput, PlanSemanalPartidaUncheckedCreateWithoutResponsableInput> | PlanSemanalPartidaCreateWithoutResponsableInput[] | PlanSemanalPartidaUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutResponsableInput | PlanSemanalPartidaCreateOrConnectWithoutResponsableInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutResponsableInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: PlanSemanalPartidaCreateManyResponsableInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutResponsableInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutResponsableInput | PlanSemanalPartidaUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type ViviendaCreateNestedManyWithoutModeloViviendaInput = {
    create?: XOR<ViviendaCreateWithoutModeloViviendaInput, ViviendaUncheckedCreateWithoutModeloViviendaInput> | ViviendaCreateWithoutModeloViviendaInput[] | ViviendaUncheckedCreateWithoutModeloViviendaInput[]
    connectOrCreate?: ViviendaCreateOrConnectWithoutModeloViviendaInput | ViviendaCreateOrConnectWithoutModeloViviendaInput[]
    createMany?: ViviendaCreateManyModeloViviendaInputEnvelope
    connect?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
  }

  export type ViviendaUncheckedCreateNestedManyWithoutModeloViviendaInput = {
    create?: XOR<ViviendaCreateWithoutModeloViviendaInput, ViviendaUncheckedCreateWithoutModeloViviendaInput> | ViviendaCreateWithoutModeloViviendaInput[] | ViviendaUncheckedCreateWithoutModeloViviendaInput[]
    connectOrCreate?: ViviendaCreateOrConnectWithoutModeloViviendaInput | ViviendaCreateOrConnectWithoutModeloViviendaInput[]
    createMany?: ViviendaCreateManyModeloViviendaInputEnvelope
    connect?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
  }

  export type ViviendaUpdateManyWithoutModeloViviendaNestedInput = {
    create?: XOR<ViviendaCreateWithoutModeloViviendaInput, ViviendaUncheckedCreateWithoutModeloViviendaInput> | ViviendaCreateWithoutModeloViviendaInput[] | ViviendaUncheckedCreateWithoutModeloViviendaInput[]
    connectOrCreate?: ViviendaCreateOrConnectWithoutModeloViviendaInput | ViviendaCreateOrConnectWithoutModeloViviendaInput[]
    upsert?: ViviendaUpsertWithWhereUniqueWithoutModeloViviendaInput | ViviendaUpsertWithWhereUniqueWithoutModeloViviendaInput[]
    createMany?: ViviendaCreateManyModeloViviendaInputEnvelope
    set?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    disconnect?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    delete?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    connect?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    update?: ViviendaUpdateWithWhereUniqueWithoutModeloViviendaInput | ViviendaUpdateWithWhereUniqueWithoutModeloViviendaInput[]
    updateMany?: ViviendaUpdateManyWithWhereWithoutModeloViviendaInput | ViviendaUpdateManyWithWhereWithoutModeloViviendaInput[]
    deleteMany?: ViviendaScalarWhereInput | ViviendaScalarWhereInput[]
  }

  export type ViviendaUncheckedUpdateManyWithoutModeloViviendaNestedInput = {
    create?: XOR<ViviendaCreateWithoutModeloViviendaInput, ViviendaUncheckedCreateWithoutModeloViviendaInput> | ViviendaCreateWithoutModeloViviendaInput[] | ViviendaUncheckedCreateWithoutModeloViviendaInput[]
    connectOrCreate?: ViviendaCreateOrConnectWithoutModeloViviendaInput | ViviendaCreateOrConnectWithoutModeloViviendaInput[]
    upsert?: ViviendaUpsertWithWhereUniqueWithoutModeloViviendaInput | ViviendaUpsertWithWhereUniqueWithoutModeloViviendaInput[]
    createMany?: ViviendaCreateManyModeloViviendaInputEnvelope
    set?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    disconnect?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    delete?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    connect?: ViviendaWhereUniqueInput | ViviendaWhereUniqueInput[]
    update?: ViviendaUpdateWithWhereUniqueWithoutModeloViviendaInput | ViviendaUpdateWithWhereUniqueWithoutModeloViviendaInput[]
    updateMany?: ViviendaUpdateManyWithWhereWithoutModeloViviendaInput | ViviendaUpdateManyWithWhereWithoutModeloViviendaInput[]
    deleteMany?: ViviendaScalarWhereInput | ViviendaScalarWhereInput[]
  }

  export type PlanMaestroCreateNestedManyWithoutProyectoInput = {
    create?: XOR<PlanMaestroCreateWithoutProyectoInput, PlanMaestroUncheckedCreateWithoutProyectoInput> | PlanMaestroCreateWithoutProyectoInput[] | PlanMaestroUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutProyectoInput | PlanMaestroCreateOrConnectWithoutProyectoInput[]
    createMany?: PlanMaestroCreateManyProyectoInputEnvelope
    connect?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
  }

  export type PlanMaestroUncheckedCreateNestedManyWithoutProyectoInput = {
    create?: XOR<PlanMaestroCreateWithoutProyectoInput, PlanMaestroUncheckedCreateWithoutProyectoInput> | PlanMaestroCreateWithoutProyectoInput[] | PlanMaestroUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutProyectoInput | PlanMaestroCreateOrConnectWithoutProyectoInput[]
    createMany?: PlanMaestroCreateManyProyectoInputEnvelope
    connect?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
  }

  export type PlanMaestroUpdateManyWithoutProyectoNestedInput = {
    create?: XOR<PlanMaestroCreateWithoutProyectoInput, PlanMaestroUncheckedCreateWithoutProyectoInput> | PlanMaestroCreateWithoutProyectoInput[] | PlanMaestroUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutProyectoInput | PlanMaestroCreateOrConnectWithoutProyectoInput[]
    upsert?: PlanMaestroUpsertWithWhereUniqueWithoutProyectoInput | PlanMaestroUpsertWithWhereUniqueWithoutProyectoInput[]
    createMany?: PlanMaestroCreateManyProyectoInputEnvelope
    set?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    disconnect?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    delete?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    connect?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    update?: PlanMaestroUpdateWithWhereUniqueWithoutProyectoInput | PlanMaestroUpdateWithWhereUniqueWithoutProyectoInput[]
    updateMany?: PlanMaestroUpdateManyWithWhereWithoutProyectoInput | PlanMaestroUpdateManyWithWhereWithoutProyectoInput[]
    deleteMany?: PlanMaestroScalarWhereInput | PlanMaestroScalarWhereInput[]
  }

  export type PlanMaestroUncheckedUpdateManyWithoutProyectoNestedInput = {
    create?: XOR<PlanMaestroCreateWithoutProyectoInput, PlanMaestroUncheckedCreateWithoutProyectoInput> | PlanMaestroCreateWithoutProyectoInput[] | PlanMaestroUncheckedCreateWithoutProyectoInput[]
    connectOrCreate?: PlanMaestroCreateOrConnectWithoutProyectoInput | PlanMaestroCreateOrConnectWithoutProyectoInput[]
    upsert?: PlanMaestroUpsertWithWhereUniqueWithoutProyectoInput | PlanMaestroUpsertWithWhereUniqueWithoutProyectoInput[]
    createMany?: PlanMaestroCreateManyProyectoInputEnvelope
    set?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    disconnect?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    delete?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    connect?: PlanMaestroWhereUniqueInput | PlanMaestroWhereUniqueInput[]
    update?: PlanMaestroUpdateWithWhereUniqueWithoutProyectoInput | PlanMaestroUpdateWithWhereUniqueWithoutProyectoInput[]
    updateMany?: PlanMaestroUpdateManyWithWhereWithoutProyectoInput | PlanMaestroUpdateManyWithWhereWithoutProyectoInput[]
    deleteMany?: PlanMaestroScalarWhereInput | PlanMaestroScalarWhereInput[]
  }

  export type ModeloViviendaCreateNestedOneWithoutViviendaInput = {
    create?: XOR<ModeloViviendaCreateWithoutViviendaInput, ModeloViviendaUncheckedCreateWithoutViviendaInput>
    connectOrCreate?: ModeloViviendaCreateOrConnectWithoutViviendaInput
    connect?: ModeloViviendaWhereUniqueInput
  }

  export type PlanSemanalPartidaCreateNestedManyWithoutViviendaInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutViviendaInput, PlanSemanalPartidaUncheckedCreateWithoutViviendaInput> | PlanSemanalPartidaCreateWithoutViviendaInput[] | PlanSemanalPartidaUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutViviendaInput | PlanSemanalPartidaCreateOrConnectWithoutViviendaInput[]
    createMany?: PlanSemanalPartidaCreateManyViviendaInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PmProgramacionCreateNestedManyWithoutViviendaInput = {
    create?: XOR<PmProgramacionCreateWithoutViviendaInput, PmProgramacionUncheckedCreateWithoutViviendaInput> | PmProgramacionCreateWithoutViviendaInput[] | PmProgramacionUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutViviendaInput | PmProgramacionCreateOrConnectWithoutViviendaInput[]
    createMany?: PmProgramacionCreateManyViviendaInputEnvelope
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
  }

  export type PlanSemanalPartidaUncheckedCreateNestedManyWithoutViviendaInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutViviendaInput, PlanSemanalPartidaUncheckedCreateWithoutViviendaInput> | PlanSemanalPartidaCreateWithoutViviendaInput[] | PlanSemanalPartidaUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutViviendaInput | PlanSemanalPartidaCreateOrConnectWithoutViviendaInput[]
    createMany?: PlanSemanalPartidaCreateManyViviendaInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PmProgramacionUncheckedCreateNestedManyWithoutViviendaInput = {
    create?: XOR<PmProgramacionCreateWithoutViviendaInput, PmProgramacionUncheckedCreateWithoutViviendaInput> | PmProgramacionCreateWithoutViviendaInput[] | PmProgramacionUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutViviendaInput | PmProgramacionCreateOrConnectWithoutViviendaInput[]
    createMany?: PmProgramacionCreateManyViviendaInputEnvelope
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
  }

  export type ModeloViviendaUpdateOneRequiredWithoutViviendaNestedInput = {
    create?: XOR<ModeloViviendaCreateWithoutViviendaInput, ModeloViviendaUncheckedCreateWithoutViviendaInput>
    connectOrCreate?: ModeloViviendaCreateOrConnectWithoutViviendaInput
    upsert?: ModeloViviendaUpsertWithoutViviendaInput
    connect?: ModeloViviendaWhereUniqueInput
    update?: XOR<XOR<ModeloViviendaUpdateToOneWithWhereWithoutViviendaInput, ModeloViviendaUpdateWithoutViviendaInput>, ModeloViviendaUncheckedUpdateWithoutViviendaInput>
  }

  export type PlanSemanalPartidaUpdateManyWithoutViviendaNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutViviendaInput, PlanSemanalPartidaUncheckedCreateWithoutViviendaInput> | PlanSemanalPartidaCreateWithoutViviendaInput[] | PlanSemanalPartidaUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutViviendaInput | PlanSemanalPartidaCreateOrConnectWithoutViviendaInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutViviendaInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutViviendaInput[]
    createMany?: PlanSemanalPartidaCreateManyViviendaInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutViviendaInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutViviendaInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutViviendaInput | PlanSemanalPartidaUpdateManyWithWhereWithoutViviendaInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type PmProgramacionUpdateManyWithoutViviendaNestedInput = {
    create?: XOR<PmProgramacionCreateWithoutViviendaInput, PmProgramacionUncheckedCreateWithoutViviendaInput> | PmProgramacionCreateWithoutViviendaInput[] | PmProgramacionUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutViviendaInput | PmProgramacionCreateOrConnectWithoutViviendaInput[]
    upsert?: PmProgramacionUpsertWithWhereUniqueWithoutViviendaInput | PmProgramacionUpsertWithWhereUniqueWithoutViviendaInput[]
    createMany?: PmProgramacionCreateManyViviendaInputEnvelope
    set?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    disconnect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    delete?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    update?: PmProgramacionUpdateWithWhereUniqueWithoutViviendaInput | PmProgramacionUpdateWithWhereUniqueWithoutViviendaInput[]
    updateMany?: PmProgramacionUpdateManyWithWhereWithoutViviendaInput | PmProgramacionUpdateManyWithWhereWithoutViviendaInput[]
    deleteMany?: PmProgramacionScalarWhereInput | PmProgramacionScalarWhereInput[]
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutViviendaNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutViviendaInput, PlanSemanalPartidaUncheckedCreateWithoutViviendaInput> | PlanSemanalPartidaCreateWithoutViviendaInput[] | PlanSemanalPartidaUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutViviendaInput | PlanSemanalPartidaCreateOrConnectWithoutViviendaInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutViviendaInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutViviendaInput[]
    createMany?: PlanSemanalPartidaCreateManyViviendaInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutViviendaInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutViviendaInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutViviendaInput | PlanSemanalPartidaUpdateManyWithWhereWithoutViviendaInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type PmProgramacionUncheckedUpdateManyWithoutViviendaNestedInput = {
    create?: XOR<PmProgramacionCreateWithoutViviendaInput, PmProgramacionUncheckedCreateWithoutViviendaInput> | PmProgramacionCreateWithoutViviendaInput[] | PmProgramacionUncheckedCreateWithoutViviendaInput[]
    connectOrCreate?: PmProgramacionCreateOrConnectWithoutViviendaInput | PmProgramacionCreateOrConnectWithoutViviendaInput[]
    upsert?: PmProgramacionUpsertWithWhereUniqueWithoutViviendaInput | PmProgramacionUpsertWithWhereUniqueWithoutViviendaInput[]
    createMany?: PmProgramacionCreateManyViviendaInputEnvelope
    set?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    disconnect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    delete?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    connect?: PmProgramacionWhereUniqueInput | PmProgramacionWhereUniqueInput[]
    update?: PmProgramacionUpdateWithWhereUniqueWithoutViviendaInput | PmProgramacionUpdateWithWhereUniqueWithoutViviendaInput[]
    updateMany?: PmProgramacionUpdateManyWithWhereWithoutViviendaInput | PmProgramacionUpdateManyWithWhereWithoutViviendaInput[]
    deleteMany?: PmProgramacionScalarWhereInput | PmProgramacionScalarWhereInput[]
  }

  export type PmFrenteCreateNestedOneWithoutPlanSemanalInput = {
    create?: XOR<PmFrenteCreateWithoutPlanSemanalInput, PmFrenteUncheckedCreateWithoutPlanSemanalInput>
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPlanSemanalInput
    connect?: PmFrenteWhereUniqueInput
  }

  export type PmFrenteUpdateOneRequiredWithoutPlanSemanalNestedInput = {
    create?: XOR<PmFrenteCreateWithoutPlanSemanalInput, PmFrenteUncheckedCreateWithoutPlanSemanalInput>
    connectOrCreate?: PmFrenteCreateOrConnectWithoutPlanSemanalInput
    upsert?: PmFrenteUpsertWithoutPlanSemanalInput
    connect?: PmFrenteWhereUniqueInput
    update?: XOR<XOR<PmFrenteUpdateToOneWithWhereWithoutPlanSemanalInput, PmFrenteUpdateWithoutPlanSemanalInput>, PmFrenteUncheckedUpdateWithoutPlanSemanalInput>
  }

  export type PartidaCreateNestedOneWithoutPlanSemanalPartidaInput = {
    create?: XOR<PartidaCreateWithoutPlanSemanalPartidaInput, PartidaUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: PartidaCreateOrConnectWithoutPlanSemanalPartidaInput
    connect?: PartidaWhereUniqueInput
  }

  export type ViviendaCreateNestedOneWithoutPlanSemanalPartidaInput = {
    create?: XOR<ViviendaCreateWithoutPlanSemanalPartidaInput, ViviendaUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: ViviendaCreateOrConnectWithoutPlanSemanalPartidaInput
    connect?: ViviendaWhereUniqueInput
  }

  export type CausaNoCumplimientoCreateNestedOneWithoutPlanSemanalPartidaInput = {
    create?: XOR<CausaNoCumplimientoCreateWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: CausaNoCumplimientoCreateOrConnectWithoutPlanSemanalPartidaInput
    connect?: CausaNoCumplimientoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPlanSemanalPartidaInput = {
    create?: XOR<UsuarioCreateWithoutPlanSemanalPartidaInput, UsuarioUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPlanSemanalPartidaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PartidaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput = {
    create?: XOR<PartidaCreateWithoutPlanSemanalPartidaInput, PartidaUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: PartidaCreateOrConnectWithoutPlanSemanalPartidaInput
    upsert?: PartidaUpsertWithoutPlanSemanalPartidaInput
    connect?: PartidaWhereUniqueInput
    update?: XOR<XOR<PartidaUpdateToOneWithWhereWithoutPlanSemanalPartidaInput, PartidaUpdateWithoutPlanSemanalPartidaInput>, PartidaUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type ViviendaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput = {
    create?: XOR<ViviendaCreateWithoutPlanSemanalPartidaInput, ViviendaUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: ViviendaCreateOrConnectWithoutPlanSemanalPartidaInput
    upsert?: ViviendaUpsertWithoutPlanSemanalPartidaInput
    connect?: ViviendaWhereUniqueInput
    update?: XOR<XOR<ViviendaUpdateToOneWithWhereWithoutPlanSemanalPartidaInput, ViviendaUpdateWithoutPlanSemanalPartidaInput>, ViviendaUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type CausaNoCumplimientoUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput = {
    create?: XOR<CausaNoCumplimientoCreateWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: CausaNoCumplimientoCreateOrConnectWithoutPlanSemanalPartidaInput
    upsert?: CausaNoCumplimientoUpsertWithoutPlanSemanalPartidaInput
    connect?: CausaNoCumplimientoWhereUniqueInput
    update?: XOR<XOR<CausaNoCumplimientoUpdateToOneWithWhereWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUpdateWithoutPlanSemanalPartidaInput>, CausaNoCumplimientoUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput = {
    create?: XOR<UsuarioCreateWithoutPlanSemanalPartidaInput, UsuarioUncheckedCreateWithoutPlanSemanalPartidaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPlanSemanalPartidaInput
    upsert?: UsuarioUpsertWithoutPlanSemanalPartidaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPlanSemanalPartidaInput, UsuarioUpdateWithoutPlanSemanalPartidaInput>, UsuarioUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type PlanSemanalPartidaCreateNestedManyWithoutCausaNoCumplimientoInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput> | PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput[] | PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput | PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput[]
    createMany?: PlanSemanalPartidaCreateManyCausaNoCumplimientoInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PlanSemanalPartidaUncheckedCreateNestedManyWithoutCausaNoCumplimientoInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput> | PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput[] | PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput | PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput[]
    createMany?: PlanSemanalPartidaCreateManyCausaNoCumplimientoInputEnvelope
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
  }

  export type PlanSemanalPartidaUpdateManyWithoutCausaNoCumplimientoNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput> | PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput[] | PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput | PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutCausaNoCumplimientoInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutCausaNoCumplimientoInput[]
    createMany?: PlanSemanalPartidaCreateManyCausaNoCumplimientoInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutCausaNoCumplimientoInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutCausaNoCumplimientoInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutCausaNoCumplimientoInput | PlanSemanalPartidaUpdateManyWithWhereWithoutCausaNoCumplimientoInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutCausaNoCumplimientoNestedInput = {
    create?: XOR<PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput> | PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput[] | PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput[]
    connectOrCreate?: PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput | PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput[]
    upsert?: PlanSemanalPartidaUpsertWithWhereUniqueWithoutCausaNoCumplimientoInput | PlanSemanalPartidaUpsertWithWhereUniqueWithoutCausaNoCumplimientoInput[]
    createMany?: PlanSemanalPartidaCreateManyCausaNoCumplimientoInputEnvelope
    set?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    disconnect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    delete?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    connect?: PlanSemanalPartidaWhereUniqueInput | PlanSemanalPartidaWhereUniqueInput[]
    update?: PlanSemanalPartidaUpdateWithWhereUniqueWithoutCausaNoCumplimientoInput | PlanSemanalPartidaUpdateWithWhereUniqueWithoutCausaNoCumplimientoInput[]
    updateMany?: PlanSemanalPartidaUpdateManyWithWhereWithoutCausaNoCumplimientoInput | PlanSemanalPartidaUpdateManyWithWhereWithoutCausaNoCumplimientoInput[]
    deleteMany?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PartidaCreateWithoutHitoInput = {
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    procesoConstrutivo: ProcesoConstrutivoCreateNestedOneWithoutPartidaInput
    paqueteTrabajo: PaqueteTrabajoCreateNestedOneWithoutPartidaInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUncheckedCreateWithoutHitoInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutPartidaInput
  }

  export type PartidaCreateOrConnectWithoutHitoInput = {
    where: PartidaWhereUniqueInput
    create: XOR<PartidaCreateWithoutHitoInput, PartidaUncheckedCreateWithoutHitoInput>
  }

  export type PartidaCreateManyHitoInputEnvelope = {
    data: PartidaCreateManyHitoInput | PartidaCreateManyHitoInput[]
    skipDuplicates?: boolean
  }

  export type PartidaUpsertWithWhereUniqueWithoutHitoInput = {
    where: PartidaWhereUniqueInput
    update: XOR<PartidaUpdateWithoutHitoInput, PartidaUncheckedUpdateWithoutHitoInput>
    create: XOR<PartidaCreateWithoutHitoInput, PartidaUncheckedCreateWithoutHitoInput>
  }

  export type PartidaUpdateWithWhereUniqueWithoutHitoInput = {
    where: PartidaWhereUniqueInput
    data: XOR<PartidaUpdateWithoutHitoInput, PartidaUncheckedUpdateWithoutHitoInput>
  }

  export type PartidaUpdateManyWithWhereWithoutHitoInput = {
    where: PartidaScalarWhereInput
    data: XOR<PartidaUpdateManyMutationInput, PartidaUncheckedUpdateManyWithoutHitoInput>
  }

  export type PartidaScalarWhereInput = {
    AND?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
    OR?: PartidaScalarWhereInput[]
    NOT?: PartidaScalarWhereInput | PartidaScalarWhereInput[]
    id_Partida?: IntFilter<"Partida"> | number
    nombre?: StringFilter<"Partida"> | string
    medida?: StringFilter<"Partida"> | string
    ritmo?: StringFilter<"Partida"> | string
    cuadrillasSugeridas?: IntFilter<"Partida"> | number
    hitoId?: IntFilter<"Partida"> | number
    procesoConstrutivoId?: IntFilter<"Partida"> | number
    paqueteTrabajoId?: IntFilter<"Partida"> | number
  }

  export type PartidaCreateWithoutPaqueteTrabajoInput = {
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hito: HitoCreateNestedOneWithoutPartidaInput
    procesoConstrutivo: ProcesoConstrutivoCreateNestedOneWithoutPartidaInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUncheckedCreateWithoutPaqueteTrabajoInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutPartidaInput
  }

  export type PartidaCreateOrConnectWithoutPaqueteTrabajoInput = {
    where: PartidaWhereUniqueInput
    create: XOR<PartidaCreateWithoutPaqueteTrabajoInput, PartidaUncheckedCreateWithoutPaqueteTrabajoInput>
  }

  export type PartidaCreateManyPaqueteTrabajoInputEnvelope = {
    data: PartidaCreateManyPaqueteTrabajoInput | PartidaCreateManyPaqueteTrabajoInput[]
    skipDuplicates?: boolean
  }

  export type PartidaUpsertWithWhereUniqueWithoutPaqueteTrabajoInput = {
    where: PartidaWhereUniqueInput
    update: XOR<PartidaUpdateWithoutPaqueteTrabajoInput, PartidaUncheckedUpdateWithoutPaqueteTrabajoInput>
    create: XOR<PartidaCreateWithoutPaqueteTrabajoInput, PartidaUncheckedCreateWithoutPaqueteTrabajoInput>
  }

  export type PartidaUpdateWithWhereUniqueWithoutPaqueteTrabajoInput = {
    where: PartidaWhereUniqueInput
    data: XOR<PartidaUpdateWithoutPaqueteTrabajoInput, PartidaUncheckedUpdateWithoutPaqueteTrabajoInput>
  }

  export type PartidaUpdateManyWithWhereWithoutPaqueteTrabajoInput = {
    where: PartidaScalarWhereInput
    data: XOR<PartidaUpdateManyMutationInput, PartidaUncheckedUpdateManyWithoutPaqueteTrabajoInput>
  }

  export type HitoCreateWithoutPartidaInput = {
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HitoUncheckedCreateWithoutPartidaInput = {
    id_Hito?: number
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HitoCreateOrConnectWithoutPartidaInput = {
    where: HitoWhereUniqueInput
    create: XOR<HitoCreateWithoutPartidaInput, HitoUncheckedCreateWithoutPartidaInput>
  }

  export type ProcesoConstrutivoCreateWithoutPartidaInput = {
    nombre: string
    descripcion: string
    jerarquia: number
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcesoConstrutivoUncheckedCreateWithoutPartidaInput = {
    id_ProcesoConstrutivo?: number
    nombre: string
    descripcion: string
    jerarquia: number
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcesoConstrutivoCreateOrConnectWithoutPartidaInput = {
    where: ProcesoConstrutivoWhereUniqueInput
    create: XOR<ProcesoConstrutivoCreateWithoutPartidaInput, ProcesoConstrutivoUncheckedCreateWithoutPartidaInput>
  }

  export type PaqueteTrabajoCreateWithoutPartidaInput = {
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTrabajoUncheckedCreateWithoutPartidaInput = {
    id_PaqueteTrabajo?: number
    nombre: string
    descripcion: string
    esActivo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTrabajoCreateOrConnectWithoutPartidaInput = {
    where: PaqueteTrabajoWhereUniqueInput
    create: XOR<PaqueteTrabajoCreateWithoutPartidaInput, PaqueteTrabajoUncheckedCreateWithoutPartidaInput>
  }

  export type PmFrentePartidaCreateWithoutPartidaInput = {
    cuadrilla: number
    orden: number
    frente: PmFrenteCreateNestedOneWithoutPmFrentePartidasInput
    pmProgramacion?: PmProgramacionCreateNestedManyWithoutPmFrentePartidaInput
  }

  export type PmFrentePartidaUncheckedCreateWithoutPartidaInput = {
    id_PmFrentePartida?: number
    cuadrilla: number
    frenteId: number
    orden: number
    pmProgramacion?: PmProgramacionUncheckedCreateNestedManyWithoutPmFrentePartidaInput
  }

  export type PmFrentePartidaCreateOrConnectWithoutPartidaInput = {
    where: PmFrentePartidaWhereUniqueInput
    create: XOR<PmFrentePartidaCreateWithoutPartidaInput, PmFrentePartidaUncheckedCreateWithoutPartidaInput>
  }

  export type PmFrentePartidaCreateManyPartidaInputEnvelope = {
    data: PmFrentePartidaCreateManyPartidaInput | PmFrentePartidaCreateManyPartidaInput[]
    skipDuplicates?: boolean
  }

  export type PlanSemanalPartidaCreateWithoutPartidaInput = {
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
    vivienda: ViviendaCreateNestedOneWithoutPlanSemanalPartidaInput
    causaNoCumplimiento: CausaNoCumplimientoCreateNestedOneWithoutPlanSemanalPartidaInput
    responsable: UsuarioCreateNestedOneWithoutPlanSemanalPartidaInput
  }

  export type PlanSemanalPartidaUncheckedCreateWithoutPartidaInput = {
    id_PlanSemanalPartida?: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaCreateOrConnectWithoutPartidaInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    create: XOR<PlanSemanalPartidaCreateWithoutPartidaInput, PlanSemanalPartidaUncheckedCreateWithoutPartidaInput>
  }

  export type PlanSemanalPartidaCreateManyPartidaInputEnvelope = {
    data: PlanSemanalPartidaCreateManyPartidaInput | PlanSemanalPartidaCreateManyPartidaInput[]
    skipDuplicates?: boolean
  }

  export type HitoUpsertWithoutPartidaInput = {
    update: XOR<HitoUpdateWithoutPartidaInput, HitoUncheckedUpdateWithoutPartidaInput>
    create: XOR<HitoCreateWithoutPartidaInput, HitoUncheckedCreateWithoutPartidaInput>
    where?: HitoWhereInput
  }

  export type HitoUpdateToOneWithWhereWithoutPartidaInput = {
    where?: HitoWhereInput
    data: XOR<HitoUpdateWithoutPartidaInput, HitoUncheckedUpdateWithoutPartidaInput>
  }

  export type HitoUpdateWithoutPartidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HitoUncheckedUpdateWithoutPartidaInput = {
    id_Hito?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcesoConstrutivoUpsertWithoutPartidaInput = {
    update: XOR<ProcesoConstrutivoUpdateWithoutPartidaInput, ProcesoConstrutivoUncheckedUpdateWithoutPartidaInput>
    create: XOR<ProcesoConstrutivoCreateWithoutPartidaInput, ProcesoConstrutivoUncheckedCreateWithoutPartidaInput>
    where?: ProcesoConstrutivoWhereInput
  }

  export type ProcesoConstrutivoUpdateToOneWithWhereWithoutPartidaInput = {
    where?: ProcesoConstrutivoWhereInput
    data: XOR<ProcesoConstrutivoUpdateWithoutPartidaInput, ProcesoConstrutivoUncheckedUpdateWithoutPartidaInput>
  }

  export type ProcesoConstrutivoUpdateWithoutPartidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcesoConstrutivoUncheckedUpdateWithoutPartidaInput = {
    id_ProcesoConstrutivo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    jerarquia?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTrabajoUpsertWithoutPartidaInput = {
    update: XOR<PaqueteTrabajoUpdateWithoutPartidaInput, PaqueteTrabajoUncheckedUpdateWithoutPartidaInput>
    create: XOR<PaqueteTrabajoCreateWithoutPartidaInput, PaqueteTrabajoUncheckedCreateWithoutPartidaInput>
    where?: PaqueteTrabajoWhereInput
  }

  export type PaqueteTrabajoUpdateToOneWithWhereWithoutPartidaInput = {
    where?: PaqueteTrabajoWhereInput
    data: XOR<PaqueteTrabajoUpdateWithoutPartidaInput, PaqueteTrabajoUncheckedUpdateWithoutPartidaInput>
  }

  export type PaqueteTrabajoUpdateWithoutPartidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTrabajoUncheckedUpdateWithoutPartidaInput = {
    id_PaqueteTrabajo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PmFrentePartidaUpsertWithWhereUniqueWithoutPartidaInput = {
    where: PmFrentePartidaWhereUniqueInput
    update: XOR<PmFrentePartidaUpdateWithoutPartidaInput, PmFrentePartidaUncheckedUpdateWithoutPartidaInput>
    create: XOR<PmFrentePartidaCreateWithoutPartidaInput, PmFrentePartidaUncheckedCreateWithoutPartidaInput>
  }

  export type PmFrentePartidaUpdateWithWhereUniqueWithoutPartidaInput = {
    where: PmFrentePartidaWhereUniqueInput
    data: XOR<PmFrentePartidaUpdateWithoutPartidaInput, PmFrentePartidaUncheckedUpdateWithoutPartidaInput>
  }

  export type PmFrentePartidaUpdateManyWithWhereWithoutPartidaInput = {
    where: PmFrentePartidaScalarWhereInput
    data: XOR<PmFrentePartidaUpdateManyMutationInput, PmFrentePartidaUncheckedUpdateManyWithoutPartidaInput>
  }

  export type PmFrentePartidaScalarWhereInput = {
    AND?: PmFrentePartidaScalarWhereInput | PmFrentePartidaScalarWhereInput[]
    OR?: PmFrentePartidaScalarWhereInput[]
    NOT?: PmFrentePartidaScalarWhereInput | PmFrentePartidaScalarWhereInput[]
    id_PmFrentePartida?: IntFilter<"PmFrentePartida"> | number
    partidaId?: IntFilter<"PmFrentePartida"> | number
    cuadrilla?: IntFilter<"PmFrentePartida"> | number
    frenteId?: IntFilter<"PmFrentePartida"> | number
    orden?: IntFilter<"PmFrentePartida"> | number
  }

  export type PlanSemanalPartidaUpsertWithWhereUniqueWithoutPartidaInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    update: XOR<PlanSemanalPartidaUpdateWithoutPartidaInput, PlanSemanalPartidaUncheckedUpdateWithoutPartidaInput>
    create: XOR<PlanSemanalPartidaCreateWithoutPartidaInput, PlanSemanalPartidaUncheckedCreateWithoutPartidaInput>
  }

  export type PlanSemanalPartidaUpdateWithWhereUniqueWithoutPartidaInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    data: XOR<PlanSemanalPartidaUpdateWithoutPartidaInput, PlanSemanalPartidaUncheckedUpdateWithoutPartidaInput>
  }

  export type PlanSemanalPartidaUpdateManyWithWhereWithoutPartidaInput = {
    where: PlanSemanalPartidaScalarWhereInput
    data: XOR<PlanSemanalPartidaUpdateManyMutationInput, PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaInput>
  }

  export type PlanSemanalPartidaScalarWhereInput = {
    AND?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
    OR?: PlanSemanalPartidaScalarWhereInput[]
    NOT?: PlanSemanalPartidaScalarWhereInput | PlanSemanalPartidaScalarWhereInput[]
    id_PlanSemanalPartida?: IntFilter<"PlanSemanalPartida"> | number
    partidaId?: IntFilter<"PlanSemanalPartida"> | number
    viviendaId?: IntFilter<"PlanSemanalPartida"> | number
    revisionOk?: BoolFilter<"PlanSemanalPartida"> | boolean
    id_UsuarioRevision?: IntFilter<"PlanSemanalPartida"> | number
    fechaRevision?: DateTimeFilter<"PlanSemanalPartida"> | Date | string
    causaNoCumplimientoId?: IntFilter<"PlanSemanalPartida"> | number
    observacion?: StringFilter<"PlanSemanalPartida"> | string
    responsableId?: IntFilter<"PlanSemanalPartida"> | number
    cantidadProgramada?: DecimalFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFilter<"PlanSemanalPartida"> | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFilter<"PlanSemanalPartida"> | number
  }

  export type PartidaCreateWithoutProcesoConstrutivoInput = {
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hito: HitoCreateNestedOneWithoutPartidaInput
    paqueteTrabajo: PaqueteTrabajoCreateNestedOneWithoutPartidaInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUncheckedCreateWithoutProcesoConstrutivoInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    paqueteTrabajoId: number
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutPartidaInput
  }

  export type PartidaCreateOrConnectWithoutProcesoConstrutivoInput = {
    where: PartidaWhereUniqueInput
    create: XOR<PartidaCreateWithoutProcesoConstrutivoInput, PartidaUncheckedCreateWithoutProcesoConstrutivoInput>
  }

  export type PartidaCreateManyProcesoConstrutivoInputEnvelope = {
    data: PartidaCreateManyProcesoConstrutivoInput | PartidaCreateManyProcesoConstrutivoInput[]
    skipDuplicates?: boolean
  }

  export type PartidaUpsertWithWhereUniqueWithoutProcesoConstrutivoInput = {
    where: PartidaWhereUniqueInput
    update: XOR<PartidaUpdateWithoutProcesoConstrutivoInput, PartidaUncheckedUpdateWithoutProcesoConstrutivoInput>
    create: XOR<PartidaCreateWithoutProcesoConstrutivoInput, PartidaUncheckedCreateWithoutProcesoConstrutivoInput>
  }

  export type PartidaUpdateWithWhereUniqueWithoutProcesoConstrutivoInput = {
    where: PartidaWhereUniqueInput
    data: XOR<PartidaUpdateWithoutProcesoConstrutivoInput, PartidaUncheckedUpdateWithoutProcesoConstrutivoInput>
  }

  export type PartidaUpdateManyWithWhereWithoutProcesoConstrutivoInput = {
    where: PartidaScalarWhereInput
    data: XOR<PartidaUpdateManyMutationInput, PartidaUncheckedUpdateManyWithoutProcesoConstrutivoInput>
  }

  export type ProyectoCreateWithoutPlanMaestroInput = {
    nombre: string
    activo?: boolean
  }

  export type ProyectoUncheckedCreateWithoutPlanMaestroInput = {
    id_Proyecto?: number
    nombre: string
    activo?: boolean
  }

  export type ProyectoCreateOrConnectWithoutPlanMaestroInput = {
    where: ProyectoWhereUniqueInput
    create: XOR<ProyectoCreateWithoutPlanMaestroInput, ProyectoUncheckedCreateWithoutPlanMaestroInput>
  }

  export type EquipoTrabajoCreateWithoutPlanMaestroInput = {
    pmEquipo?: PmEquipoCreateNestedManyWithoutEquipoTrabajoInput
  }

  export type EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput = {
    id_EquipoTrabajo?: number
    pmEquipo?: PmEquipoUncheckedCreateNestedManyWithoutEquipoTrabajoInput
  }

  export type EquipoTrabajoCreateOrConnectWithoutPlanMaestroInput = {
    where: EquipoTrabajoWhereUniqueInput
    create: XOR<EquipoTrabajoCreateWithoutPlanMaestroInput, EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput>
  }

  export type EquipoTrabajoCreateManyPlanMaestroInputEnvelope = {
    data: EquipoTrabajoCreateManyPlanMaestroInput | EquipoTrabajoCreateManyPlanMaestroInput[]
    skipDuplicates?: boolean
  }

  export type PmFrenteCreateWithoutPlanMaestroInput = {
    nombre: string
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutFrenteInput
    planSemanal?: PlanSemanalCreateNestedManyWithoutPmFrenteInput
  }

  export type PmFrenteUncheckedCreateWithoutPlanMaestroInput = {
    id_PmFrente?: number
    nombre: string
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutFrenteInput
    planSemanal?: PlanSemanalUncheckedCreateNestedManyWithoutPmFrenteInput
  }

  export type PmFrenteCreateOrConnectWithoutPlanMaestroInput = {
    where: PmFrenteWhereUniqueInput
    create: XOR<PmFrenteCreateWithoutPlanMaestroInput, PmFrenteUncheckedCreateWithoutPlanMaestroInput>
  }

  export type PmFrenteCreateManyPlanMaestroInputEnvelope = {
    data: PmFrenteCreateManyPlanMaestroInput | PmFrenteCreateManyPlanMaestroInput[]
    skipDuplicates?: boolean
  }

  export type ProyectoUpsertWithoutPlanMaestroInput = {
    update: XOR<ProyectoUpdateWithoutPlanMaestroInput, ProyectoUncheckedUpdateWithoutPlanMaestroInput>
    create: XOR<ProyectoCreateWithoutPlanMaestroInput, ProyectoUncheckedCreateWithoutPlanMaestroInput>
    where?: ProyectoWhereInput
  }

  export type ProyectoUpdateToOneWithWhereWithoutPlanMaestroInput = {
    where?: ProyectoWhereInput
    data: XOR<ProyectoUpdateWithoutPlanMaestroInput, ProyectoUncheckedUpdateWithoutPlanMaestroInput>
  }

  export type ProyectoUpdateWithoutPlanMaestroInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProyectoUncheckedUpdateWithoutPlanMaestroInput = {
    id_Proyecto?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipoTrabajoUpsertWithWhereUniqueWithoutPlanMaestroInput = {
    where: EquipoTrabajoWhereUniqueInput
    update: XOR<EquipoTrabajoUpdateWithoutPlanMaestroInput, EquipoTrabajoUncheckedUpdateWithoutPlanMaestroInput>
    create: XOR<EquipoTrabajoCreateWithoutPlanMaestroInput, EquipoTrabajoUncheckedCreateWithoutPlanMaestroInput>
  }

  export type EquipoTrabajoUpdateWithWhereUniqueWithoutPlanMaestroInput = {
    where: EquipoTrabajoWhereUniqueInput
    data: XOR<EquipoTrabajoUpdateWithoutPlanMaestroInput, EquipoTrabajoUncheckedUpdateWithoutPlanMaestroInput>
  }

  export type EquipoTrabajoUpdateManyWithWhereWithoutPlanMaestroInput = {
    where: EquipoTrabajoScalarWhereInput
    data: XOR<EquipoTrabajoUpdateManyMutationInput, EquipoTrabajoUncheckedUpdateManyWithoutPlanMaestroInput>
  }

  export type EquipoTrabajoScalarWhereInput = {
    AND?: EquipoTrabajoScalarWhereInput | EquipoTrabajoScalarWhereInput[]
    OR?: EquipoTrabajoScalarWhereInput[]
    NOT?: EquipoTrabajoScalarWhereInput | EquipoTrabajoScalarWhereInput[]
    id_EquipoTrabajo?: IntFilter<"EquipoTrabajo"> | number
    planMaestroId?: IntFilter<"EquipoTrabajo"> | number
  }

  export type PmFrenteUpsertWithWhereUniqueWithoutPlanMaestroInput = {
    where: PmFrenteWhereUniqueInput
    update: XOR<PmFrenteUpdateWithoutPlanMaestroInput, PmFrenteUncheckedUpdateWithoutPlanMaestroInput>
    create: XOR<PmFrenteCreateWithoutPlanMaestroInput, PmFrenteUncheckedCreateWithoutPlanMaestroInput>
  }

  export type PmFrenteUpdateWithWhereUniqueWithoutPlanMaestroInput = {
    where: PmFrenteWhereUniqueInput
    data: XOR<PmFrenteUpdateWithoutPlanMaestroInput, PmFrenteUncheckedUpdateWithoutPlanMaestroInput>
  }

  export type PmFrenteUpdateManyWithWhereWithoutPlanMaestroInput = {
    where: PmFrenteScalarWhereInput
    data: XOR<PmFrenteUpdateManyMutationInput, PmFrenteUncheckedUpdateManyWithoutPlanMaestroInput>
  }

  export type PmFrenteScalarWhereInput = {
    AND?: PmFrenteScalarWhereInput | PmFrenteScalarWhereInput[]
    OR?: PmFrenteScalarWhereInput[]
    NOT?: PmFrenteScalarWhereInput | PmFrenteScalarWhereInput[]
    id_PmFrente?: IntFilter<"PmFrente"> | number
    planMaestroId?: IntFilter<"PmFrente"> | number
    nombre?: StringFilter<"PmFrente"> | string
  }

  export type PlanMaestroCreateWithoutPmFrentesInput = {
    descripcion: string
    fechaInicio?: Date | string
    proyecto: ProyectoCreateNestedOneWithoutPlanMaestroInput
    equipoTrabajos?: EquipoTrabajoCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroUncheckedCreateWithoutPmFrentesInput = {
    id_PlanMaestro?: number
    descripcion: string
    fechaInicio?: Date | string
    proyectoId: number
    equipoTrabajos?: EquipoTrabajoUncheckedCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroCreateOrConnectWithoutPmFrentesInput = {
    where: PlanMaestroWhereUniqueInput
    create: XOR<PlanMaestroCreateWithoutPmFrentesInput, PlanMaestroUncheckedCreateWithoutPmFrentesInput>
  }

  export type PmFrentePartidaCreateWithoutFrenteInput = {
    cuadrilla: number
    orden: number
    partida: PartidaCreateNestedOneWithoutPmFrentePartidasInput
    pmProgramacion?: PmProgramacionCreateNestedManyWithoutPmFrentePartidaInput
  }

  export type PmFrentePartidaUncheckedCreateWithoutFrenteInput = {
    id_PmFrentePartida?: number
    partidaId: number
    cuadrilla: number
    orden: number
    pmProgramacion?: PmProgramacionUncheckedCreateNestedManyWithoutPmFrentePartidaInput
  }

  export type PmFrentePartidaCreateOrConnectWithoutFrenteInput = {
    where: PmFrentePartidaWhereUniqueInput
    create: XOR<PmFrentePartidaCreateWithoutFrenteInput, PmFrentePartidaUncheckedCreateWithoutFrenteInput>
  }

  export type PmFrentePartidaCreateManyFrenteInputEnvelope = {
    data: PmFrentePartidaCreateManyFrenteInput | PmFrentePartidaCreateManyFrenteInput[]
    skipDuplicates?: boolean
  }

  export type PlanSemanalCreateWithoutPmFrenteInput = {
    descripcion: string
    fechaInicio?: Date | string
    fechaTermino?: Date | string
  }

  export type PlanSemanalUncheckedCreateWithoutPmFrenteInput = {
    id_PlanSemanal?: number
    descripcion: string
    fechaInicio?: Date | string
    fechaTermino?: Date | string
  }

  export type PlanSemanalCreateOrConnectWithoutPmFrenteInput = {
    where: PlanSemanalWhereUniqueInput
    create: XOR<PlanSemanalCreateWithoutPmFrenteInput, PlanSemanalUncheckedCreateWithoutPmFrenteInput>
  }

  export type PlanSemanalCreateManyPmFrenteInputEnvelope = {
    data: PlanSemanalCreateManyPmFrenteInput | PlanSemanalCreateManyPmFrenteInput[]
    skipDuplicates?: boolean
  }

  export type PlanMaestroUpsertWithoutPmFrentesInput = {
    update: XOR<PlanMaestroUpdateWithoutPmFrentesInput, PlanMaestroUncheckedUpdateWithoutPmFrentesInput>
    create: XOR<PlanMaestroCreateWithoutPmFrentesInput, PlanMaestroUncheckedCreateWithoutPmFrentesInput>
    where?: PlanMaestroWhereInput
  }

  export type PlanMaestroUpdateToOneWithWhereWithoutPmFrentesInput = {
    where?: PlanMaestroWhereInput
    data: XOR<PlanMaestroUpdateWithoutPmFrentesInput, PlanMaestroUncheckedUpdateWithoutPmFrentesInput>
  }

  export type PlanMaestroUpdateWithoutPmFrentesInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProyectoUpdateOneRequiredWithoutPlanMaestroNestedInput
    equipoTrabajos?: EquipoTrabajoUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PlanMaestroUncheckedUpdateWithoutPmFrentesInput = {
    id_PlanMaestro?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    equipoTrabajos?: EquipoTrabajoUncheckedUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PmFrentePartidaUpsertWithWhereUniqueWithoutFrenteInput = {
    where: PmFrentePartidaWhereUniqueInput
    update: XOR<PmFrentePartidaUpdateWithoutFrenteInput, PmFrentePartidaUncheckedUpdateWithoutFrenteInput>
    create: XOR<PmFrentePartidaCreateWithoutFrenteInput, PmFrentePartidaUncheckedCreateWithoutFrenteInput>
  }

  export type PmFrentePartidaUpdateWithWhereUniqueWithoutFrenteInput = {
    where: PmFrentePartidaWhereUniqueInput
    data: XOR<PmFrentePartidaUpdateWithoutFrenteInput, PmFrentePartidaUncheckedUpdateWithoutFrenteInput>
  }

  export type PmFrentePartidaUpdateManyWithWhereWithoutFrenteInput = {
    where: PmFrentePartidaScalarWhereInput
    data: XOR<PmFrentePartidaUpdateManyMutationInput, PmFrentePartidaUncheckedUpdateManyWithoutFrenteInput>
  }

  export type PlanSemanalUpsertWithWhereUniqueWithoutPmFrenteInput = {
    where: PlanSemanalWhereUniqueInput
    update: XOR<PlanSemanalUpdateWithoutPmFrenteInput, PlanSemanalUncheckedUpdateWithoutPmFrenteInput>
    create: XOR<PlanSemanalCreateWithoutPmFrenteInput, PlanSemanalUncheckedCreateWithoutPmFrenteInput>
  }

  export type PlanSemanalUpdateWithWhereUniqueWithoutPmFrenteInput = {
    where: PlanSemanalWhereUniqueInput
    data: XOR<PlanSemanalUpdateWithoutPmFrenteInput, PlanSemanalUncheckedUpdateWithoutPmFrenteInput>
  }

  export type PlanSemanalUpdateManyWithWhereWithoutPmFrenteInput = {
    where: PlanSemanalScalarWhereInput
    data: XOR<PlanSemanalUpdateManyMutationInput, PlanSemanalUncheckedUpdateManyWithoutPmFrenteInput>
  }

  export type PlanSemanalScalarWhereInput = {
    AND?: PlanSemanalScalarWhereInput | PlanSemanalScalarWhereInput[]
    OR?: PlanSemanalScalarWhereInput[]
    NOT?: PlanSemanalScalarWhereInput | PlanSemanalScalarWhereInput[]
    id_PlanSemanal?: IntFilter<"PlanSemanal"> | number
    descripcion?: StringFilter<"PlanSemanal"> | string
    fechaInicio?: DateTimeFilter<"PlanSemanal"> | Date | string
    fechaTermino?: DateTimeFilter<"PlanSemanal"> | Date | string
    pmFrenteId?: IntFilter<"PlanSemanal"> | number
  }

  export type PartidaCreateWithoutPmFrentePartidasInput = {
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hito: HitoCreateNestedOneWithoutPartidaInput
    procesoConstrutivo: ProcesoConstrutivoCreateNestedOneWithoutPartidaInput
    paqueteTrabajo: PaqueteTrabajoCreateNestedOneWithoutPartidaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUncheckedCreateWithoutPmFrentePartidasInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutPartidaInput
  }

  export type PartidaCreateOrConnectWithoutPmFrentePartidasInput = {
    where: PartidaWhereUniqueInput
    create: XOR<PartidaCreateWithoutPmFrentePartidasInput, PartidaUncheckedCreateWithoutPmFrentePartidasInput>
  }

  export type PmFrenteCreateWithoutPmFrentePartidasInput = {
    nombre: string
    planMaestro: PlanMaestroCreateNestedOneWithoutPmFrentesInput
    planSemanal?: PlanSemanalCreateNestedManyWithoutPmFrenteInput
  }

  export type PmFrenteUncheckedCreateWithoutPmFrentePartidasInput = {
    id_PmFrente?: number
    planMaestroId: number
    nombre: string
    planSemanal?: PlanSemanalUncheckedCreateNestedManyWithoutPmFrenteInput
  }

  export type PmFrenteCreateOrConnectWithoutPmFrentePartidasInput = {
    where: PmFrenteWhereUniqueInput
    create: XOR<PmFrenteCreateWithoutPmFrentePartidasInput, PmFrenteUncheckedCreateWithoutPmFrentePartidasInput>
  }

  export type PmProgramacionCreateWithoutPmFrentePartidaInput = {
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    vivienda: ViviendaCreateNestedOneWithoutPmProgramacionInput
  }

  export type PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput = {
    id_PmProgramacion?: number
    viviendaId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
  }

  export type PmProgramacionCreateOrConnectWithoutPmFrentePartidaInput = {
    where: PmProgramacionWhereUniqueInput
    create: XOR<PmProgramacionCreateWithoutPmFrentePartidaInput, PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput>
  }

  export type PmProgramacionCreateManyPmFrentePartidaInputEnvelope = {
    data: PmProgramacionCreateManyPmFrentePartidaInput | PmProgramacionCreateManyPmFrentePartidaInput[]
    skipDuplicates?: boolean
  }

  export type PartidaUpsertWithoutPmFrentePartidasInput = {
    update: XOR<PartidaUpdateWithoutPmFrentePartidasInput, PartidaUncheckedUpdateWithoutPmFrentePartidasInput>
    create: XOR<PartidaCreateWithoutPmFrentePartidasInput, PartidaUncheckedCreateWithoutPmFrentePartidasInput>
    where?: PartidaWhereInput
  }

  export type PartidaUpdateToOneWithWhereWithoutPmFrentePartidasInput = {
    where?: PartidaWhereInput
    data: XOR<PartidaUpdateWithoutPmFrentePartidasInput, PartidaUncheckedUpdateWithoutPmFrentePartidasInput>
  }

  export type PartidaUpdateWithoutPmFrentePartidasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hito?: HitoUpdateOneRequiredWithoutPartidaNestedInput
    procesoConstrutivo?: ProcesoConstrutivoUpdateOneRequiredWithoutPartidaNestedInput
    paqueteTrabajo?: PaqueteTrabajoUpdateOneRequiredWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateWithoutPmFrentePartidasInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaNestedInput
  }

  export type PmFrenteUpsertWithoutPmFrentePartidasInput = {
    update: XOR<PmFrenteUpdateWithoutPmFrentePartidasInput, PmFrenteUncheckedUpdateWithoutPmFrentePartidasInput>
    create: XOR<PmFrenteCreateWithoutPmFrentePartidasInput, PmFrenteUncheckedCreateWithoutPmFrentePartidasInput>
    where?: PmFrenteWhereInput
  }

  export type PmFrenteUpdateToOneWithWhereWithoutPmFrentePartidasInput = {
    where?: PmFrenteWhereInput
    data: XOR<PmFrenteUpdateWithoutPmFrentePartidasInput, PmFrenteUncheckedUpdateWithoutPmFrentePartidasInput>
  }

  export type PmFrenteUpdateWithoutPmFrentePartidasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    planMaestro?: PlanMaestroUpdateOneRequiredWithoutPmFrentesNestedInput
    planSemanal?: PlanSemanalUpdateManyWithoutPmFrenteNestedInput
  }

  export type PmFrenteUncheckedUpdateWithoutPmFrentePartidasInput = {
    id_PmFrente?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    planSemanal?: PlanSemanalUncheckedUpdateManyWithoutPmFrenteNestedInput
  }

  export type PmProgramacionUpsertWithWhereUniqueWithoutPmFrentePartidaInput = {
    where: PmProgramacionWhereUniqueInput
    update: XOR<PmProgramacionUpdateWithoutPmFrentePartidaInput, PmProgramacionUncheckedUpdateWithoutPmFrentePartidaInput>
    create: XOR<PmProgramacionCreateWithoutPmFrentePartidaInput, PmProgramacionUncheckedCreateWithoutPmFrentePartidaInput>
  }

  export type PmProgramacionUpdateWithWhereUniqueWithoutPmFrentePartidaInput = {
    where: PmProgramacionWhereUniqueInput
    data: XOR<PmProgramacionUpdateWithoutPmFrentePartidaInput, PmProgramacionUncheckedUpdateWithoutPmFrentePartidaInput>
  }

  export type PmProgramacionUpdateManyWithWhereWithoutPmFrentePartidaInput = {
    where: PmProgramacionScalarWhereInput
    data: XOR<PmProgramacionUpdateManyMutationInput, PmProgramacionUncheckedUpdateManyWithoutPmFrentePartidaInput>
  }

  export type PmProgramacionScalarWhereInput = {
    AND?: PmProgramacionScalarWhereInput | PmProgramacionScalarWhereInput[]
    OR?: PmProgramacionScalarWhereInput[]
    NOT?: PmProgramacionScalarWhereInput | PmProgramacionScalarWhereInput[]
    id_PmProgramacion?: IntFilter<"PmProgramacion"> | number
    viviendaId?: IntFilter<"PmProgramacion"> | number
    fechaInicio?: DateTimeFilter<"PmProgramacion"> | Date | string
    fechaFin?: DateTimeFilter<"PmProgramacion"> | Date | string
    cantidad?: IntFilter<"PmProgramacion"> | number
    pmFrentePartidaId?: IntFilter<"PmProgramacion"> | number
  }

  export type ViviendaCreateWithoutPmProgramacionInput = {
    numero: string
    id_Frente: string
    modeloVivienda: ModeloViviendaCreateNestedOneWithoutViviendaInput
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaUncheckedCreateWithoutPmProgramacionInput = {
    id_Vivienda?: number
    numero: string
    id_Frente: string
    modeloViviendaId: number
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaCreateOrConnectWithoutPmProgramacionInput = {
    where: ViviendaWhereUniqueInput
    create: XOR<ViviendaCreateWithoutPmProgramacionInput, ViviendaUncheckedCreateWithoutPmProgramacionInput>
  }

  export type PmFrentePartidaCreateWithoutPmProgramacionInput = {
    cuadrilla: number
    orden: number
    partida: PartidaCreateNestedOneWithoutPmFrentePartidasInput
    frente: PmFrenteCreateNestedOneWithoutPmFrentePartidasInput
  }

  export type PmFrentePartidaUncheckedCreateWithoutPmProgramacionInput = {
    id_PmFrentePartida?: number
    partidaId: number
    cuadrilla: number
    frenteId: number
    orden: number
  }

  export type PmFrentePartidaCreateOrConnectWithoutPmProgramacionInput = {
    where: PmFrentePartidaWhereUniqueInput
    create: XOR<PmFrentePartidaCreateWithoutPmProgramacionInput, PmFrentePartidaUncheckedCreateWithoutPmProgramacionInput>
  }

  export type ViviendaUpsertWithoutPmProgramacionInput = {
    update: XOR<ViviendaUpdateWithoutPmProgramacionInput, ViviendaUncheckedUpdateWithoutPmProgramacionInput>
    create: XOR<ViviendaCreateWithoutPmProgramacionInput, ViviendaUncheckedCreateWithoutPmProgramacionInput>
    where?: ViviendaWhereInput
  }

  export type ViviendaUpdateToOneWithWhereWithoutPmProgramacionInput = {
    where?: ViviendaWhereInput
    data: XOR<ViviendaUpdateWithoutPmProgramacionInput, ViviendaUncheckedUpdateWithoutPmProgramacionInput>
  }

  export type ViviendaUpdateWithoutPmProgramacionInput = {
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloVivienda?: ModeloViviendaUpdateOneRequiredWithoutViviendaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutViviendaNestedInput
  }

  export type ViviendaUncheckedUpdateWithoutPmProgramacionInput = {
    id_Vivienda?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloViviendaId?: IntFieldUpdateOperationsInput | number
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutViviendaNestedInput
  }

  export type PmFrentePartidaUpsertWithoutPmProgramacionInput = {
    update: XOR<PmFrentePartidaUpdateWithoutPmProgramacionInput, PmFrentePartidaUncheckedUpdateWithoutPmProgramacionInput>
    create: XOR<PmFrentePartidaCreateWithoutPmProgramacionInput, PmFrentePartidaUncheckedCreateWithoutPmProgramacionInput>
    where?: PmFrentePartidaWhereInput
  }

  export type PmFrentePartidaUpdateToOneWithWhereWithoutPmProgramacionInput = {
    where?: PmFrentePartidaWhereInput
    data: XOR<PmFrentePartidaUpdateWithoutPmProgramacionInput, PmFrentePartidaUncheckedUpdateWithoutPmProgramacionInput>
  }

  export type PmFrentePartidaUpdateWithoutPmProgramacionInput = {
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPmFrentePartidasNestedInput
    frente?: PmFrenteUpdateOneRequiredWithoutPmFrentePartidasNestedInput
  }

  export type PmFrentePartidaUncheckedUpdateWithoutPmProgramacionInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    frenteId?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoCreateWithoutEquipoCargoInput = {
    usuario: UsuarioCreateNestedOneWithoutPmEquipoInput
    equipoTrabajo: EquipoTrabajoCreateNestedOneWithoutPmEquipoInput
  }

  export type PmEquipoUncheckedCreateWithoutEquipoCargoInput = {
    id_PmEquipo?: number
    usuarioId: number
    equipoTrabajoId: number
  }

  export type PmEquipoCreateOrConnectWithoutEquipoCargoInput = {
    where: PmEquipoWhereUniqueInput
    create: XOR<PmEquipoCreateWithoutEquipoCargoInput, PmEquipoUncheckedCreateWithoutEquipoCargoInput>
  }

  export type PmEquipoCreateManyEquipoCargoInputEnvelope = {
    data: PmEquipoCreateManyEquipoCargoInput | PmEquipoCreateManyEquipoCargoInput[]
    skipDuplicates?: boolean
  }

  export type PmEquipoUpsertWithWhereUniqueWithoutEquipoCargoInput = {
    where: PmEquipoWhereUniqueInput
    update: XOR<PmEquipoUpdateWithoutEquipoCargoInput, PmEquipoUncheckedUpdateWithoutEquipoCargoInput>
    create: XOR<PmEquipoCreateWithoutEquipoCargoInput, PmEquipoUncheckedCreateWithoutEquipoCargoInput>
  }

  export type PmEquipoUpdateWithWhereUniqueWithoutEquipoCargoInput = {
    where: PmEquipoWhereUniqueInput
    data: XOR<PmEquipoUpdateWithoutEquipoCargoInput, PmEquipoUncheckedUpdateWithoutEquipoCargoInput>
  }

  export type PmEquipoUpdateManyWithWhereWithoutEquipoCargoInput = {
    where: PmEquipoScalarWhereInput
    data: XOR<PmEquipoUpdateManyMutationInput, PmEquipoUncheckedUpdateManyWithoutEquipoCargoInput>
  }

  export type PmEquipoScalarWhereInput = {
    AND?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
    OR?: PmEquipoScalarWhereInput[]
    NOT?: PmEquipoScalarWhereInput | PmEquipoScalarWhereInput[]
    id_PmEquipo?: IntFilter<"PmEquipo"> | number
    usuarioId?: IntFilter<"PmEquipo"> | number
    equipoTrabajoId?: IntFilter<"PmEquipo"> | number
    equipoCargoId?: IntFilter<"PmEquipo"> | number
  }

  export type PlanMaestroCreateWithoutEquipoTrabajosInput = {
    descripcion: string
    fechaInicio?: Date | string
    proyecto: ProyectoCreateNestedOneWithoutPlanMaestroInput
    pmFrentes?: PmFrenteCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroUncheckedCreateWithoutEquipoTrabajosInput = {
    id_PlanMaestro?: number
    descripcion: string
    fechaInicio?: Date | string
    proyectoId: number
    pmFrentes?: PmFrenteUncheckedCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroCreateOrConnectWithoutEquipoTrabajosInput = {
    where: PlanMaestroWhereUniqueInput
    create: XOR<PlanMaestroCreateWithoutEquipoTrabajosInput, PlanMaestroUncheckedCreateWithoutEquipoTrabajosInput>
  }

  export type PmEquipoCreateWithoutEquipoTrabajoInput = {
    usuario: UsuarioCreateNestedOneWithoutPmEquipoInput
    equipoCargo: EquipoCargoCreateNestedOneWithoutPmEquipoInput
  }

  export type PmEquipoUncheckedCreateWithoutEquipoTrabajoInput = {
    id_PmEquipo?: number
    usuarioId: number
    equipoCargoId: number
  }

  export type PmEquipoCreateOrConnectWithoutEquipoTrabajoInput = {
    where: PmEquipoWhereUniqueInput
    create: XOR<PmEquipoCreateWithoutEquipoTrabajoInput, PmEquipoUncheckedCreateWithoutEquipoTrabajoInput>
  }

  export type PmEquipoCreateManyEquipoTrabajoInputEnvelope = {
    data: PmEquipoCreateManyEquipoTrabajoInput | PmEquipoCreateManyEquipoTrabajoInput[]
    skipDuplicates?: boolean
  }

  export type PlanMaestroUpsertWithoutEquipoTrabajosInput = {
    update: XOR<PlanMaestroUpdateWithoutEquipoTrabajosInput, PlanMaestroUncheckedUpdateWithoutEquipoTrabajosInput>
    create: XOR<PlanMaestroCreateWithoutEquipoTrabajosInput, PlanMaestroUncheckedCreateWithoutEquipoTrabajosInput>
    where?: PlanMaestroWhereInput
  }

  export type PlanMaestroUpdateToOneWithWhereWithoutEquipoTrabajosInput = {
    where?: PlanMaestroWhereInput
    data: XOR<PlanMaestroUpdateWithoutEquipoTrabajosInput, PlanMaestroUncheckedUpdateWithoutEquipoTrabajosInput>
  }

  export type PlanMaestroUpdateWithoutEquipoTrabajosInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyecto?: ProyectoUpdateOneRequiredWithoutPlanMaestroNestedInput
    pmFrentes?: PmFrenteUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PlanMaestroUncheckedUpdateWithoutEquipoTrabajosInput = {
    id_PlanMaestro?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    proyectoId?: IntFieldUpdateOperationsInput | number
    pmFrentes?: PmFrenteUncheckedUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PmEquipoUpsertWithWhereUniqueWithoutEquipoTrabajoInput = {
    where: PmEquipoWhereUniqueInput
    update: XOR<PmEquipoUpdateWithoutEquipoTrabajoInput, PmEquipoUncheckedUpdateWithoutEquipoTrabajoInput>
    create: XOR<PmEquipoCreateWithoutEquipoTrabajoInput, PmEquipoUncheckedCreateWithoutEquipoTrabajoInput>
  }

  export type PmEquipoUpdateWithWhereUniqueWithoutEquipoTrabajoInput = {
    where: PmEquipoWhereUniqueInput
    data: XOR<PmEquipoUpdateWithoutEquipoTrabajoInput, PmEquipoUncheckedUpdateWithoutEquipoTrabajoInput>
  }

  export type PmEquipoUpdateManyWithWhereWithoutEquipoTrabajoInput = {
    where: PmEquipoScalarWhereInput
    data: XOR<PmEquipoUpdateManyMutationInput, PmEquipoUncheckedUpdateManyWithoutEquipoTrabajoInput>
  }

  export type UsuarioCreateWithoutPmEquipoInput = {
    nombre: string
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutResponsableInput
  }

  export type UsuarioUncheckedCreateWithoutPmEquipoInput = {
    id_Usuario?: number
    nombre: string
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UsuarioCreateOrConnectWithoutPmEquipoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPmEquipoInput, UsuarioUncheckedCreateWithoutPmEquipoInput>
  }

  export type EquipoTrabajoCreateWithoutPmEquipoInput = {
    PlanMaestro: PlanMaestroCreateNestedOneWithoutEquipoTrabajosInput
  }

  export type EquipoTrabajoUncheckedCreateWithoutPmEquipoInput = {
    id_EquipoTrabajo?: number
    planMaestroId: number
  }

  export type EquipoTrabajoCreateOrConnectWithoutPmEquipoInput = {
    where: EquipoTrabajoWhereUniqueInput
    create: XOR<EquipoTrabajoCreateWithoutPmEquipoInput, EquipoTrabajoUncheckedCreateWithoutPmEquipoInput>
  }

  export type EquipoCargoCreateWithoutPmEquipoInput = {
    nombre: string
    esActivo?: boolean
  }

  export type EquipoCargoUncheckedCreateWithoutPmEquipoInput = {
    id_EquipoCargo?: number
    nombre: string
    esActivo?: boolean
  }

  export type EquipoCargoCreateOrConnectWithoutPmEquipoInput = {
    where: EquipoCargoWhereUniqueInput
    create: XOR<EquipoCargoCreateWithoutPmEquipoInput, EquipoCargoUncheckedCreateWithoutPmEquipoInput>
  }

  export type UsuarioUpsertWithoutPmEquipoInput = {
    update: XOR<UsuarioUpdateWithoutPmEquipoInput, UsuarioUncheckedUpdateWithoutPmEquipoInput>
    create: XOR<UsuarioCreateWithoutPmEquipoInput, UsuarioUncheckedCreateWithoutPmEquipoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPmEquipoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPmEquipoInput, UsuarioUncheckedUpdateWithoutPmEquipoInput>
  }

  export type UsuarioUpdateWithoutPmEquipoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutResponsableNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPmEquipoInput = {
    id_Usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type EquipoTrabajoUpsertWithoutPmEquipoInput = {
    update: XOR<EquipoTrabajoUpdateWithoutPmEquipoInput, EquipoTrabajoUncheckedUpdateWithoutPmEquipoInput>
    create: XOR<EquipoTrabajoCreateWithoutPmEquipoInput, EquipoTrabajoUncheckedCreateWithoutPmEquipoInput>
    where?: EquipoTrabajoWhereInput
  }

  export type EquipoTrabajoUpdateToOneWithWhereWithoutPmEquipoInput = {
    where?: EquipoTrabajoWhereInput
    data: XOR<EquipoTrabajoUpdateWithoutPmEquipoInput, EquipoTrabajoUncheckedUpdateWithoutPmEquipoInput>
  }

  export type EquipoTrabajoUpdateWithoutPmEquipoInput = {
    PlanMaestro?: PlanMaestroUpdateOneRequiredWithoutEquipoTrabajosNestedInput
  }

  export type EquipoTrabajoUncheckedUpdateWithoutPmEquipoInput = {
    id_EquipoTrabajo?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipoCargoUpsertWithoutPmEquipoInput = {
    update: XOR<EquipoCargoUpdateWithoutPmEquipoInput, EquipoCargoUncheckedUpdateWithoutPmEquipoInput>
    create: XOR<EquipoCargoCreateWithoutPmEquipoInput, EquipoCargoUncheckedCreateWithoutPmEquipoInput>
    where?: EquipoCargoWhereInput
  }

  export type EquipoCargoUpdateToOneWithWhereWithoutPmEquipoInput = {
    where?: EquipoCargoWhereInput
    data: XOR<EquipoCargoUpdateWithoutPmEquipoInput, EquipoCargoUncheckedUpdateWithoutPmEquipoInput>
  }

  export type EquipoCargoUpdateWithoutPmEquipoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipoCargoUncheckedUpdateWithoutPmEquipoInput = {
    id_EquipoCargo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PmEquipoCreateWithoutUsuarioInput = {
    equipoTrabajo: EquipoTrabajoCreateNestedOneWithoutPmEquipoInput
    equipoCargo: EquipoCargoCreateNestedOneWithoutPmEquipoInput
  }

  export type PmEquipoUncheckedCreateWithoutUsuarioInput = {
    id_PmEquipo?: number
    equipoTrabajoId: number
    equipoCargoId: number
  }

  export type PmEquipoCreateOrConnectWithoutUsuarioInput = {
    where: PmEquipoWhereUniqueInput
    create: XOR<PmEquipoCreateWithoutUsuarioInput, PmEquipoUncheckedCreateWithoutUsuarioInput>
  }

  export type PmEquipoCreateManyUsuarioInputEnvelope = {
    data: PmEquipoCreateManyUsuarioInput | PmEquipoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PlanSemanalPartidaCreateWithoutResponsableInput = {
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
    partida: PartidaCreateNestedOneWithoutPlanSemanalPartidaInput
    vivienda: ViviendaCreateNestedOneWithoutPlanSemanalPartidaInput
    causaNoCumplimiento: CausaNoCumplimientoCreateNestedOneWithoutPlanSemanalPartidaInput
  }

  export type PlanSemanalPartidaUncheckedCreateWithoutResponsableInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaCreateOrConnectWithoutResponsableInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    create: XOR<PlanSemanalPartidaCreateWithoutResponsableInput, PlanSemanalPartidaUncheckedCreateWithoutResponsableInput>
  }

  export type PlanSemanalPartidaCreateManyResponsableInputEnvelope = {
    data: PlanSemanalPartidaCreateManyResponsableInput | PlanSemanalPartidaCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type PmEquipoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PmEquipoWhereUniqueInput
    update: XOR<PmEquipoUpdateWithoutUsuarioInput, PmEquipoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PmEquipoCreateWithoutUsuarioInput, PmEquipoUncheckedCreateWithoutUsuarioInput>
  }

  export type PmEquipoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PmEquipoWhereUniqueInput
    data: XOR<PmEquipoUpdateWithoutUsuarioInput, PmEquipoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PmEquipoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PmEquipoScalarWhereInput
    data: XOR<PmEquipoUpdateManyMutationInput, PmEquipoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PlanSemanalPartidaUpsertWithWhereUniqueWithoutResponsableInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    update: XOR<PlanSemanalPartidaUpdateWithoutResponsableInput, PlanSemanalPartidaUncheckedUpdateWithoutResponsableInput>
    create: XOR<PlanSemanalPartidaCreateWithoutResponsableInput, PlanSemanalPartidaUncheckedCreateWithoutResponsableInput>
  }

  export type PlanSemanalPartidaUpdateWithWhereUniqueWithoutResponsableInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    data: XOR<PlanSemanalPartidaUpdateWithoutResponsableInput, PlanSemanalPartidaUncheckedUpdateWithoutResponsableInput>
  }

  export type PlanSemanalPartidaUpdateManyWithWhereWithoutResponsableInput = {
    where: PlanSemanalPartidaScalarWhereInput
    data: XOR<PlanSemanalPartidaUpdateManyMutationInput, PlanSemanalPartidaUncheckedUpdateManyWithoutResponsableInput>
  }

  export type ViviendaCreateWithoutModeloViviendaInput = {
    numero: string
    id_Frente: string
    planSemanalPartida?: PlanSemanalPartidaCreateNestedManyWithoutViviendaInput
    pmProgramacion?: PmProgramacionCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaUncheckedCreateWithoutModeloViviendaInput = {
    id_Vivienda?: number
    numero: string
    id_Frente: string
    planSemanalPartida?: PlanSemanalPartidaUncheckedCreateNestedManyWithoutViviendaInput
    pmProgramacion?: PmProgramacionUncheckedCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaCreateOrConnectWithoutModeloViviendaInput = {
    where: ViviendaWhereUniqueInput
    create: XOR<ViviendaCreateWithoutModeloViviendaInput, ViviendaUncheckedCreateWithoutModeloViviendaInput>
  }

  export type ViviendaCreateManyModeloViviendaInputEnvelope = {
    data: ViviendaCreateManyModeloViviendaInput | ViviendaCreateManyModeloViviendaInput[]
    skipDuplicates?: boolean
  }

  export type ViviendaUpsertWithWhereUniqueWithoutModeloViviendaInput = {
    where: ViviendaWhereUniqueInput
    update: XOR<ViviendaUpdateWithoutModeloViviendaInput, ViviendaUncheckedUpdateWithoutModeloViviendaInput>
    create: XOR<ViviendaCreateWithoutModeloViviendaInput, ViviendaUncheckedCreateWithoutModeloViviendaInput>
  }

  export type ViviendaUpdateWithWhereUniqueWithoutModeloViviendaInput = {
    where: ViviendaWhereUniqueInput
    data: XOR<ViviendaUpdateWithoutModeloViviendaInput, ViviendaUncheckedUpdateWithoutModeloViviendaInput>
  }

  export type ViviendaUpdateManyWithWhereWithoutModeloViviendaInput = {
    where: ViviendaScalarWhereInput
    data: XOR<ViviendaUpdateManyMutationInput, ViviendaUncheckedUpdateManyWithoutModeloViviendaInput>
  }

  export type ViviendaScalarWhereInput = {
    AND?: ViviendaScalarWhereInput | ViviendaScalarWhereInput[]
    OR?: ViviendaScalarWhereInput[]
    NOT?: ViviendaScalarWhereInput | ViviendaScalarWhereInput[]
    id_Vivienda?: IntFilter<"Vivienda"> | number
    numero?: StringFilter<"Vivienda"> | string
    id_Frente?: StringFilter<"Vivienda"> | string
    modeloViviendaId?: IntFilter<"Vivienda"> | number
  }

  export type PlanMaestroCreateWithoutProyectoInput = {
    descripcion: string
    fechaInicio?: Date | string
    equipoTrabajos?: EquipoTrabajoCreateNestedManyWithoutPlanMaestroInput
    pmFrentes?: PmFrenteCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroUncheckedCreateWithoutProyectoInput = {
    id_PlanMaestro?: number
    descripcion: string
    fechaInicio?: Date | string
    equipoTrabajos?: EquipoTrabajoUncheckedCreateNestedManyWithoutPlanMaestroInput
    pmFrentes?: PmFrenteUncheckedCreateNestedManyWithoutPlanMaestroInput
  }

  export type PlanMaestroCreateOrConnectWithoutProyectoInput = {
    where: PlanMaestroWhereUniqueInput
    create: XOR<PlanMaestroCreateWithoutProyectoInput, PlanMaestroUncheckedCreateWithoutProyectoInput>
  }

  export type PlanMaestroCreateManyProyectoInputEnvelope = {
    data: PlanMaestroCreateManyProyectoInput | PlanMaestroCreateManyProyectoInput[]
    skipDuplicates?: boolean
  }

  export type PlanMaestroUpsertWithWhereUniqueWithoutProyectoInput = {
    where: PlanMaestroWhereUniqueInput
    update: XOR<PlanMaestroUpdateWithoutProyectoInput, PlanMaestroUncheckedUpdateWithoutProyectoInput>
    create: XOR<PlanMaestroCreateWithoutProyectoInput, PlanMaestroUncheckedCreateWithoutProyectoInput>
  }

  export type PlanMaestroUpdateWithWhereUniqueWithoutProyectoInput = {
    where: PlanMaestroWhereUniqueInput
    data: XOR<PlanMaestroUpdateWithoutProyectoInput, PlanMaestroUncheckedUpdateWithoutProyectoInput>
  }

  export type PlanMaestroUpdateManyWithWhereWithoutProyectoInput = {
    where: PlanMaestroScalarWhereInput
    data: XOR<PlanMaestroUpdateManyMutationInput, PlanMaestroUncheckedUpdateManyWithoutProyectoInput>
  }

  export type PlanMaestroScalarWhereInput = {
    AND?: PlanMaestroScalarWhereInput | PlanMaestroScalarWhereInput[]
    OR?: PlanMaestroScalarWhereInput[]
    NOT?: PlanMaestroScalarWhereInput | PlanMaestroScalarWhereInput[]
    id_PlanMaestro?: IntFilter<"PlanMaestro"> | number
    descripcion?: StringFilter<"PlanMaestro"> | string
    fechaInicio?: DateTimeFilter<"PlanMaestro"> | Date | string
    proyectoId?: IntFilter<"PlanMaestro"> | number
  }

  export type ModeloViviendaCreateWithoutViviendaInput = {
    nombre: string
    activo?: boolean
  }

  export type ModeloViviendaUncheckedCreateWithoutViviendaInput = {
    id_ModeloVivienda?: number
    nombre: string
    activo?: boolean
  }

  export type ModeloViviendaCreateOrConnectWithoutViviendaInput = {
    where: ModeloViviendaWhereUniqueInput
    create: XOR<ModeloViviendaCreateWithoutViviendaInput, ModeloViviendaUncheckedCreateWithoutViviendaInput>
  }

  export type PlanSemanalPartidaCreateWithoutViviendaInput = {
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
    partida: PartidaCreateNestedOneWithoutPlanSemanalPartidaInput
    causaNoCumplimiento: CausaNoCumplimientoCreateNestedOneWithoutPlanSemanalPartidaInput
    responsable: UsuarioCreateNestedOneWithoutPlanSemanalPartidaInput
  }

  export type PlanSemanalPartidaUncheckedCreateWithoutViviendaInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaCreateOrConnectWithoutViviendaInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    create: XOR<PlanSemanalPartidaCreateWithoutViviendaInput, PlanSemanalPartidaUncheckedCreateWithoutViviendaInput>
  }

  export type PlanSemanalPartidaCreateManyViviendaInputEnvelope = {
    data: PlanSemanalPartidaCreateManyViviendaInput | PlanSemanalPartidaCreateManyViviendaInput[]
    skipDuplicates?: boolean
  }

  export type PmProgramacionCreateWithoutViviendaInput = {
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    pmFrentePartida: PmFrentePartidaCreateNestedOneWithoutPmProgramacionInput
  }

  export type PmProgramacionUncheckedCreateWithoutViviendaInput = {
    id_PmProgramacion?: number
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    pmFrentePartidaId: number
  }

  export type PmProgramacionCreateOrConnectWithoutViviendaInput = {
    where: PmProgramacionWhereUniqueInput
    create: XOR<PmProgramacionCreateWithoutViviendaInput, PmProgramacionUncheckedCreateWithoutViviendaInput>
  }

  export type PmProgramacionCreateManyViviendaInputEnvelope = {
    data: PmProgramacionCreateManyViviendaInput | PmProgramacionCreateManyViviendaInput[]
    skipDuplicates?: boolean
  }

  export type ModeloViviendaUpsertWithoutViviendaInput = {
    update: XOR<ModeloViviendaUpdateWithoutViviendaInput, ModeloViviendaUncheckedUpdateWithoutViviendaInput>
    create: XOR<ModeloViviendaCreateWithoutViviendaInput, ModeloViviendaUncheckedCreateWithoutViviendaInput>
    where?: ModeloViviendaWhereInput
  }

  export type ModeloViviendaUpdateToOneWithWhereWithoutViviendaInput = {
    where?: ModeloViviendaWhereInput
    data: XOR<ModeloViviendaUpdateWithoutViviendaInput, ModeloViviendaUncheckedUpdateWithoutViviendaInput>
  }

  export type ModeloViviendaUpdateWithoutViviendaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModeloViviendaUncheckedUpdateWithoutViviendaInput = {
    id_ModeloVivienda?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanSemanalPartidaUpsertWithWhereUniqueWithoutViviendaInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    update: XOR<PlanSemanalPartidaUpdateWithoutViviendaInput, PlanSemanalPartidaUncheckedUpdateWithoutViviendaInput>
    create: XOR<PlanSemanalPartidaCreateWithoutViviendaInput, PlanSemanalPartidaUncheckedCreateWithoutViviendaInput>
  }

  export type PlanSemanalPartidaUpdateWithWhereUniqueWithoutViviendaInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    data: XOR<PlanSemanalPartidaUpdateWithoutViviendaInput, PlanSemanalPartidaUncheckedUpdateWithoutViviendaInput>
  }

  export type PlanSemanalPartidaUpdateManyWithWhereWithoutViviendaInput = {
    where: PlanSemanalPartidaScalarWhereInput
    data: XOR<PlanSemanalPartidaUpdateManyMutationInput, PlanSemanalPartidaUncheckedUpdateManyWithoutViviendaInput>
  }

  export type PmProgramacionUpsertWithWhereUniqueWithoutViviendaInput = {
    where: PmProgramacionWhereUniqueInput
    update: XOR<PmProgramacionUpdateWithoutViviendaInput, PmProgramacionUncheckedUpdateWithoutViviendaInput>
    create: XOR<PmProgramacionCreateWithoutViviendaInput, PmProgramacionUncheckedCreateWithoutViviendaInput>
  }

  export type PmProgramacionUpdateWithWhereUniqueWithoutViviendaInput = {
    where: PmProgramacionWhereUniqueInput
    data: XOR<PmProgramacionUpdateWithoutViviendaInput, PmProgramacionUncheckedUpdateWithoutViviendaInput>
  }

  export type PmProgramacionUpdateManyWithWhereWithoutViviendaInput = {
    where: PmProgramacionScalarWhereInput
    data: XOR<PmProgramacionUpdateManyMutationInput, PmProgramacionUncheckedUpdateManyWithoutViviendaInput>
  }

  export type PmFrenteCreateWithoutPlanSemanalInput = {
    nombre: string
    planMaestro: PlanMaestroCreateNestedOneWithoutPmFrentesInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutFrenteInput
  }

  export type PmFrenteUncheckedCreateWithoutPlanSemanalInput = {
    id_PmFrente?: number
    planMaestroId: number
    nombre: string
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutFrenteInput
  }

  export type PmFrenteCreateOrConnectWithoutPlanSemanalInput = {
    where: PmFrenteWhereUniqueInput
    create: XOR<PmFrenteCreateWithoutPlanSemanalInput, PmFrenteUncheckedCreateWithoutPlanSemanalInput>
  }

  export type PmFrenteUpsertWithoutPlanSemanalInput = {
    update: XOR<PmFrenteUpdateWithoutPlanSemanalInput, PmFrenteUncheckedUpdateWithoutPlanSemanalInput>
    create: XOR<PmFrenteCreateWithoutPlanSemanalInput, PmFrenteUncheckedCreateWithoutPlanSemanalInput>
    where?: PmFrenteWhereInput
  }

  export type PmFrenteUpdateToOneWithWhereWithoutPlanSemanalInput = {
    where?: PmFrenteWhereInput
    data: XOR<PmFrenteUpdateWithoutPlanSemanalInput, PmFrenteUncheckedUpdateWithoutPlanSemanalInput>
  }

  export type PmFrenteUpdateWithoutPlanSemanalInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    planMaestro?: PlanMaestroUpdateOneRequiredWithoutPmFrentesNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutFrenteNestedInput
  }

  export type PmFrenteUncheckedUpdateWithoutPlanSemanalInput = {
    id_PmFrente?: IntFieldUpdateOperationsInput | number
    planMaestroId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutFrenteNestedInput
  }

  export type PartidaCreateWithoutPlanSemanalPartidaInput = {
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hito: HitoCreateNestedOneWithoutPartidaInput
    procesoConstrutivo: ProcesoConstrutivoCreateNestedOneWithoutPartidaInput
    paqueteTrabajo: PaqueteTrabajoCreateNestedOneWithoutPartidaInput
    pmFrentePartidas?: PmFrentePartidaCreateNestedManyWithoutPartidaInput
  }

  export type PartidaUncheckedCreateWithoutPlanSemanalPartidaInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
    pmFrentePartidas?: PmFrentePartidaUncheckedCreateNestedManyWithoutPartidaInput
  }

  export type PartidaCreateOrConnectWithoutPlanSemanalPartidaInput = {
    where: PartidaWhereUniqueInput
    create: XOR<PartidaCreateWithoutPlanSemanalPartidaInput, PartidaUncheckedCreateWithoutPlanSemanalPartidaInput>
  }

  export type ViviendaCreateWithoutPlanSemanalPartidaInput = {
    numero: string
    id_Frente: string
    modeloVivienda: ModeloViviendaCreateNestedOneWithoutViviendaInput
    pmProgramacion?: PmProgramacionCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaUncheckedCreateWithoutPlanSemanalPartidaInput = {
    id_Vivienda?: number
    numero: string
    id_Frente: string
    modeloViviendaId: number
    pmProgramacion?: PmProgramacionUncheckedCreateNestedManyWithoutViviendaInput
  }

  export type ViviendaCreateOrConnectWithoutPlanSemanalPartidaInput = {
    where: ViviendaWhereUniqueInput
    create: XOR<ViviendaCreateWithoutPlanSemanalPartidaInput, ViviendaUncheckedCreateWithoutPlanSemanalPartidaInput>
  }

  export type CausaNoCumplimientoCreateWithoutPlanSemanalPartidaInput = {
    nombre: string
    esActivo?: boolean
  }

  export type CausaNoCumplimientoUncheckedCreateWithoutPlanSemanalPartidaInput = {
    id_CausaNoCumplimiento?: number
    nombre: string
    esActivo?: boolean
  }

  export type CausaNoCumplimientoCreateOrConnectWithoutPlanSemanalPartidaInput = {
    where: CausaNoCumplimientoWhereUniqueInput
    create: XOR<CausaNoCumplimientoCreateWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUncheckedCreateWithoutPlanSemanalPartidaInput>
  }

  export type UsuarioCreateWithoutPlanSemanalPartidaInput = {
    nombre: string
    pmEquipo?: PmEquipoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPlanSemanalPartidaInput = {
    id_Usuario?: number
    nombre: string
    pmEquipo?: PmEquipoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPlanSemanalPartidaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPlanSemanalPartidaInput, UsuarioUncheckedCreateWithoutPlanSemanalPartidaInput>
  }

  export type PartidaUpsertWithoutPlanSemanalPartidaInput = {
    update: XOR<PartidaUpdateWithoutPlanSemanalPartidaInput, PartidaUncheckedUpdateWithoutPlanSemanalPartidaInput>
    create: XOR<PartidaCreateWithoutPlanSemanalPartidaInput, PartidaUncheckedCreateWithoutPlanSemanalPartidaInput>
    where?: PartidaWhereInput
  }

  export type PartidaUpdateToOneWithWhereWithoutPlanSemanalPartidaInput = {
    where?: PartidaWhereInput
    data: XOR<PartidaUpdateWithoutPlanSemanalPartidaInput, PartidaUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type PartidaUpdateWithoutPlanSemanalPartidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hito?: HitoUpdateOneRequiredWithoutPartidaNestedInput
    procesoConstrutivo?: ProcesoConstrutivoUpdateOneRequiredWithoutPartidaNestedInput
    paqueteTrabajo?: PaqueteTrabajoUpdateOneRequiredWithoutPartidaNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateWithoutPlanSemanalPartidaInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutPartidaNestedInput
  }

  export type ViviendaUpsertWithoutPlanSemanalPartidaInput = {
    update: XOR<ViviendaUpdateWithoutPlanSemanalPartidaInput, ViviendaUncheckedUpdateWithoutPlanSemanalPartidaInput>
    create: XOR<ViviendaCreateWithoutPlanSemanalPartidaInput, ViviendaUncheckedCreateWithoutPlanSemanalPartidaInput>
    where?: ViviendaWhereInput
  }

  export type ViviendaUpdateToOneWithWhereWithoutPlanSemanalPartidaInput = {
    where?: ViviendaWhereInput
    data: XOR<ViviendaUpdateWithoutPlanSemanalPartidaInput, ViviendaUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type ViviendaUpdateWithoutPlanSemanalPartidaInput = {
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloVivienda?: ModeloViviendaUpdateOneRequiredWithoutViviendaNestedInput
    pmProgramacion?: PmProgramacionUpdateManyWithoutViviendaNestedInput
  }

  export type ViviendaUncheckedUpdateWithoutPlanSemanalPartidaInput = {
    id_Vivienda?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    modeloViviendaId?: IntFieldUpdateOperationsInput | number
    pmProgramacion?: PmProgramacionUncheckedUpdateManyWithoutViviendaNestedInput
  }

  export type CausaNoCumplimientoUpsertWithoutPlanSemanalPartidaInput = {
    update: XOR<CausaNoCumplimientoUpdateWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUncheckedUpdateWithoutPlanSemanalPartidaInput>
    create: XOR<CausaNoCumplimientoCreateWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUncheckedCreateWithoutPlanSemanalPartidaInput>
    where?: CausaNoCumplimientoWhereInput
  }

  export type CausaNoCumplimientoUpdateToOneWithWhereWithoutPlanSemanalPartidaInput = {
    where?: CausaNoCumplimientoWhereInput
    data: XOR<CausaNoCumplimientoUpdateWithoutPlanSemanalPartidaInput, CausaNoCumplimientoUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type CausaNoCumplimientoUpdateWithoutPlanSemanalPartidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CausaNoCumplimientoUncheckedUpdateWithoutPlanSemanalPartidaInput = {
    id_CausaNoCumplimiento?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    esActivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUpsertWithoutPlanSemanalPartidaInput = {
    update: XOR<UsuarioUpdateWithoutPlanSemanalPartidaInput, UsuarioUncheckedUpdateWithoutPlanSemanalPartidaInput>
    create: XOR<UsuarioCreateWithoutPlanSemanalPartidaInput, UsuarioUncheckedCreateWithoutPlanSemanalPartidaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPlanSemanalPartidaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPlanSemanalPartidaInput, UsuarioUncheckedUpdateWithoutPlanSemanalPartidaInput>
  }

  export type UsuarioUpdateWithoutPlanSemanalPartidaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    pmEquipo?: PmEquipoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPlanSemanalPartidaInput = {
    id_Usuario?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    pmEquipo?: PmEquipoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput = {
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
    partida: PartidaCreateNestedOneWithoutPlanSemanalPartidaInput
    vivienda: ViviendaCreateNestedOneWithoutPlanSemanalPartidaInput
    responsable: UsuarioCreateNestedOneWithoutPlanSemanalPartidaInput
  }

  export type PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaCreateOrConnectWithoutCausaNoCumplimientoInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    create: XOR<PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput>
  }

  export type PlanSemanalPartidaCreateManyCausaNoCumplimientoInputEnvelope = {
    data: PlanSemanalPartidaCreateManyCausaNoCumplimientoInput | PlanSemanalPartidaCreateManyCausaNoCumplimientoInput[]
    skipDuplicates?: boolean
  }

  export type PlanSemanalPartidaUpsertWithWhereUniqueWithoutCausaNoCumplimientoInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    update: XOR<PlanSemanalPartidaUpdateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedUpdateWithoutCausaNoCumplimientoInput>
    create: XOR<PlanSemanalPartidaCreateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedCreateWithoutCausaNoCumplimientoInput>
  }

  export type PlanSemanalPartidaUpdateWithWhereUniqueWithoutCausaNoCumplimientoInput = {
    where: PlanSemanalPartidaWhereUniqueInput
    data: XOR<PlanSemanalPartidaUpdateWithoutCausaNoCumplimientoInput, PlanSemanalPartidaUncheckedUpdateWithoutCausaNoCumplimientoInput>
  }

  export type PlanSemanalPartidaUpdateManyWithWhereWithoutCausaNoCumplimientoInput = {
    where: PlanSemanalPartidaScalarWhereInput
    data: XOR<PlanSemanalPartidaUpdateManyMutationInput, PlanSemanalPartidaUncheckedUpdateManyWithoutCausaNoCumplimientoInput>
  }

  export type PartidaCreateManyHitoInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    procesoConstrutivoId: number
    paqueteTrabajoId: number
  }

  export type PartidaUpdateWithoutHitoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    procesoConstrutivo?: ProcesoConstrutivoUpdateOneRequiredWithoutPartidaNestedInput
    paqueteTrabajo?: PaqueteTrabajoUpdateOneRequiredWithoutPartidaNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateWithoutHitoInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateManyWithoutHitoInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
  }

  export type PartidaCreateManyPaqueteTrabajoInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    procesoConstrutivoId: number
  }

  export type PartidaUpdateWithoutPaqueteTrabajoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hito?: HitoUpdateOneRequiredWithoutPartidaNestedInput
    procesoConstrutivo?: ProcesoConstrutivoUpdateOneRequiredWithoutPartidaNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateWithoutPaqueteTrabajoInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateManyWithoutPaqueteTrabajoInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    procesoConstrutivoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmFrentePartidaCreateManyPartidaInput = {
    id_PmFrentePartida?: number
    cuadrilla: number
    frenteId: number
    orden: number
  }

  export type PlanSemanalPartidaCreateManyPartidaInput = {
    id_PlanSemanalPartida?: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PmFrentePartidaUpdateWithoutPartidaInput = {
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    frente?: PmFrenteUpdateOneRequiredWithoutPmFrentePartidasNestedInput
    pmProgramacion?: PmProgramacionUpdateManyWithoutPmFrentePartidaNestedInput
  }

  export type PmFrentePartidaUncheckedUpdateWithoutPartidaInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    frenteId?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    pmProgramacion?: PmProgramacionUncheckedUpdateManyWithoutPmFrentePartidaNestedInput
  }

  export type PmFrentePartidaUncheckedUpdateManyWithoutPartidaInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    frenteId?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUpdateWithoutPartidaInput = {
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
    vivienda?: ViviendaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    causaNoCumplimiento?: CausaNoCumplimientoUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    responsable?: UsuarioUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
  }

  export type PlanSemanalPartidaUncheckedUpdateWithoutPartidaInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PartidaCreateManyProcesoConstrutivoInput = {
    id_Partida?: number
    nombre: string
    medida: string
    ritmo: string
    cuadrillasSugeridas: number
    hitoId: number
    paqueteTrabajoId: number
  }

  export type PartidaUpdateWithoutProcesoConstrutivoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hito?: HitoUpdateOneRequiredWithoutPartidaNestedInput
    paqueteTrabajo?: PaqueteTrabajoUpdateOneRequiredWithoutPartidaNestedInput
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateWithoutProcesoConstrutivoInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutPartidaNestedInput
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutPartidaNestedInput
  }

  export type PartidaUncheckedUpdateManyWithoutProcesoConstrutivoInput = {
    id_Partida?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    medida?: StringFieldUpdateOperationsInput | string
    ritmo?: StringFieldUpdateOperationsInput | string
    cuadrillasSugeridas?: IntFieldUpdateOperationsInput | number
    hitoId?: IntFieldUpdateOperationsInput | number
    paqueteTrabajoId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipoTrabajoCreateManyPlanMaestroInput = {
    id_EquipoTrabajo?: number
  }

  export type PmFrenteCreateManyPlanMaestroInput = {
    id_PmFrente?: number
    nombre: string
  }

  export type EquipoTrabajoUpdateWithoutPlanMaestroInput = {
    pmEquipo?: PmEquipoUpdateManyWithoutEquipoTrabajoNestedInput
  }

  export type EquipoTrabajoUncheckedUpdateWithoutPlanMaestroInput = {
    id_EquipoTrabajo?: IntFieldUpdateOperationsInput | number
    pmEquipo?: PmEquipoUncheckedUpdateManyWithoutEquipoTrabajoNestedInput
  }

  export type EquipoTrabajoUncheckedUpdateManyWithoutPlanMaestroInput = {
    id_EquipoTrabajo?: IntFieldUpdateOperationsInput | number
  }

  export type PmFrenteUpdateWithoutPlanMaestroInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    pmFrentePartidas?: PmFrentePartidaUpdateManyWithoutFrenteNestedInput
    planSemanal?: PlanSemanalUpdateManyWithoutPmFrenteNestedInput
  }

  export type PmFrenteUncheckedUpdateWithoutPlanMaestroInput = {
    id_PmFrente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    pmFrentePartidas?: PmFrentePartidaUncheckedUpdateManyWithoutFrenteNestedInput
    planSemanal?: PlanSemanalUncheckedUpdateManyWithoutPmFrenteNestedInput
  }

  export type PmFrenteUncheckedUpdateManyWithoutPlanMaestroInput = {
    id_PmFrente?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PmFrentePartidaCreateManyFrenteInput = {
    id_PmFrentePartida?: number
    partidaId: number
    cuadrilla: number
    orden: number
  }

  export type PlanSemanalCreateManyPmFrenteInput = {
    id_PlanSemanal?: number
    descripcion: string
    fechaInicio?: Date | string
    fechaTermino?: Date | string
  }

  export type PmFrentePartidaUpdateWithoutFrenteInput = {
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPmFrentePartidasNestedInput
    pmProgramacion?: PmProgramacionUpdateManyWithoutPmFrentePartidaNestedInput
  }

  export type PmFrentePartidaUncheckedUpdateWithoutFrenteInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
    pmProgramacion?: PmProgramacionUncheckedUpdateManyWithoutPmFrentePartidaNestedInput
  }

  export type PmFrentePartidaUncheckedUpdateManyWithoutFrenteInput = {
    id_PmFrentePartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    cuadrilla?: IntFieldUpdateOperationsInput | number
    orden?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalUpdateWithoutPmFrenteInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSemanalUncheckedUpdateWithoutPmFrenteInput = {
    id_PlanSemanal?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSemanalUncheckedUpdateManyWithoutPmFrenteInput = {
    id_PlanSemanal?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaTermino?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PmProgramacionCreateManyPmFrentePartidaInput = {
    id_PmProgramacion?: number
    viviendaId: number
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
  }

  export type PmProgramacionUpdateWithoutPmFrentePartidaInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    vivienda?: ViviendaUpdateOneRequiredWithoutPmProgramacionNestedInput
  }

  export type PmProgramacionUncheckedUpdateWithoutPmFrentePartidaInput = {
    id_PmProgramacion?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PmProgramacionUncheckedUpdateManyWithoutPmFrentePartidaInput = {
    id_PmProgramacion?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoCreateManyEquipoCargoInput = {
    id_PmEquipo?: number
    usuarioId: number
    equipoTrabajoId: number
  }

  export type PmEquipoUpdateWithoutEquipoCargoInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutPmEquipoNestedInput
    equipoTrabajo?: EquipoTrabajoUpdateOneRequiredWithoutPmEquipoNestedInput
  }

  export type PmEquipoUncheckedUpdateWithoutEquipoCargoInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    equipoTrabajoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoUncheckedUpdateManyWithoutEquipoCargoInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    equipoTrabajoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoCreateManyEquipoTrabajoInput = {
    id_PmEquipo?: number
    usuarioId: number
    equipoCargoId: number
  }

  export type PmEquipoUpdateWithoutEquipoTrabajoInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutPmEquipoNestedInput
    equipoCargo?: EquipoCargoUpdateOneRequiredWithoutPmEquipoNestedInput
  }

  export type PmEquipoUncheckedUpdateWithoutEquipoTrabajoInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    equipoCargoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoUncheckedUpdateManyWithoutEquipoTrabajoInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    equipoCargoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoCreateManyUsuarioInput = {
    id_PmEquipo?: number
    equipoTrabajoId: number
    equipoCargoId: number
  }

  export type PlanSemanalPartidaCreateManyResponsableInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PmEquipoUpdateWithoutUsuarioInput = {
    equipoTrabajo?: EquipoTrabajoUpdateOneRequiredWithoutPmEquipoNestedInput
    equipoCargo?: EquipoCargoUpdateOneRequiredWithoutPmEquipoNestedInput
  }

  export type PmEquipoUncheckedUpdateWithoutUsuarioInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    equipoTrabajoId?: IntFieldUpdateOperationsInput | number
    equipoCargoId?: IntFieldUpdateOperationsInput | number
  }

  export type PmEquipoUncheckedUpdateManyWithoutUsuarioInput = {
    id_PmEquipo?: IntFieldUpdateOperationsInput | number
    equipoTrabajoId?: IntFieldUpdateOperationsInput | number
    equipoCargoId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUpdateWithoutResponsableInput = {
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    vivienda?: ViviendaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    causaNoCumplimiento?: CausaNoCumplimientoUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
  }

  export type PlanSemanalPartidaUncheckedUpdateWithoutResponsableInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutResponsableInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type ViviendaCreateManyModeloViviendaInput = {
    id_Vivienda?: number
    numero: string
    id_Frente: string
  }

  export type ViviendaUpdateWithoutModeloViviendaInput = {
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    planSemanalPartida?: PlanSemanalPartidaUpdateManyWithoutViviendaNestedInput
    pmProgramacion?: PmProgramacionUpdateManyWithoutViviendaNestedInput
  }

  export type ViviendaUncheckedUpdateWithoutModeloViviendaInput = {
    id_Vivienda?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
    planSemanalPartida?: PlanSemanalPartidaUncheckedUpdateManyWithoutViviendaNestedInput
    pmProgramacion?: PmProgramacionUncheckedUpdateManyWithoutViviendaNestedInput
  }

  export type ViviendaUncheckedUpdateManyWithoutModeloViviendaInput = {
    id_Vivienda?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    id_Frente?: StringFieldUpdateOperationsInput | string
  }

  export type PlanMaestroCreateManyProyectoInput = {
    id_PlanMaestro?: number
    descripcion: string
    fechaInicio?: Date | string
  }

  export type PlanMaestroUpdateWithoutProyectoInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    equipoTrabajos?: EquipoTrabajoUpdateManyWithoutPlanMaestroNestedInput
    pmFrentes?: PmFrenteUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PlanMaestroUncheckedUpdateWithoutProyectoInput = {
    id_PlanMaestro?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    equipoTrabajos?: EquipoTrabajoUncheckedUpdateManyWithoutPlanMaestroNestedInput
    pmFrentes?: PmFrenteUncheckedUpdateManyWithoutPlanMaestroNestedInput
  }

  export type PlanMaestroUncheckedUpdateManyWithoutProyectoInput = {
    id_PlanMaestro?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSemanalPartidaCreateManyViviendaInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    causaNoCumplimientoId: number
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PmProgramacionCreateManyViviendaInput = {
    id_PmProgramacion?: number
    fechaInicio?: Date | string
    fechaFin?: Date | string
    cantidad: number
    pmFrentePartidaId: number
  }

  export type PlanSemanalPartidaUpdateWithoutViviendaInput = {
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    causaNoCumplimiento?: CausaNoCumplimientoUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    responsable?: UsuarioUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
  }

  export type PlanSemanalPartidaUncheckedUpdateWithoutViviendaInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutViviendaInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    causaNoCumplimientoId?: IntFieldUpdateOperationsInput | number
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PmProgramacionUpdateWithoutViviendaInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    pmFrentePartida?: PmFrentePartidaUpdateOneRequiredWithoutPmProgramacionNestedInput
  }

  export type PmProgramacionUncheckedUpdateWithoutViviendaInput = {
    id_PmProgramacion?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    pmFrentePartidaId?: IntFieldUpdateOperationsInput | number
  }

  export type PmProgramacionUncheckedUpdateManyWithoutViviendaInput = {
    id_PmProgramacion?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    pmFrentePartidaId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaCreateManyCausaNoCumplimientoInput = {
    id_PlanSemanalPartida?: number
    partidaId: number
    viviendaId: number
    revisionOk?: boolean
    id_UsuarioRevision: number
    fechaRevision?: Date | string
    observacion: string
    responsableId: number
    cantidadProgramada: Decimal | DecimalJsLike | number | string
    cantidadEjecutada: Decimal | DecimalJsLike | number | string
    id_Cuadrilla: number
  }

  export type PlanSemanalPartidaUpdateWithoutCausaNoCumplimientoInput = {
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
    partida?: PartidaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    vivienda?: ViviendaUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
    responsable?: UsuarioUpdateOneRequiredWithoutPlanSemanalPartidaNestedInput
  }

  export type PlanSemanalPartidaUncheckedUpdateWithoutCausaNoCumplimientoInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }

  export type PlanSemanalPartidaUncheckedUpdateManyWithoutCausaNoCumplimientoInput = {
    id_PlanSemanalPartida?: IntFieldUpdateOperationsInput | number
    partidaId?: IntFieldUpdateOperationsInput | number
    viviendaId?: IntFieldUpdateOperationsInput | number
    revisionOk?: BoolFieldUpdateOperationsInput | boolean
    id_UsuarioRevision?: IntFieldUpdateOperationsInput | number
    fechaRevision?: DateTimeFieldUpdateOperationsInput | Date | string
    observacion?: StringFieldUpdateOperationsInput | string
    responsableId?: IntFieldUpdateOperationsInput | number
    cantidadProgramada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidadEjecutada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_Cuadrilla?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}